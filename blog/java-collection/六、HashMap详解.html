<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>HashMap | GM的博客</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="stylesheet" href="/blog/custom.css">
    <script src="/blog/custom.js"></script>
    <meta name="description" content="博观约取、厚积薄发。">
    
    <link rel="preload" href="/blog/assets/css/0.styles.0612dbff.css" as="style"><link rel="preload" href="/blog/assets/js/app.f2787e20.js" as="script"><link rel="preload" href="/blog/assets/js/7.98eba54e.js" as="script"><link rel="preload" href="/blog/assets/js/2.5367abf9.js" as="script"><link rel="preload" href="/blog/assets/js/1.ae39e4f8.js" as="script"><link rel="preload" href="/blog/assets/js/47.745f27d2.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.524f93ca.js"><link rel="prefetch" href="/blog/assets/js/11.93985887.js"><link rel="prefetch" href="/blog/assets/js/14.c9e1e289.js"><link rel="prefetch" href="/blog/assets/js/15.926b1cd7.js"><link rel="prefetch" href="/blog/assets/js/16.5627e9c8.js"><link rel="prefetch" href="/blog/assets/js/17.d7f9401e.js"><link rel="prefetch" href="/blog/assets/js/18.94e52d84.js"><link rel="prefetch" href="/blog/assets/js/19.4cc4b37d.js"><link rel="prefetch" href="/blog/assets/js/20.7a174a7c.js"><link rel="prefetch" href="/blog/assets/js/21.4268d6f7.js"><link rel="prefetch" href="/blog/assets/js/22.f6b8bd65.js"><link rel="prefetch" href="/blog/assets/js/23.1ed14112.js"><link rel="prefetch" href="/blog/assets/js/24.9cbc74cf.js"><link rel="prefetch" href="/blog/assets/js/25.9e5d1b45.js"><link rel="prefetch" href="/blog/assets/js/26.692e69bd.js"><link rel="prefetch" href="/blog/assets/js/27.a396b304.js"><link rel="prefetch" href="/blog/assets/js/28.fbe9bcb5.js"><link rel="prefetch" href="/blog/assets/js/29.3015da07.js"><link rel="prefetch" href="/blog/assets/js/3.4054e9b0.js"><link rel="prefetch" href="/blog/assets/js/30.2962fbba.js"><link rel="prefetch" href="/blog/assets/js/31.39d4cb55.js"><link rel="prefetch" href="/blog/assets/js/32.97324ada.js"><link rel="prefetch" href="/blog/assets/js/33.72f5128a.js"><link rel="prefetch" href="/blog/assets/js/34.d9e34b8a.js"><link rel="prefetch" href="/blog/assets/js/35.c4f7378c.js"><link rel="prefetch" href="/blog/assets/js/36.71d98d02.js"><link rel="prefetch" href="/blog/assets/js/37.42f66454.js"><link rel="prefetch" href="/blog/assets/js/38.d0bbb2f7.js"><link rel="prefetch" href="/blog/assets/js/39.fad25426.js"><link rel="prefetch" href="/blog/assets/js/4.9dca7b48.js"><link rel="prefetch" href="/blog/assets/js/40.59506fc5.js"><link rel="prefetch" href="/blog/assets/js/41.fe5cb305.js"><link rel="prefetch" href="/blog/assets/js/42.a4476c8c.js"><link rel="prefetch" href="/blog/assets/js/43.d3e59daf.js"><link rel="prefetch" href="/blog/assets/js/44.35cb5387.js"><link rel="prefetch" href="/blog/assets/js/45.01a6487f.js"><link rel="prefetch" href="/blog/assets/js/46.691f9163.js"><link rel="prefetch" href="/blog/assets/js/48.b77d35b8.js"><link rel="prefetch" href="/blog/assets/js/49.29fe3ce5.js"><link rel="prefetch" href="/blog/assets/js/5.07cd297f.js"><link rel="prefetch" href="/blog/assets/js/50.cdb1f833.js"><link rel="prefetch" href="/blog/assets/js/51.c6e0135f.js"><link rel="prefetch" href="/blog/assets/js/52.b8c3e6db.js"><link rel="prefetch" href="/blog/assets/js/53.837f7482.js"><link rel="prefetch" href="/blog/assets/js/54.bff99f2a.js"><link rel="prefetch" href="/blog/assets/js/55.104079fd.js"><link rel="prefetch" href="/blog/assets/js/56.de4e487c.js"><link rel="prefetch" href="/blog/assets/js/57.4255693e.js"><link rel="prefetch" href="/blog/assets/js/58.e7392cd3.js"><link rel="prefetch" href="/blog/assets/js/59.85e468f0.js"><link rel="prefetch" href="/blog/assets/js/6.7f43b7a4.js"><link rel="prefetch" href="/blog/assets/js/60.d6cc488b.js"><link rel="prefetch" href="/blog/assets/js/61.8d1debea.js"><link rel="prefetch" href="/blog/assets/js/62.8a893f70.js"><link rel="prefetch" href="/blog/assets/js/63.547fa4e5.js"><link rel="prefetch" href="/blog/assets/js/64.1f654ee5.js"><link rel="prefetch" href="/blog/assets/js/65.e1585d3d.js"><link rel="prefetch" href="/blog/assets/js/66.536070ce.js"><link rel="prefetch" href="/blog/assets/js/67.9bb316fe.js"><link rel="prefetch" href="/blog/assets/js/68.452120de.js"><link rel="prefetch" href="/blog/assets/js/8.10fb926e.js"><link rel="prefetch" href="/blog/assets/js/9.bfffe90e.js"><link rel="prefetch" href="/blog/assets/js/vendors~docsearch.6e140397.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.0612dbff.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>GM的博客</h3> <p class="description" data-v-59e6cb88>博观约取、厚积薄发。</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2024
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/head.jpg" alt="GM的博客" class="logo"> <span class="site-name">GM的博客</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://deepjava-gm.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  首页
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      GM的博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/deepjava-gm" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/qq_37883866" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><!----> <!----> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>30</h3> <h6 data-v-1fad0c41>文章</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>0</h3> <h6 data-v-1fad0c41>标签</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="https://deepjava-gm.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  首页
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      GM的博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/deepjava-gm" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/qq_37883866" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/blog/" class="sidebar-heading clickable router-link-active"><span>构建自己的Java知识体系</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/" aria-current="page" class="sidebar-link">引言</a></li><li><a href="/blog/contact.html" class="sidebar-link">反馈</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/blog/javabase/一、Java基础知识" class="sidebar-heading clickable"><span>Java基础</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/blog/java-collection/一、Java集合概述" class="sidebar-heading clickable open"><span>Java集合</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/java-collection/一、Java集合概述.html" class="sidebar-link">一、Java集合概述</a></li><li><a href="/blog/java-collection/二、ArrayList详解.html" class="sidebar-link">二、ArrayList详解</a></li><li><a href="/blog/java-collection/三、LinkedList详解.html" class="sidebar-link">三、LinkedList详解</a></li><li><a href="/blog/java-collection/四、CopyOnWriteArrayList详解.html" class="sidebar-link">四、CopyOnWriteArrayList详解</a></li><li><a href="/blog/java-collection/五、Stack详解.html" class="sidebar-link">五、Stack详解</a></li><li><a href="/blog/java-collection/六、HashMap详解.html" class="active sidebar-link">六、HashMap详解</a></li><li><a href="/blog/java-collection/七、LinkedHashMap详解.html" class="sidebar-link">七、LinkedHashMap详解</a></li><li><a href="/blog/java-collection/八、ConcurrentHashMap详解.html" class="sidebar-link">八、ConcurrentHashMap详解</a></li><li><a href="/blog/java-collection/九、ArrayDeque详解.html" class="sidebar-link">九、ArrayDeque详解</a></li><li><a href="/blog/java-collection/十、BlockingQueue详解.html" class="sidebar-link">十、BlockingQueue详解</a></li><li><a href="/blog/java-collection/十一、PriorityQueue详解.html" class="sidebar-link">十一、PriorityQueue详解</a></li><li><a href="/blog/java-collection/十二、DelayQueue详解.html" class="sidebar-link">十二、DelayQueue详解</a></li><li><a href="/blog/java-collection/十三、ConcurrentLinkedQueue详解.html" class="sidebar-link">十三、ConcurrentLinkedQueue详解</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/blog/java-concurrent/一、Java并发编程基础知识点" class="sidebar-heading clickable"><span>Java并发编程</span> <span class="arrow right"></span></a> <!----></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88></h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2024
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">HashMap</h1> <div data-v-8a445198><!----> <!----> <!----> <!----></div></div> <div class="theme-reco-content content__default"><h1 id="hashmap"><a href="#hashmap" class="header-anchor">#</a> HashMap</h1> <p>基于JDK8。<br>
HashMap在我们的日常开发中是十分常用的键值对集合,我们来深入探究下HashMap的设计。</p> <h2 id="_1、hashmap的继承体系"><a href="#_1、hashmap的继承体系" class="header-anchor">#</a> 1、HashMap的继承体系</h2> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword">implements</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> <span class="token class-name">Serializable</span>
</code></pre></div><img src="/blog/images/21-1.png" alt="mixureSecure"> <h2 id="_2、hashmap底层数据结构"><a href="#_2、hashmap底层数据结构" class="header-anchor">#</a> 2、HashMap底层数据结构</h2> <p>这里先把答案给出。<br>
稍后再去探究，为什么使用链表处理哈希冲突，JDK8为什么引入红黑树，红黑树的数据结构有什么特点，为什么会用64,  8, 6这几个数字作为阈值？为什么元素个数达到容量的0.75倍时就扩容？</p> <p>JDK8之前 是<strong>数组 + 链表</strong> 。<br>
JDK8 是<strong>数组 + 链表|红黑树</strong>。</p> <p>JDK8之前 是<strong>数组 + 链表</strong> 。</p> <img src="/blog/images/21-14.png" alt="mixureSecure"> <p>JDK8 是<strong>数组 + 链表|红黑树</strong>。</p> <img src="/blog/images/21-15.png" alt="mixureSecure"> <p>链表的主要目的是解决哈希冲突（hash collision）问题。</p> <p><strong>JDK8的HashMap链表转换为红黑树的条件：</strong><br>
链表长度 &gt;= 8<br>
数组容量 &gt;= 64</p> <p><strong>红黑树转换回链表的条件：</strong><br>
红黑树节点数 &lt;= 6</p> <h2 id="_3、hashmap的构造函数"><a href="#_3、hashmap的构造函数" class="header-anchor">#</a> 3、HashMap的构造函数</h2> <h3 id="_1、无参构造"><a href="#_1、无参构造" class="header-anchor">#</a> ①、无参构造</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 加载因子，用于控制哈希表的扩容频率</span>
<span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span>

<span class="token comment">// 默认的加载因子</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> <span class="token constant">DEFAULT_LOAD_FACTOR</span> <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 使用默认的加载因子</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> <span class="token constant">DEFAULT_LOAD_FACTOR</span><span class="token punctuation">;</span> <span class="token comment">// all other fields defaulted</span>
    <span class="token punctuation">}</span>
</code></pre></div><h3 id="_2、有参构造1-和-有参构造2-可以自定义初始容量和负载因子"><a href="#_2、有参构造1-和-有参构造2-可以自定义初始容量和负载因子" class="header-anchor">#</a> ②、有参构造1 和 有参构造2 (可以自定义初始容量和负载因子)</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 加载因子，用于控制哈希表的扩容频率</span>
<span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span>

<span class="token comment">// 默认的加载因子</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> <span class="token constant">DEFAULT_LOAD_FACTOR</span> <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span>

<span class="token comment">// 哈希表的最大容量    2的30次方   1,073,741,824   10亿多</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span>

<span class="token comment">// 扩容阈值，当哈希表中元素个数超过这个值时，会触发扩容</span>
<span class="token keyword">int</span> threshold<span class="token punctuation">;</span>

<span class="token comment">/**
 * 有参构造函数1：只接受初始容量参数
 * @param initialCapacity 初始容量
 */</span>
<span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 调用另一个构造函数，使用默认加载因子</span>
    <span class="token keyword">this</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> <span class="token constant">DEFAULT_LOAD_FACTOR</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 有参构造函数2：接受初始容量和加载因子参数
 * @param initialCapacity 初始容量
 * @param loadFactor 加载因子
 */</span>
<span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 检查初始容量是否为负数，如果是负数，抛出非法参数异常</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">&quot;Illegal initial capacity: &quot;</span> <span class="token operator">+</span> initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 如果初始容量超过最大容量，则将初始容量设置为最大容量</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&gt;</span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">)</span>
        initialCapacity <span class="token operator">=</span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">;</span>

    <span class="token comment">// 检查加载因子是否有效，如果小于等于0或不是一个有效数字，则抛出非法参数异常</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>loadFactor <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token class-name">Float</span><span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span>loadFactor<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">&quot;Illegal load factor: &quot;</span> <span class="token operator">+</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 设置实例的加载因子</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> loadFactor<span class="token punctuation">;</span>

    <span class="token comment">// 根据初始容量计算扩容阈值</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 计算大于等于给定容量的最小2的幂次方值
 * @param cap 给定的容量值
 * @return 大于等于cap的最小2的幂次方值
 */</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> cap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> cap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">// 将所有位置为1的位向右传播</span>
    n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>
    n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">2</span><span class="token punctuation">;</span>
    n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">4</span><span class="token punctuation">;</span>
    n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">8</span><span class="token punctuation">;</span>
    n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">;</span>

    <span class="token comment">// 确保返回值在合法范围内</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">:</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>这里再抛一个问题，为什么我们传自定义大小的容量，HashMap要调用tableSizeFor方法取大于等于自定义容量的最小2的幂次方值。
比如我们传入35，tableSizeFor计算得出36 ，HashMap就使用36作为容量。这个问题也在后面进行探究。</p> <h3 id="_3、有参构造3-接受一个map参数"><a href="#_3、有参构造3-接受一个map参数" class="header-anchor">#</a> ③、有参构造3(接受一个Map参数)</h3> <p>这个构造方法就比较复杂了，涉及添加元素和扩容等操作，暂时就不展开了，后面单独去看添加元素和扩容操作。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 加载因子，用于控制哈希表的扩容频率</span>
<span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span>

<span class="token comment">// 默认的加载因子</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> <span class="token constant">DEFAULT_LOAD_FACTOR</span> <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span>

<span class="token comment">// 哈希表的最大容量，2的30次方，即1,073,741,824（10亿多）</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span>

<span class="token comment">// 哈希表的底层数组，存储键值对</span>
<span class="token keyword">transient</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>

<span class="token comment">// 扩容阈值，当哈希表中元素个数超过这个值时，会触发扩容</span>
<span class="token keyword">int</span> threshold<span class="token punctuation">;</span>

<span class="token comment">/**
 * 有参构造函数3：接受一个Map参数
 * @param m 初始化时用的Map
 */</span>
<span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 使用默认加载因子</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> <span class="token constant">DEFAULT_LOAD_FACTOR</span><span class="token punctuation">;</span>
    <span class="token comment">// 将传入的Map中的所有元素添加到当前HashMap中</span>
    <span class="token function">putMapEntries</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 将指定的Map中的所有元素添加到当前HashMap中
 * @param m 指定的Map
 * @param evict 是否驱逐旧元素（此参数在其他上下文中使用，这里传入false）
 */</span>
<span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">putMapEntries</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> m<span class="token punctuation">,</span> <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取指定Map的大小</span>
    <span class="token keyword">int</span> s <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果当前哈希表还未初始化（即底层数组为空）</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>table <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 预先调整大小</span>
            <span class="token comment">// 计算预期的扩容阈值，公式为：(指定Map的大小 / 加载因子) + 1</span>
            <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>s <span class="token operator">/</span> loadFactor<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1.0F</span><span class="token punctuation">;</span>
            <span class="token comment">// 如果计算结果小于最大容量，则取计算结果，否则取最大容量</span>
            <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 如果计算结果大于当前的扩容阈值，则更新扩容阈值</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">&gt;</span> threshold<span class="token punctuation">)</span>
                threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 如果当前哈希表已初始化，并且指定Map的大小超过了当前的扩容阈值</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">&gt;</span> threshold<span class="token punctuation">)</span>
            <span class="token comment">// 扩容哈希表</span>
            <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 将指定Map中的每个键值对添加到当前哈希表中</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e <span class="token operator">:</span> m<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">K</span> key <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">V</span> value <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 使用putVal方法添加键值对</span>
            <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> evict<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 计算给定键的哈希值
 * @param key 给定的键
 * @return 哈希值
 */</span>
<span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> h<span class="token punctuation">;</span>
    <span class="token comment">// 计算哈希值，并进行哈希扰动，增加哈希分布的随机性</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
  
</code></pre></div><p>可以看到这里的<code>final int hash(Object key)</code>方法是对键的hashCode进行二次hash的方法。</p> <h3 id="jdk-8之前版本的哈希方法"><a href="#jdk-8之前版本的哈希方法" class="header-anchor">#</a> JDK 8之前版本的哈希方法：</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    h <span class="token operator">^=</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>JDK 7的hash方法通过异或操作 (^) 和右移操作 (&gt;&gt;&gt;) 对原始哈希码进行扰动，以减少冲突。</p> <h3 id="jdk-8版本的哈希方法"><a href="#jdk-8版本的哈希方法" class="header-anchor">#</a> JDK 8版本的哈希方法</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * 计算给定键的哈希值
 * @param key 给定的键
 * @return 哈希值
 */</span>
<span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> h<span class="token punctuation">;</span>
    <span class="token comment">// 计算哈希值，并进行哈希扰动，增加哈希分布的随机性</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>JDK 8 通过将哈希码右移16位并与原始哈希码异或 <code>(h = key.hashCode() ^ (key.hashCode() &gt;&gt;&gt; 16))</code> 来扰动哈希码，提高哈希分布的随机性。</p> <p>JDK 8的扰动方式计算步骤更简单高效，有助于减少哈希冲突，提高哈希表的性能。</p> <h2 id="_4、拉链法解决哈希冲突"><a href="#_4、拉链法解决哈希冲突" class="header-anchor">#</a> 4、拉链法解决哈希冲突</h2> <h3 id="什么是拉链法"><a href="#什么是拉链法" class="header-anchor">#</a> 什么是拉链法？</h3> <p>拉链法就是数组和链表结合，每个数组的元素存储的是一个链表（或在JDK 8中链表长度超过一定阈值时使用红黑树）。当发生哈希冲突时，只需要将新的元素插入链表或树中。</p> <img src="/blog/images/21-2.png" alt="mixureSecure"> <p>上图中a,c,d元素由于哈希冲突，就组成了一个链表，当我们查找d时，先计算出下标index是1，发现链表的头是a不是d，就继续向下遍历链表直到找到d为止。</p> <h3 id="动画演示拉链法解决哈希冲突"><a href="#动画演示拉链法解决哈希冲突" class="header-anchor">#</a> 动画演示拉链法解决哈希冲突：</h3> <img src="/blog/images/21-3.gif" alt="mixureSecure"> <h3 id="拉链法有哪些好处-还有其他解决哈希冲突的方式吗"><a href="#拉链法有哪些好处-还有其他解决哈希冲突的方式吗" class="header-anchor">#</a> 拉链法有哪些好处？ 还有其他解决哈希冲突的方式吗？</h3> <p><strong>拉链法解决哈希冲突的优点：</strong></p> <ul><li><p>①.简单高效：拉链法实现起来相对简单，每个数组元素存储的是一个链表。当发生哈希冲突时，只需要将新的元素插入链表中，插入和查找操作的平均时间复杂度较低。</p></li> <li><p>②、空间利用率高：拉链法在冲突发生时不需要额外的数组空间，只需在链表中插入新节点，节省空间。</p></li> <li><p>③、动态扩展：JDK8使用的链表和红黑树都能动态地扩展，不需要预先分配大量内存，并且在元素很多时可以通过扩容数组(哈希表)来降低每个链表的长度，维持高效的查找性能。</p></li> <li><p>④、易于实现的扩容机制：在拉链法中，扩容只需重新分配一个更大的数组，然后重新哈希现有的元素。这一过程较为简单(实际上JDK通过特殊的手段让重新计算扩容后的元素位置变得简单，这个手段就是数组(哈希表)的容量永远都是2的整数倍)，不需要处理复杂的元素迁移问题。</p></li></ul> <p><strong>其他解决哈希冲突的方式(了解下)：</strong></p> <p><strong>再哈希法（Rehashing）：</strong>
    使用不同的哈希函数重新计算发生冲突的元素的位置。再哈希法会在原哈希函数发生冲突时，使用一个新的哈希函数重新计算索引,需要再次计算哈希值，性能较低，特别是多次哈希冲突的情况下。</p> <p><strong>Cuckoo Hashing（布谷鸟哈希）：</strong>
    使用两个或更多的哈希函数和两个或更多的哈希表。当一个位置发生冲突时，将现有元素移到它的另一个可能位置（类似于布谷鸟在鸟巢中下蛋），如果新位置也有冲突，则继续迁移，直到找到一个空位或达到迁移限制。</p> <p><strong>开放地址法（Open Addressing）：</strong></p> <ul><li>线性探测（Linear Probing）：当发生冲突时，按固定步长（通常为1）向前探测下一个位置，直到找到一个空位或回到原位置。</li> <li>二次探测（Quadratic Probing）：探测步长按平方序列增长（如1, 4, 9, 16...），以减少聚集效应。</li> <li>双重散列（Double Hashing）：使用两个不同的哈希函数，当第一个哈希函数发生冲突时，用第二个哈希函数计算探测步长。</li></ul> <p><strong>线性散列法（Linear Hashing）：</strong>
    一种动态哈希方法，通过渐进式地扩展哈希表来处理冲突。在需要扩展时，不是一次性重新分配整个哈希表，而是渐进地调整部分元素的位置。</p> <p><strong>Hopscotch Hashing（跳跃哈希）：</strong>
    结合开放地址法和链表法的优点。当冲突发生时，在一定范围内探测并交换元素，使得链表的元素能保持接近原位置，减少查找路径长度。</p> <h2 id="_5、hashmap的put方法"><a href="#_5、hashmap的put方法" class="header-anchor">#</a> 5、HashMap的<code>put</code>方法</h2> <p>（涉及到扩容、树化、反树化等操作）</p> <h3 id="hashmap的属性注释"><a href="#hashmap的属性注释" class="header-anchor">#</a> HashMap的属性注释</h3> <p>HashMap的属性太多了，每次都在方法上面加上一些类的属性比较麻烦，这里把所有的属性都注释下。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword">implements</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span> 
	
    <span class="token comment">// 默认初始容量，即2的4次方，即哈希表的默认大小为16</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">DEFAULT_INITIAL_CAPACITY</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span>

    
    <span class="token comment">// 哈希表的最大容量，即2的30次方，即1073741824</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span>

   
    <span class="token comment">// 默认的加载因子，即哈希表的装填因子，默认为0.75</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> <span class="token constant">DEFAULT_LOAD_FACTOR</span> <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span>
	
    <span class="token comment">// 树化阈值，当链表长度 &gt;= 8且 容量&gt;=64时，链表转为红黑树</span>
	<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">TREEIFY_THRESHOLD</span> <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>

    <span class="token comment">// 反树化阈值，当红黑树节点数量小于等于6时，红黑树转为链表</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">UNTREEIFY_THRESHOLD</span> <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>

    <span class="token comment">// 最小树化容量，即哈希表的最小容量为64时，链表可以转为红黑树</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MIN_TREEIFY_CAPACITY</span> <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span>
	
	
	<span class="token comment">// 哈希表的底层数组，存储键值对，也就是HashMap底层的数组类型是Node&lt;K,V&gt; </span>
	<span class="token keyword">transient</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>

    <span class="token comment">// 键值对集合的视图，用于遍历哈希表中的所有键值对</span>
    <span class="token keyword">transient</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> entrySet<span class="token punctuation">;</span>

    <span class="token comment">// 哈希表中元素的数量</span>
    <span class="token keyword">transient</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>

    <span class="token comment">// 哈希表结构修改的次数，用于迭代器快速失败机制</span>
    <span class="token keyword">transient</span> <span class="token keyword">int</span> modCount<span class="token punctuation">;</span>

    <span class="token comment">// 哈希表扩容阈值，当哈希表中元素个数超过这个值时会触发扩容</span>
    <span class="token keyword">int</span> threshold<span class="token punctuation">;</span>

    <span class="token comment">// 加载因子，用于控制哈希表的扩容频率</span>
    <span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span>

<span class="token punctuation">}</span>


</code></pre></div><h3 id="put方法"><a href="#put方法" class="header-anchor">#</a> <code>put</code>方法</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 调用putVal方法将键值对插入到哈希表中</span>
    <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><h3 id="putval方法"><a href="#putval方法" class="header-anchor">#</a> <code>putVal</code>方法</h3> <p><code>boolean evict</code>,该参数指示当前的操作是否在创建模式下。如果为 false，表示哈希表处于创建模式；<br>
如果为 true，表示哈希表处于正常操作模式。此参数通常在调整哈希表大小时使用，以避免在创建模式中触发删除操作。</p> <p><strong>evict 参数为 false 的情况：</strong><br>
在哈希表初始化或扩容时，通过 putMapEntries 方法调用 putVal，设置 evict 为 false。</p> <p><strong>evict 参数为 true 的情况：</strong><br>
正常操作（非创建模式）下，插入或更新元素时，evict 为 true，允许执行淘汰策略。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span> <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span>  <span class="token comment">// 哈希表(数组)</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">;</span>      <span class="token comment">// 当前处理的节点</span>
    <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>         <span class="token comment">// n为表的长度，i为计算出的索引</span>

    <span class="token comment">// 如果哈希表为空或哈希表的长度为0，则进行扩容操作</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>

    <span class="token comment">// 计算哈希值对应的索引，如果该索引处没有节点，则创建新节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span>  <span class="token comment">// 临时节点，用于存储当前节点或找到的目标节点</span>
        <span class="token class-name">K</span> k<span class="token punctuation">;</span>          <span class="token comment">// 临时变量，用于存储节点的键</span>

        <span class="token comment">// 判断第一个节点的哈希值和键是否与插入的相同</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            e <span class="token operator">=</span> p<span class="token punctuation">;</span>  
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>
            <span class="token comment">// 如果当前节点是树节点，则调用树节点的插入方法</span>
            e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">// 如果当前节点不是树节点 遍历链表进行插入操作</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 如果当前节点的下一个节点为空，表示到达链表末端</span>
                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在链表末尾插入新的节点</span>
                    <span class="token comment">// 如果链表长度超过树化阈值 8 ，则 调用treeifyBin </span>
                    <span class="token comment">// 在 treeifyBin 中会判断 哈希表容量是否 &gt;=64 如果 哈希表容量&gt;=64 则树化，否则先扩容  </span>
                    <span class="token comment">// 注意 binCount 从 0 开始计数，表示遍历链表时访问的节点数，但插入新节点时实际的节点总数是 binCount + 1</span>
                    <span class="token comment">// TREEIFY_THRESHOLD - 1 = 8-1 = 7  所以binCount=7时  节点总数是 8 正好达到了阈值</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">&gt;=</span> <span class="token constant">TREEIFY_THRESHOLD</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> 
                        <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                 <span class="token comment">// 如果找到哈希值相同并且键相同的节点</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// 结束循环</span>
                <span class="token comment">// 移动到链表的下一个节点,继续下一次循环</span>
                p <span class="token operator">=</span> e<span class="token punctuation">;</span> 
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 如果找到了相同的键，则更新值</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">V</span> oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
            <span class="token comment">// 插入后进行后续处理  可以给HashMap的子类做扩展  </span>
            <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 增加修改次数</span>
    <span class="token operator">++</span>modCount<span class="token punctuation">;</span>
    <span class="token comment">// 如果当前元素个数超过阈值，则进行扩容操作</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">&gt;</span> threshold<span class="token punctuation">)</span>
        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 插入后进行后续处理 可以给HashMap的子类做扩展  </span>
    <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="puttreeval方法"><a href="#puttreeval方法" class="header-anchor">#</a> <code>putTreeVal</code>方法</h3> <p>添加红黑树节点</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 在红黑树中插入一个新的节点，或者返回已存在的节点</span>
<span class="token keyword">final</span> <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> map<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span>
                                       <span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token class-name">K</span> k<span class="token punctuation">,</span> <span class="token class-name">V</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// kc是用于比较的类</span>
    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> kc <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token comment">// searched表示是否已经搜索过树</span>
    <span class="token keyword">boolean</span> searched <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token comment">// 如果当前节点有父节点，则获取树的根节点，否则使用当前节点</span>
    <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> root <span class="token operator">=</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">root</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token comment">// 从根节点开始遍历树</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p <span class="token operator">=</span> root<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// dir表示比较方向，ph是当前节点的哈希值，pk是当前节点的键</span>
        <span class="token keyword">int</span> dir<span class="token punctuation">,</span> ph<span class="token punctuation">;</span> <span class="token class-name">K</span> pk<span class="token punctuation">;</span>
        <span class="token comment">// 如果当前节点的哈希值大于待插入节点的哈希值，dir设为-1（左子树）</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ph <span class="token operator">=</span> p<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">&gt;</span> h<span class="token punctuation">)</span>
            dir <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token comment">// 如果当前节点的哈希值小于待插入节点的哈希值，dir设为1（右子树）</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ph <span class="token operator">&lt;</span> h<span class="token punctuation">)</span>
            dir <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token comment">// 如果当前节点的哈希值等于待插入节点的哈希值，比较键</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pk <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> k <span class="token operator">||</span> <span class="token punctuation">(</span>k <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> k<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>pk<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token comment">// 键相同，返回当前节点</span>
            <span class="token keyword">return</span> p<span class="token punctuation">;</span>
        <span class="token comment">// 如果kc为null，尝试获取k的可比较类</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>kc <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>
                  <span class="token punctuation">(</span>kc <span class="token operator">=</span> <span class="token function">comparableClassFor</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">||</span>
                 <span class="token comment">// 使用可比较类比较键，结果为0表示键相同</span>
                 <span class="token punctuation">(</span>dir <span class="token operator">=</span> <span class="token function">compareComparables</span><span class="token punctuation">(</span>kc<span class="token punctuation">,</span> k<span class="token punctuation">,</span> pk<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 如果还没有搜索过子树</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>searched<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> q<span class="token punctuation">,</span> ch<span class="token punctuation">;</span>
                <span class="token comment">// 标记为已搜索</span>
                searched <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token comment">// 在左子树和右子树中查找</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ch <span class="token operator">=</span> p<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>
                     <span class="token punctuation">(</span>q <span class="token operator">=</span> ch<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> k<span class="token punctuation">,</span> kc<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">||</span>
                    <span class="token punctuation">(</span><span class="token punctuation">(</span>ch <span class="token operator">=</span> p<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>
                     <span class="token punctuation">(</span>q <span class="token operator">=</span> ch<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> k<span class="token punctuation">,</span> kc<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token comment">// 找到节点则返回</span>
                    <span class="token keyword">return</span> q<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 使用tie-break规则决定插入方向</span>
            dir <span class="token operator">=</span> <span class="token function">tieBreakOrder</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> pk<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 保存当前节点为xp</span>
        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> xp <span class="token operator">=</span> p<span class="token punctuation">;</span>
        <span class="token comment">// 根据dir决定向左还是向右</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token punctuation">(</span>dir <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> p<span class="token punctuation">.</span>left <span class="token operator">:</span> p<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 创建一个新节点</span>
            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> xpn <span class="token operator">=</span> xp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> x <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">newTreeNode</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> k<span class="token punctuation">,</span> v<span class="token punctuation">,</span> xpn<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 插入到左子树或者右子树</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>dir <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
                xp<span class="token punctuation">.</span>left <span class="token operator">=</span> x<span class="token punctuation">;</span>
            <span class="token keyword">else</span>
                xp<span class="token punctuation">.</span>right <span class="token operator">=</span> x<span class="token punctuation">;</span>
            <span class="token comment">// 更新链表结构</span>
            xp<span class="token punctuation">.</span>next <span class="token operator">=</span> x<span class="token punctuation">;</span>
            x<span class="token punctuation">.</span>parent <span class="token operator">=</span> x<span class="token punctuation">.</span>prev <span class="token operator">=</span> xp<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>xpn <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>xpn<span class="token punctuation">)</span><span class="token punctuation">.</span>prev <span class="token operator">=</span> x<span class="token punctuation">;</span>
            <span class="token comment">// 平衡树并将根节点移动到数组前端</span>
            <span class="token function">moveRootToFront</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> <span class="token function">balanceInsertion</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 返回null表示插入成功</span>
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="treeifybin-方法"><a href="#treeifybin-方法" class="header-anchor">#</a> <code>treeifyBin</code> 方法</h3> <p>将哈希桶中的链表转换为红黑树</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">treeifyBin</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> <span class="token keyword">int</span> hash<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> n<span class="token punctuation">,</span> index<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span>
    <span class="token comment">// 检查哈希表是否为空，或者表的长度是否小于最小树化容量</span>
    <span class="token comment">// MIN_TREEIFY_CAPACITY 是一个常量（通常为64），表示树化所需的最小表大小</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token constant">MIN_TREEIFY_CAPACITY</span><span class="token punctuation">)</span>
        <span class="token comment">// 如果条件满足，则调整哈希表大小，而不是树化</span>
        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> tab<span class="token punctuation">[</span>index <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果计算出的索引处的桶不为空，则进行树化操作</span>
        <span class="token comment">// 初始化树节点列表的头和尾</span>
        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> hd <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> tl <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">do</span> <span class="token punctuation">{</span>
            <span class="token comment">// 将当前链表节点转换为树节点</span>
            <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p <span class="token operator">=</span> <span class="token function">replacementTreeNode</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>tl <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                <span class="token comment">// 如果这是第一个节点，将其设为头节点</span>
                hd <span class="token operator">=</span> p<span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token comment">// 否则，将当前节点链接到前一个节点</span>
                p<span class="token punctuation">.</span>prev <span class="token operator">=</span> tl<span class="token punctuation">;</span>
                tl<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 将尾节点移动到当前节点</span>
            tl <span class="token operator">=</span> p<span class="token punctuation">;</span>
        <span class="token comment">// 继续处理下一个节点，直到链表结束</span>
        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 将树化后的头节点放入桶中，并调用树化方法</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> hd<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            hd<span class="token punctuation">.</span><span class="token function">treeify</span><span class="token punctuation">(</span>tab<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><h3 id="node-k-v-静态内部类"><a href="#node-k-v-静态内部类" class="header-anchor">#</a> <code>Node&lt;K,V&gt;静态内部类</code></h3> <p>HashMap的数组中保存的就是Node&lt;K,V&gt;</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span>  <span class="token comment">// 键的哈希值</span>
    <span class="token keyword">final</span> <span class="token class-name">K</span> key<span class="token punctuation">;</span>     <span class="token comment">// 键</span>
    <span class="token class-name">V</span> value<span class="token punctuation">;</span>         <span class="token comment">// 值</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span>  <span class="token comment">// 指向下一个节点    这里可以看出 是单向链表结构</span>

    <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>hash <span class="token operator">=</span> hash<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><h3 id="resize方法"><a href="#resize方法" class="header-anchor">#</a> <code>resize</code>方法</h3> <p>扩容方法</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span> <span class="token comment">// 获取当前哈希表</span>
    <span class="token keyword">int</span> oldCap <span class="token operator">=</span> <span class="token punctuation">(</span>oldTab <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment">// 获取当前哈希表的容量，如果为空则为0</span>
    <span class="token keyword">int</span> oldThr <span class="token operator">=</span> threshold<span class="token punctuation">;</span> <span class="token comment">// 获取当前的扩容阈值</span>
    <span class="token keyword">int</span> newCap<span class="token punctuation">,</span> newThr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 声明新的容量和新的扩容阈值</span>

    <span class="token comment">// 如果当前哈希表的容量大于0</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果当前容量已经达到最大值，则将扩容阈值设为最大整数值，并返回当前表</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">&gt;=</span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            threshold <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">;</span> <span class="token comment">// 将阈值设为最大整数值</span>
            <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span> <span class="token comment">// 返回当前表</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 如果当前容量未达到最大值</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">&amp;&amp;</span> oldCap <span class="token operator">&gt;=</span> <span class="token constant">DEFAULT_INITIAL_CAPACITY</span><span class="token punctuation">)</span>
            newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 将容量和扩容阈值翻倍</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 如果当前容量为0但扩容阈值大于0（即初始化时的情况）</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// initial capacity was placed in threshold</span>
        newCap <span class="token operator">=</span> oldThr<span class="token punctuation">;</span> <span class="token comment">// 将新容量设为当前的阈值</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 否则使用默认初始值</span>
        newCap <span class="token operator">=</span> <span class="token constant">DEFAULT_INITIAL_CAPACITY</span><span class="token punctuation">;</span> <span class="token comment">// 使用默认初始容量</span>
        newThr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token constant">DEFAULT_LOAD_FACTOR</span> <span class="token operator">*</span> <span class="token constant">DEFAULT_INITIAL_CAPACITY</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根据默认负载因子和默认初始容量计算新的扩容阈值</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 如果新的扩容阈值为0，根据负载因子和新容量计算新的扩容阈值</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newThr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>newCap <span class="token operator">*</span> loadFactor<span class="token punctuation">;</span> <span class="token comment">// 计算新的扩容阈值</span>
        newThr <span class="token operator">=</span> <span class="token punctuation">(</span>newCap <span class="token operator">&lt;</span> <span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">&amp;&amp;</span> ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根据新容量和负载因子计算新的阈值，确保不超过最大容量</span>
    <span class="token punctuation">}</span>
    threshold <span class="token operator">=</span> newThr<span class="token punctuation">;</span> <span class="token comment">// 更新扩容阈值</span>
    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">&quot;rawtypes&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;unchecked&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 创建新的哈希表</span>
    table <span class="token operator">=</span> newTab<span class="token punctuation">;</span> <span class="token comment">// 更新哈希表引用</span>

    <span class="token comment">// 如果旧表不为空，将旧表中的元素重新散列到新表中</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 遍历旧表</span>
            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果旧表的当前桶不为空</span>
                oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 释放旧表的当前桶</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// 如果桶中只有一个节点</span>
                    newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span> <span class="token comment">// 重新计算索引并放入新表</span>
                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span> <span class="token comment">// 如果桶中是红黑树节点</span>
                    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 拆分红黑树</span>
                <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 否则是链表节点</span>
                    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> loHead <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> loTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 定义低位链表的头尾节点</span>
                    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> hiHead <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> hiTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 定义高位链表的头尾节点</span>
                    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span>
                    <span class="token keyword">do</span> <span class="token punctuation">{</span>
                        next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment">// 暂存下一个节点</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 根据旧容量的高位判断新索引</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// 如果低位链表为空</span>
                                loHead <span class="token operator">=</span> e<span class="token punctuation">;</span> <span class="token comment">// 设置低位链表的头节点</span>
                            <span class="token keyword">else</span>
                                loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span> <span class="token comment">// 追加到低位链表的尾部</span>
                            loTail <span class="token operator">=</span> e<span class="token punctuation">;</span> <span class="token comment">// 更新低位链表的尾节点</span>
                        <span class="token punctuation">}</span>
                        <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 如果是高位链表</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// 如果高位链表为空</span>
                                hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span> <span class="token comment">// 设置高位链表的头节点</span>
                            <span class="token keyword">else</span>
                                hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span> <span class="token comment">// 追加到高位链表的尾部</span>
                            hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span> <span class="token comment">// 更新高位链表的尾节点</span>
                        <span class="token punctuation">}</span>
                    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 遍历链表中的所有节点</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果低位链表不为空</span>
                        loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 断开链表</span>
                        newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span> <span class="token comment">// 将低位链表放入新表</span>
                    <span class="token punctuation">}</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果高位链表不为空</span>
                        hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 断开链表</span>
                        newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span> <span class="token comment">// 将高位链表放入新表</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> newTab<span class="token punctuation">;</span> <span class="token comment">// 返回新的哈希表</span>
<span class="token punctuation">}</span>

</code></pre></div><h3 id="split方法"><a href="#split方法" class="header-anchor">#</a> <code>split</code>方法</h3> <p>split 方法用于在哈希表扩容时，重新分配红黑树节点到新的哈希表桶中。
在拆分过程中，原桶中的红黑树节点被分配到两个链表中。<br>
低位链表和高位链表分别表示原桶和新桶中的元素。
这是为了保证新哈希表的负载均匀性，并且避免在扩容过程中造成哈希冲突过多。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">split</span><span class="token punctuation">(</span><span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> map<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> bit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> b <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token comment">// 当前树节点</span>
    <span class="token comment">// 初始化低位和高位链表的头尾节点</span>
    <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> loHead <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> loTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> hiHead <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> hiTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> lc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> hc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 低位和高位链表的节点计数</span>

    <span class="token comment">// 遍历当前树节点的所有节点</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> b<span class="token punctuation">,</span> next<span class="token punctuation">;</span> e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        next <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>e<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment">// 暂存下一个节点</span>
        e<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 断开当前节点的 next 引用</span>

        <span class="token comment">// 根据 bit 的值决定节点放入低位链表还是高位链表</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> bit<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>prev <span class="token operator">=</span> loTail<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// 如果低位链表尾节点为空，说明是第一个节点</span>
                loHead <span class="token operator">=</span> e<span class="token punctuation">;</span> <span class="token comment">// 设置低位链表的头节点</span>
            <span class="token keyword">else</span>
                loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span> <span class="token comment">// 否则将当前节点连接到尾节点</span>
            loTail <span class="token operator">=</span> e<span class="token punctuation">;</span> <span class="token comment">// 更新低位链表的尾节点</span>
            <span class="token operator">++</span>lc<span class="token punctuation">;</span> <span class="token comment">// 低位链表节点计数增加</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>prev <span class="token operator">=</span> hiTail<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// 如果高位链表尾节点为空，说明是第一个节点</span>
                hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span> <span class="token comment">// 设置高位链表的头节点</span>
            <span class="token keyword">else</span>
                hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span> <span class="token comment">// 否则将当前节点连接到尾节点</span>
            hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span> <span class="token comment">// 更新高位链表的尾节点</span>
            <span class="token operator">++</span>hc<span class="token punctuation">;</span> <span class="token comment">// 高位链表节点计数增加</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 如果低位链表不为空</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>loHead <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果低位链表的节点数小于等于阈值，转换为链表结构</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>lc <span class="token operator">&lt;=</span> <span class="token constant">UNTREEIFY_THRESHOLD</span><span class="token punctuation">)</span>
            tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">.</span><span class="token function">untreeify</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将低位链表转换为普通链表并放入新表</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span>
            tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span> <span class="token comment">// 否则直接将低位链表放入新表</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>hiHead <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// 如果高位链表不为空，说明原来是红黑树结构</span>
                loHead<span class="token punctuation">.</span><span class="token function">treeify</span><span class="token punctuation">(</span>tab<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将低位链表重新组织为红黑树结构</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 如果高位链表不为空</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>hiHead <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果高位链表的节点数小于等于阈值 默认是6，转换为链表结构</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>hc <span class="token operator">&lt;=</span> <span class="token constant">UNTREEIFY_THRESHOLD</span><span class="token punctuation">)</span>
            tab<span class="token punctuation">[</span>index <span class="token operator">+</span> bit<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">.</span><span class="token function">untreeify</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将高位链表转换为普通链表并放入新表</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span>
            tab<span class="token punctuation">[</span>index <span class="token operator">+</span> bit<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span> <span class="token comment">// 否则直接将高位链表放入新表</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>loHead <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// 如果低位链表不为空，说明原来是红黑树结构</span>
                hiHead<span class="token punctuation">.</span><span class="token function">treeify</span><span class="token punctuation">(</span>tab<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将高位链表重新组织为红黑树结构</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 树转化为链表</span>
<span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">untreeify</span><span class="token punctuation">(</span><span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> map<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> hd <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> tl <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 初始化新的链表头节点和尾节点</span>
    <span class="token comment">// 遍历当前的树节点，将其转换为链表节点</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> q <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span> q <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> q <span class="token operator">=</span> q<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">replacementNode</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将树节点转换为普通链表节点</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>tl <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// 如果链表尾节点为空，说明是第一个节点</span>
            hd <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment">// 设置链表头节点</span>
        <span class="token keyword">else</span>
            tl<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment">// 否则将当前节点连接到尾节点的 next 引用</span>
        tl <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment">// 更新链表尾节点</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> hd<span class="token punctuation">;</span> <span class="token comment">// 返回新的链表头节点</span>
<span class="token punctuation">}</span>

</code></pre></div><h3 id="afternodeaccess方法"><a href="#afternodeaccess方法" class="header-anchor">#</a> <code>afterNodeAccess</code>方法</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 在节点访问后进行的回调方法</span>
<span class="token keyword">void</span> <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 此方法在访问节点后被调用，具体的实现可以在子类中覆盖  </span>
    <span class="token comment">// 体现了面向对象设计原则中的 开闭原则，对修改关闭对扩展开放</span>
<span class="token punctuation">}</span>

</code></pre></div><h3 id="afternodeinsertion方法"><a href="#afternodeinsertion方法" class="header-anchor">#</a> <code>afterNodeInsertion</code>方法</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 在节点插入后进行的回调方法</span>
<span class="token keyword">void</span> <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 此方法在插入节点后被调用，具体的实现可以在子类中覆盖</span>
     <span class="token comment">// 体现了面向对象设计原则中的 开闭原则，对修改关闭对扩展开放</span>
<span class="token punctuation">}</span>

</code></pre></div><h3 id="hashmap的put方法执行流程图示"><a href="#hashmap的put方法执行流程图示" class="header-anchor">#</a> HashMap的<code>put</code>方法执行流程图示</h3> <img src="/blog/images/21-4.png" alt="mixureSecure"> <p><strong>这里有个点需要注意下：</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 如果onlyIfAbsent是false 或者 oldValue 是null  就会新值替换旧值</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                    e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
</code></pre></div><p>所以调用HashMap的 putIfAbsent方法时要注意，如果key已存在且旧值是null ，那么即使key存在也会替换旧值。
代码示例：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> hashMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        hashMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        hashMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;putIfAbsent之前&quot;</span><span class="token operator">+</span>hashMap<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 之前的 key  a 对应的 value 是null 所以仍然会替换</span>
        hashMap<span class="token punctuation">.</span><span class="token function">putIfAbsent</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;123&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 之前的 key  b 对应的 value  是b 所以不会替换</span>
        hashMap<span class="token punctuation">.</span><span class="token function">putIfAbsent</span><span class="token punctuation">(</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;123&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;putIfAbsent之后&quot;</span><span class="token operator">+</span>hashMap<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>执行结果：</p> <div class="language-shell extra-class"><pre class="language-shell"><code>putIfAbsent之前<span class="token punctuation">{</span>a<span class="token operator">=</span>null, <span class="token assign-left variable">b</span><span class="token operator">=</span>b<span class="token punctuation">}</span>
putIfAbsent之后<span class="token punctuation">{</span>a<span class="token operator">=</span><span class="token number">123</span>, <span class="token assign-left variable">b</span><span class="token operator">=</span>b<span class="token punctuation">}</span>
</code></pre></div><h2 id="_6、hashmap如何计算key的索引位置"><a href="#_6、hashmap如何计算key的索引位置" class="header-anchor">#</a> 6、HashMap如何计算key的索引位置</h2> <p>下面是<code>putVal</code>方法内的一段源码，可以看到 索引 i = (n - 1) &amp; hash, 也就是索引等于 哈希表(数组)的长度 &amp; key调用 hash(key)方法得到的值。</p> <div class="language-java extra-class"><pre class="language-java"><code> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>         <span class="token comment">// n为表的长度，i为计算出的索引</span>

<span class="token comment">// 如果表为空或表的长度为0，则进行扩容操作</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>

<span class="token comment">// 计算哈希值对应的索引，如果该索引处没有节点，则创建新节点</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
    tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这里我们再来探讨上面提过的哈希表容量的问题。</p> <h3 id="为什么hashmap的容量设计成总是2的整数倍"><a href="#为什么hashmap的容量设计成总是2的整数倍" class="header-anchor">#</a> 为什么HashMap的容量设计成总是2的整数倍？</h3> <ul><li><strong>①、更高效的计算索引：</strong> 我们一般计算索引都是使用 key的哈希值对容量求余数，也就是 hash%容量 ，在计算机内部直接使用%求余性能比较低，就像我们直接使用乘法符号计算2乘2 (2*2)   和使用移位运算符 2 &lt;&lt; 1 得到的结果是一致的，但是移位运算比直接 使用乘法符号计算快的多，这是由计算机操作系统本身对算术运算的设计规则决定的。</li></ul> <p>由于 table.length 总是 2 的幂次方，那么 table.length - 1 就是一个全为 1 的二进制数，这样可以高效地与哈希值进行按位与运算，快速得到索引。</p> <p>当容量n 是2的整数倍时  计算 索引 i = (n - 1) &amp; hash 和  i = hash%n 结果是一样的。这也就解释了 HashMap的容量设计成2的整数倍的第一个好处。<br>
比如： 容量  n = 16  ， hash = 3  ，  索引 i = (16-1) &amp; 3 = 3;</p> <img src="/blog/images/21-5.png" alt="mixureSecure"> <p>索引  i = 3%16 也等于3。</p> <ul><li><p><strong>②、更好的哈希分布：</strong> 将容量设置为 2 的幂次方，有助于避免哈希碰撞，并使得哈希值的低位和高位都能有效参与到索引计算中。因为使用按位与运算时，所有位都能参与到索引的计算中，如果容量不是 2 的幂次方，那么某些位可能永远不会参与到计算中，这会导致哈希分布不均匀，增加哈希冲突的概率。</p></li> <li><p><strong>③、高效的扩容操作:</strong> 这点设计是真的厉害，在扩容时，新的容量也是 2 的幂次方，这样可以保持上述优点。而且扩容后，旧表中的元素可以很容易地重新分配到新表中，只需根据元素的哈希值和新表的容量重新计算索引即可。这使得扩容操作更加高效。</p></li></ul> <p>扩容时只需要检查元素的哈希值的新增位是 0 还是 1 来决定它是留在原索引位置还是移动到新索引位置：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 留在原索引位置</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 移动到新索引位置</span>
    <span class="token comment">// 新索引的位置 =  旧索引位置 + 旧容量</span>
<span class="token punctuation">}</span>
</code></pre></div><p>更精妙的是，新索引的位置直接就等于 旧位置 + 旧容量。
这里举个例子计算一下：</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token number">1</span>.如果 <span class="token punctuation">(</span>e.hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span>，元素留在原索引位置。
<span class="token number">2</span>.如果 <span class="token punctuation">(</span>e.hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span>，元素移动到新索引位置：旧索引位置 + 旧容量。

假设扩容前哈希表长度为8 ,  扩容后哈希表长度为16

情况2举例说明：

假设 a的hash值为10

扩容前a的索引位置： i <span class="token operator">=</span> <span class="token number">10</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token number">8</span>-1<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">10</span>%8 <span class="token operator">=</span> <span class="token number">2</span>

扩容后a的索引位置： 
先计算 <span class="token number">10</span><span class="token operator">&amp;</span><span class="token number">8</span> <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">!=</span> <span class="token number">0</span> , 新索引位置 i <span class="token operator">=</span> 旧索引位置<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> + 旧容量<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">10</span>

如果我们直接计算新索引位置 i <span class="token operator">=</span> <span class="token number">10</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token number">16</span>-1<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">10</span>%16 <span class="token operator">=</span> <span class="token number">10</span> 和上面计算结果一致


情况2举例说明：
假设 b的hash值为2

扩容前b的索引位置： i <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token number">8</span>-1<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">2</span>%8 <span class="token operator">=</span> <span class="token number">2</span>

扩容后b的索引位置： 
先计算 <span class="token number">2</span><span class="token operator">&amp;</span><span class="token number">8</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">==</span> <span class="token number">0</span> , 新索引位置 i <span class="token operator">=</span> 旧索引位置<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>

如果我们直接计算新索引位置 i <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token number">16</span>-1<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">2</span>%16 <span class="token operator">=</span> <span class="token number">2</span> 和上面计算结果一致
</code></pre></div><p><strong>还有一些其他好处：</strong><br>
    容量总是 2 的幂次方使得很多实现细节变得简单而高效。比如计算容量、计算阈值、扩容等操作都可以利用位运算来实现，减少了代码的复杂度和运行时的开销。</p> <p>    由于哈希表的负载因子通常设定为 0.75，当容量为 2 的幂次方时，可以保证在触发扩容时，哈希表的装载程度接近于最佳状态，避免了过度扩容或者装载过高导致的性能问题。</p> <h2 id="_7、hashmap的get方法"><a href="#_7、hashmap的get方法" class="header-anchor">#</a> 7、HashMap的<code>get</code>方法</h2> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 获取指定键的值</span>
<span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 调用 getNode 方法查找键对应的节点，如果找到则返回节点的值，否则返回 null</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 根据 hash 值和键查找节点</span>
<span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 定义一些局部变量</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span>       <span class="token comment">// 哈希表</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> first<span class="token punctuation">,</span> e<span class="token punctuation">;</span>    <span class="token comment">// 链表中的节点</span>
    <span class="token keyword">int</span> n<span class="token punctuation">;</span>                 <span class="token comment">// 哈希表的长度</span>
    <span class="token class-name">K</span> k<span class="token punctuation">;</span>                   <span class="token comment">// 节点中的键</span>

    <span class="token comment">// 如果哈希表不为空并且长度大于 0，并且对应哈希桶中第一个节点不为空</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>
        <span class="token punctuation">(</span>first <span class="token operator">=</span> tab<span class="token punctuation">[</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 检查第一个节点</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> 
            <span class="token comment">// 比较键是否相等（引用相等或者内容相等）</span>
            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> first<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token comment">// 如果第一个节点就是我们要找的，直接返回</span>
            <span class="token keyword">return</span> first<span class="token punctuation">;</span>
        <span class="token comment">// 如果第一个节点不是我们要找的，并且有后续节点</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> first<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 如果是树节点（红黑树）</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>
                <span class="token comment">// 在树中查找节点</span>
                <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>first<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTreeNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 否则在链表中查找</span>
            <span class="token keyword">do</span> <span class="token punctuation">{</span>
                <span class="token comment">// 比较每一个节点的哈希值和键</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token comment">// 找到匹配的节点</span>
                    <span class="token keyword">return</span> e<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 遍历链表</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 如果没有找到，返回 null</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>红黑树的查找 <code>getTreeNode</code> 方法就不看了，感兴趣的可以自己到源码里看。<br>
后续写数据结构和算法之类的文章会再看这类实现特定数据结构的源码。</p> <h2 id="_8、hashmap的remove方法"><a href="#_8、hashmap的remove方法" class="header-anchor">#</a> 8、HashMap的<code>remove</code>方法</h2> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * 根据指定的键从HashMap中移除键值对。
 * 如果键存在，则移除该键值对并返回其对应的值；否则返回null。
 *
 * @param key 要移除的键
 * @return 被移除的值，如果键不存在则返回null
 */</span>
<span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 调用removeNode方法执行移除操作，并返回被移除节点的值</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span>
        <span class="token keyword">null</span> <span class="token operator">:</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 从HashMap中移除指定哈希值和键的节点，并可选择性匹配值。
 * 此方法是HashMap移除元素的核心实现。
 *
 * @param hash 键的哈希值
 * @param key 要移除的键
 * @param value 要匹配的值，如果为null则不匹配值
 * @param matchValue 是否进行值匹配
 * @param movable 是否允许节点移动
 * @return 如果成功移除则返回被移除的节点，否则返回null
 */</span>
<span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">Object</span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">,</span>
                           <span class="token keyword">boolean</span> matchValue<span class="token punctuation">,</span> <span class="token keyword">boolean</span> movable<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 定义局部变量</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> index<span class="token punctuation">;</span>

    <span class="token comment">// 如果HashMap的表不为空，并且长度大于0，并且在计算的索引位置有节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>
        <span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>index <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> node <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> e<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span> <span class="token class-name">V</span> v<span class="token punctuation">;</span>

        <span class="token comment">// 如果索引位置的节点就是我们要找的节点</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            node <span class="token operator">=</span> p<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> 
        <span class="token comment">// 否则检查链表的下一个节点（包括红黑树的情况）</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 在红黑树结构中查找节点</span>
                node <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTreeNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token comment">// 在链表中查找节点</span>
                <span class="token keyword">do</span> <span class="token punctuation">{</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
                        <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span>
                         <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        node <span class="token operator">=</span> e<span class="token punctuation">;</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    p <span class="token operator">=</span> e<span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 如果找到了节点，并且不需要匹配值或值匹配成功</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">!</span>matchValue <span class="token operator">||</span> <span class="token punctuation">(</span>v <span class="token operator">=</span> node<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token operator">==</span> value <span class="token operator">||</span>
                             <span class="token punctuation">(</span>value <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> value<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 如果是红黑树节点，移除树节点</span>
                <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">removeTreeNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> movable<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 如果节点是链表的头节点，直接更新表的索引位置</span>
                tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token comment">// 否则，更新前驱节点的next引用，跳过当前节点</span>
                p<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token comment">// 更新HashMap的结构修改计数和大小</span>
            <span class="token operator">++</span>modCount<span class="token punctuation">;</span>
            <span class="token operator">--</span>size<span class="token punctuation">;</span>

            <span class="token comment">// 调用节点移除后的处理方法</span>
            <span class="token function">afterNodeRemoval</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">// 返回被移除的节点</span>
            <span class="token keyword">return</span> node<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 如果没有找到匹配的节点，返回null</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><h2 id="_9、hashmap的迭代器"><a href="#_9、hashmap的迭代器" class="header-anchor">#</a> 9、HashMap的迭代器</h2> <p>    由于HashMap是数组+链表的数据结构，所以HashMap的迭代器只能循环数组，从0索引位置开始循环找到第一个非空的Node节点，如果该节点的next不会空，就继续使用Node节点的next去一个一个遍历元素，如果next为空了，再往下循环数组直到找到下一个非空的Node节点继续使用next遍历。<br>
所以HashMap的迭代器会循环遍历所有的数组Node节点，以及Node节点链接的链表或红黑树的全部元素。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">HashIterator</span> <span class="token punctuation">{</span>
        <span class="token comment">// 下一个要返回的节点</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span>        
        <span class="token comment">// 当前的节点</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> current<span class="token punctuation">;</span>     
        <span class="token comment">// 用于快速失败的期望修改计数</span>
        <span class="token keyword">int</span> expectedModCount<span class="token punctuation">;</span>  
        <span class="token comment">// 当前槽的索引</span>
        <span class="token keyword">int</span> index<span class="token punctuation">;</span>             

        <span class="token comment">// 构造方法</span>
        <span class="token class-name">HashIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 初始化期望的修改计数，等于当前的修改计数</span>
            expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span>
            <span class="token comment">// 获取哈希表</span>
            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> t <span class="token operator">=</span> table<span class="token punctuation">;</span>
            <span class="token comment">// 初始化当前节点和下一个节点为null</span>
            current <span class="token operator">=</span> next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token comment">// 初始化索引为0</span>
            index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token comment">// 如果哈希表不为空并且大小大于0，推进到第一个非空的槽</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> size <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
                <span class="token comment">// 循环直到找到第一个非空的槽</span>
                <span class="token keyword">do</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> t<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>next <span class="token operator">=</span> t<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 判断是否有下一个元素</span>
        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 获取下一个节点</span>
        <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">nextNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 临时变量t用于存储哈希表</span>
            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> t<span class="token punctuation">;</span>
            <span class="token comment">// e用于存储当前的下一个节点</span>
            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> next<span class="token punctuation">;</span>
            <span class="token comment">// 如果哈希表的修改计数与期望的修改计数不同，抛出并发修改异常</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 如果下一个节点为空，抛出没有元素异常</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 将当前节点设为下一个节点，如果下一个节点的下一个节点为空，继续寻找下一个非空的槽</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>next <span class="token operator">=</span> <span class="token punctuation">(</span>current <span class="token operator">=</span> e<span class="token punctuation">)</span><span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>t <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 循环直到找到下一个非空的槽</span>
                <span class="token keyword">do</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> t<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>next <span class="token operator">=</span> t<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 返回当前的节点</span>
            <span class="token keyword">return</span> e<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

</code></pre></div><h2 id="_10、hashmap的一些常见问题"><a href="#_10、hashmap的一些常见问题" class="header-anchor">#</a> 10、HashMap的一些常见问题</h2> <h3 id="_1、jdk8为什么引入红黑树"><a href="#_1、jdk8为什么引入红黑树" class="header-anchor">#</a> ①、JDK8为什么引入红黑树？</h3> <p>HashMap采用哈希表的结构存储键值对，键通过哈希函数被映射到数组的某个索引位置。理想情况下，哈希函数将键均匀地分布在数组的各个位置上，但在实际应用中，不同的键可能会被映射到同一个索引位置，导致哈希冲突。</p> <p>在JDK8之前，HashMap在处理哈希冲突时使用的是链表。即在同一个索引位置上存储多个键值对时，这些键值对会被存储在一个链表中。这意味着，当多个键被映射到同一个位置时，查询、插入或删除操作的时间复杂度会随着链表长度的增加而增加，最坏情况下达到O(n)，其中n是链表中的元素数量。</p> <p>为了优化在哈希冲突严重情况下的性能，JDK8引入了红黑树。当链表长度大于等于8时，且哈希表容量大于等于64时。链表会转换为红黑树。</p> <p>红黑树是一种自平衡二叉搜索树，具有以下特点：<br>
平衡性：红黑树通过一系列的旋转和颜色变化来保持树的平衡，使得树的高度始终保持在O(log n)。<br>
查询效率：由于红黑树的高度是O(log n)，因此在红黑树中的查询、插入和删除操作的时间复杂度是O(log n)，比链表的O(n)更高效。</p> <h3 id="_2、红黑树的数据结构有什么特点"><a href="#_2、红黑树的数据结构有什么特点" class="header-anchor">#</a> ②、红黑树的数据结构有什么特点  ？</h3> <p><strong>树结构有以下特点：</strong><br>
查找效率高：<br>
通过树形结构（如二叉查找树、红黑树、B树等），可以在O(log n)时间内完成查找操作，比线性结构（如数组、链表）高效。</p> <p>保持数据有序：<br>
树结构能够在插入和删除操作后保持数据的有序性，适用于需要频繁更新和检索的数据集。</p> <p>表示层次结构：<br>
树结构用于表示具有层次关系的数据，如XML/HTML文档、组织结构图、文件系统等。</p> <p>高效插入和删除：<br>
树结构支持高效的插入和删除操作，特别是自平衡树，通过旋转和重新平衡操作，能够在O(log n)时间内完成插入和删除。</p> <p><strong>红黑树的特点</strong></p> <ul><li>节点颜色：每个节点都被标记为红色或黑色。</li> <li>根节点：根节点始终是黑色。</li> <li>叶子节点：所有叶子节点（即空节点）都是黑色。</li> <li>红色规则：红色节点不能有两个连续的红色父节点和子节点。</li> <li>黑色规则：从任一节点到其每个叶节点的所有路径都包含相同数量的黑色节点。
这些规则确保红黑树在最坏情况下也能保持O(log n)的时间复杂度。通过插入和删除操作后的旋转和重新着色，红黑树能够保持平衡，避免退化成线性结构。</li></ul> <p><strong>二叉查找树（BST）与红黑树（Red-Black Tree）的区别:</strong></p> <table><thead><tr><th>特点</th> <th>普通二叉查找树（BST）</th> <th>红黑树（Red-Black Tree）</th></tr></thead> <tbody><tr><td><strong>基本定义</strong></td> <td>每个节点最多有两个子节点，左子节点小于父节点，右子节点大于父节点</td> <td>一种自平衡的二叉查找树，附加了红黑节点的颜色属性</td></tr> <tr><td><strong>平衡性</strong></td> <td>不保证平衡，可能会退化成线性结构</td> <td>保持平衡，通过颜色和旋转操作维持</td></tr> <tr><td><strong>最坏情况时间复杂度</strong></td> <td>O(n)，退化成链表时</td> <td>O(log n)</td></tr> <tr><td><strong>平均情况时间复杂度</strong></td> <td>O(log n)</td> <td>O(log n)</td></tr> <tr><td><strong>插入复杂度</strong></td> <td>O(log n)（平均情况），O(n)（最坏情况）</td> <td>O(log n)</td></tr> <tr><td><strong>删除复杂度</strong></td> <td>O(log n)（平均情况），O(n)（最坏情况）</td> <td>O(log n)</td></tr> <tr><td><strong>查询复杂度</strong></td> <td>O(log n)（平均情况），O(n)（最坏情况）</td> <td>O(log n)</td></tr> <tr><td><strong>结构维护</strong></td> <td>插入和删除不涉及复杂的维护操作</td> <td>插入和删除需要进行旋转和重新着色来维持平衡</td></tr> <tr><td><strong>使用场景</strong></td> <td>简单的插入、查找操作，数据相对有序时性能较好</td> <td>需要频繁插入、删除和查找操作时性能稳定</td></tr> <tr><td><strong>退化情况</strong></td> <td>当插入数据按顺序（升序或降序）时会退化成线性结构</td> <td>通过自平衡机制，避免退化</td></tr></tbody></table> <p><strong>普通的二叉查找树（BST）会在以下情况下退化成线性结构：</strong>
当节点按顺序（升序或降序）插入时，每个节点都只有一个子节点，导致树变成一条“链”。
例如，插入序列为1, 2, 3, 4, 5时，BST会退化成：</p> <img src="/blog/images/21-6.png" alt="mixureSecure"> <h3 id="_3、负载因子为什么是0-75"><a href="#_3、负载因子为什么是0-75" class="header-anchor">#</a> ③、负载因子为什么是0.75？</h3> <p>在空间占用与查询时间之间取得较好的权衡。<br>
大于这个值，空间节省了，但链表可能就会比较长影响性能。<br>
小于这个值，冲突减少了，但扩容就会更频繁，空间占用多。
综合考虑实际使用场景和对性能的要求，0.75加载因子是经验上比较成熟和常用的选择。<br>
这个值在大多数情况下能够保证HashMap在性能和空间利用率之间取得合理的平衡。</p> <p>数学概率方面：
hash 值如果足够随机，则在 hash 表内按泊松分布，在负载因子 0.75 的情况下，长度超过8的链表出现概率是0.00000006，选择8就是为了让树化几率足够小。</p> <p>添加第一个元素时，默认情况下HashMap容量是16，负载因子是0.75  。<br>
16*0.75=12 ，也就是第一次扩容的阈值为12。<br>
当添加第13个元素的时候，13&gt;12，HashMap容量扩容为32；</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 获取 HashMap 内部的 table 数组长度</span>
        <span class="token class-name">Field</span> tableField <span class="token operator">=</span> <span class="token class-name">HashMap</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">&quot;table&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        tableField<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 设置可访问私有字段</span>

        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;123&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> table <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> tableField<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 16</span>
        
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;2&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;123&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;3&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;123&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;4&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;123&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;5&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;123&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;6&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;123&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;7&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;123&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;8&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;123&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;9&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;123&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;10&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;123&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;11&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;123&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;12&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;123&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> table1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> tableField<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>table1<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 16</span>
        
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;13&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;123&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> table2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> tableField<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>table2<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 32</span>
    <span class="token punctuation">}</span>
</code></pre></div><h3 id="_4、为什么数组长度≥64且链表长度-≥8才树化"><a href="#_4、为什么数组长度≥64且链表长度-≥8才树化" class="header-anchor">#</a> ④、为什么数组长度≥64且链表长度 ≥8才树化？</h3> <p>空间和时间的折中考虑：
红黑树比链表占用更多的内存空间，因为树节点通常比链表节点大。因此，在选择将链表转换成树时，需要权衡空间和时间效率。<br>
只有在链表长度较大时，大于等于阈值8，才值得为了提升时间效率而牺牲一定的空间。</p> <p>并不是所有长度大于等于8的链表都会立即树化，只有当链表长度大于等于8且数组(哈希表)长度大于等于64时才会树化。如果链表长度大于等于8但是数组长度小于64，此时会进行扩容重新散列，而不是树化。 因为数组长度小于64说明此时的数组容量还很小，此时应该考虑扩容把元素重新散列到更大的哈希表中以减少哈希冲突来提升性能。</p> <h3 id="_5、多线程下hashmap写操作可能出现哪些问题"><a href="#_5、多线程下hashmap写操作可能出现哪些问题" class="header-anchor">#</a> ⑤、多线程下HashMap写操作可能出现哪些问题？</h3> <p>JDK8之前可能会出现：
扩容死链(头插法导致)，丢失数据。</p> <p>JDK8的HashMap的链表采用了尾插法不会出现扩容死链问题，仍然可能会出现丢失数据问题。</p> <h4 id="jdk1-8之前并发扩容死链问题-动画演示"><a href="#jdk1-8之前并发扩容死链问题-动画演示" class="header-anchor">#</a> JDK1.8之前并发扩容死链问题，动画演示：</h4> <p>这个动画我画了快3小时 ┭┮﹏┭┮ ，多看几遍 我相信就能很容易理解扩容死链形成的过程了。</p> <img src="/blog/images/21-7.gif" alt="mixureSecure"> <p>最终形成了 a.next=b,  b.next=a 的这种死链：</p> <img src="/blog/images/21-8.png" alt="mixureSecure"> <p>此时当我们再调用查找方法，比如  key  c 的索引也是1  ，HashMap就会遍历这个死链，发现a不是b不是 再往下遍历又到了a、b，a，b 无线循环下去，就会导致 本次 get(c)的调用陷入死循环。</p> <h4 id="丢失数据问题-代码演示"><a href="#丢失数据问题-代码演示" class="header-anchor">#</a> 丢失数据问题，代码演示：</h4> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 默认容量16</span>

        <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// hash值 97  索引位置 i = (16-1) &amp; 97 = 1</span>
            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// hash值 98  索引位置 i = (16-1) &amp; 98 = 2</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">&quot;t1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// hash值  49 索引位置 i = (16-1) &amp; 49 = 1</span>
            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;2&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// hash值 50  索引位置 i = (16-1) &amp; 50 = 2</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">&quot;t2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t2<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">&quot;t2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>可以看到 key  &quot;a&quot; 和 &quot;1&quot; 会出现哈希冲突，key  &quot;b&quot; 和 &quot;2&quot; 会出现哈希冲突。<br>
正常情况下应该得到的结果是：</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token punctuation">{</span><span class="token number">1</span><span class="token operator">=</span><span class="token number">1</span>, <span class="token assign-left variable">a</span><span class="token operator">=</span>a, <span class="token assign-left variable">2</span><span class="token operator">=</span><span class="token number">2</span>, <span class="token assign-left variable">b</span><span class="token operator">=</span>b<span class="token punctuation">}</span>
</code></pre></div><p>现在我们演示下出问题的情况：<br>
首先打断点，断点的条件设置为 线程名称是 t1或者t2才走断点。(因为JVM启动的时候也会调用putVal方法，不加条件可能会断点到很多其他线程的调用)</p> <p>断点条件代码：<code>Thread.currentThread().getName().equals(&quot;t1&quot;)||Thread.currentThread().getName().equals(&quot;t2&quot;)</code></p> <img src="/blog/images/21-9.png" alt="mixureSecure"> <p>①、debug运行代码，先走t1线程的断点     <code>map.put(&quot;a&quot;,&quot;a&quot;); // hash值 97 索引位置 i = (16-1) &amp; 97 = 1</code><br>
注意让t1只走到判断 索引位置为空的if条件里先不给数组赋值</p> <img src="/blog/images/21-10.png" alt="mixureSecure"> <p>②、此时选t2线程，此时由于  key &quot;1&quot;的索引位置也是1 ，而t1线程 还没来得及给数组的这个1位置赋值<br>
所以t2线程也进入了if代码块内 。
此时让t2线程继续往下走一步赋值 <code>map.put(&quot;1&quot;,&quot;1&quot;); // hash值 49 索引位置 i = (16-1) &amp; 49 = 1</code>  , 数组的 tab[1] = (&quot;1&quot;,&quot;1&quot;)了</p> <img src="/blog/images/21-11.png" alt="mixureSecure"> <p>③、再返回t1线程，此时的tab[1] 已经有值了，是上面 t2线程赋的值。</p> <img src="/blog/images/21-12.png" alt="mixureSecure"> <p>这个时候让t1线程继续赋值就把 t2 线程在索引位置1 处赋的值覆盖掉了。</p> <img src="/blog/images/21-13.png" alt="mixureSecure"> <p>④、我们再重复上面的操作，再走t1进if语句内不赋值，然后等t2赋值后，t1再赋值。<br>
最终就能得到丢失数据的结果。</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token punctuation">{</span>a<span class="token operator">=</span>a, <span class="token assign-left variable">b</span><span class="token operator">=</span>b<span class="token punctuation">}</span>
</code></pre></div><p>可以看到 和正常情况的 <code>{1=1, a=a, 2=2, b=b}</code> 相比 丢失了t2线程put的数据。</p> <h3 id="_6、jdk8之前的put方法和之后的put方法有什么区别"><a href="#_6、jdk8之前的put方法和之后的put方法有什么区别" class="header-anchor">#</a> ⑥、JDK8之前的put方法和之后的put方法有什么区别  ？</h3> <ul><li>1、链表插入行为不同：链表插入节点时，JDK8之前是头插法，JDK8是尾插法。</li> <li>2、扩容行为不同：JDK8之前是大于等于阈值且没有空位时才扩容，而JDK8是大于阈值就扩容.</li> <li>3、链表和红黑树转化：JDK8之前只有链表，JDK8引入红黑树。</li></ul> <h3 id="_7、hashmap的红黑树什么情况下会退化成链表"><a href="#_7、hashmap的红黑树什么情况下会退化成链表" class="header-anchor">#</a> ⑦、HashMap的红黑树什么情况下会退化成链表？</h3> <p><strong>退化情况1:</strong>  在扩容时如果拆分树时，树元素个数&lt;=6则会退化为链表。</p> <p>在HashMap进行扩容时，会对现有的桶进行重新分配元素。如果一个桶中原本是红黑树节点（TreeNode），而在进行扩容时，树中节点的数量少于等于6个，HashMap会选择将这些节点转换为链表形式。这是因为对于数量较少的节点来说，使用链表而不是红黑树可能会更节省空间和操作成本。<br>
对应代码：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>loHead <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果低位链表头结点不为空</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>lc <span class="token operator">&lt;=</span> <span class="token constant">UNTREEIFY_THRESHOLD</span><span class="token punctuation">)</span>
        <span class="token comment">// 如果低位链表的节点数小于等于UNTREEIFY_THRESHOLD (默认是6)，将其退化成链表</span>
        tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">.</span><span class="token function">untreeify</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 否则，保持为红黑树</span>
        tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>hiHead <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// 如果高位链表头结点也不为空，保持红黑树结构</span>
            loHead<span class="token punctuation">.</span><span class="token function">treeify</span><span class="token punctuation">(</span>tab<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>hiHead <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果高位链表头结点不为空</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>hc <span class="token operator">&lt;=</span> <span class="token constant">UNTREEIFY_THRESHOLD</span><span class="token punctuation">)</span>
        <span class="token comment">// 如果高位链表的节点数小于等于UNTREEIFY_THRESHOLD (默认是6)，将其退化成链表</span>
        tab<span class="token punctuation">[</span>index <span class="token operator">+</span> bit<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">.</span><span class="token function">untreeify</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 否则，保持为红黑树</span>
        tab<span class="token punctuation">[</span>index <span class="token operator">+</span> bit<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>loHead <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// 如果低位链表头结点也不为空，保持红黑树结构</span>
            hiHead<span class="token punctuation">.</span><span class="token function">treeify</span><span class="token punctuation">(</span>tab<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


</code></pre></div><p><strong>退化情况2:</strong> remove 树节点时，若 root、root.left、root.right、root.left.left有一个为 null，也会退化为链表。</p> <p>在HashMap中删除树节点时，如果根节点或其子节点的左右子节点为null，则树节点会退化为链表形式。<br>
这是因为在红黑树中，根节点的左右子节点为null意味着红黑树的结构不再成立，因此HashMap选择将这部分节点转换为链表以保持结构的一致性和简单性。</p> <p>对应代码：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">removeTreeNode</span><span class="token punctuation">(</span><span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> map<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> <span class="token keyword">boolean</span> movable<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> n<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// 如果哈希表为空或长度为零，直接返回</span>

    <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">;</span> <span class="token comment">// 计算节点所在的桶索引</span>
    <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> first <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span> root <span class="token operator">=</span> first<span class="token punctuation">,</span> rl<span class="token punctuation">;</span>
    <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> succ <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>next<span class="token punctuation">,</span> pred <span class="token operator">=</span> prev<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> first <span class="token operator">=</span> succ<span class="token punctuation">;</span> <span class="token comment">// 如果没有前驱节点，将桶头设置为后继节点</span>
    <span class="token keyword">else</span>
        pred<span class="token punctuation">.</span>next <span class="token operator">=</span> succ<span class="token punctuation">;</span> <span class="token comment">// 否则将前驱节点的 next 指向后继节点</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>succ <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        succ<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred<span class="token punctuation">;</span> <span class="token comment">// 如果有后继节点，将其 prev 指向前驱节点</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// 如果桶头为空，直接返回</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>parent <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        root <span class="token operator">=</span> root<span class="token punctuation">.</span><span class="token function">root</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取红黑树的根节点</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> root<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>rl <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> rl<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> first<span class="token punctuation">.</span><span class="token function">untreeify</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果红黑树的结构不再平衡，将其退化为链表</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">,</span> pl <span class="token operator">=</span> left<span class="token punctuation">,</span> pr <span class="token operator">=</span> right<span class="token punctuation">,</span> replacement<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>pl <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> pr <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> s <span class="token operator">=</span> pr<span class="token punctuation">,</span> sl<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sl <span class="token operator">=</span> s<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            s <span class="token operator">=</span> sl<span class="token punctuation">;</span> <span class="token comment">// 找到后继节点</span>
        <span class="token keyword">boolean</span> c <span class="token operator">=</span> s<span class="token punctuation">.</span>red<span class="token punctuation">;</span> s<span class="token punctuation">.</span>red <span class="token operator">=</span> p<span class="token punctuation">.</span>red<span class="token punctuation">;</span> p<span class="token punctuation">.</span>red <span class="token operator">=</span> c<span class="token punctuation">;</span> <span class="token comment">// 交换颜色</span>
        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> sr <span class="token operator">=</span> s<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> pp <span class="token operator">=</span> p<span class="token punctuation">.</span>parent<span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> pr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            p<span class="token punctuation">.</span>parent <span class="token operator">=</span> s<span class="token punctuation">;</span>
            s<span class="token punctuation">.</span>right <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment">// 如果后继节点是右子节点，调整关系</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> sp <span class="token operator">=</span> s<span class="token punctuation">.</span>parent<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>parent <span class="token operator">=</span> sp<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> sp<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
                    sp<span class="token punctuation">.</span>left <span class="token operator">=</span> p<span class="token punctuation">;</span>
                <span class="token keyword">else</span>
                    sp<span class="token punctuation">.</span>right <span class="token operator">=</span> p<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>right <span class="token operator">=</span> pr<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                pr<span class="token punctuation">.</span>parent <span class="token operator">=</span> s<span class="token punctuation">;</span> <span class="token comment">// 调整后继节点与右子节点的关系</span>
        <span class="token punctuation">}</span>
        p<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>right <span class="token operator">=</span> sr<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            sr<span class="token punctuation">.</span>parent <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment">// 调整右子节点与 p 的关系</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>left <span class="token operator">=</span> pl<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            pl<span class="token punctuation">.</span>parent <span class="token operator">=</span> s<span class="token punctuation">;</span> <span class="token comment">// 调整左子节点与后继节点的关系</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>parent <span class="token operator">=</span> pp<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            root <span class="token operator">=</span> s<span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> pp<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            pp<span class="token punctuation">.</span>left <span class="token operator">=</span> s<span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            pp<span class="token punctuation">.</span>right <span class="token operator">=</span> s<span class="token punctuation">;</span> <span class="token comment">// 调整后继节点与 p 父节点的关系</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>sr <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            replacement <span class="token operator">=</span> sr<span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            replacement <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment">// 确定替代节点</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pl <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        replacement <span class="token operator">=</span> pl<span class="token punctuation">;</span> <span class="token comment">// 如果只有左子节点，替代节点为左子节点</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pr <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        replacement <span class="token operator">=</span> pr<span class="token punctuation">;</span> <span class="token comment">// 如果只有右子节点，替代节点为右子节点</span>
    <span class="token keyword">else</span>
        replacement <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment">// 如果没有子节点，替代节点为 p</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>replacement <span class="token operator">!=</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> pp <span class="token operator">=</span> replacement<span class="token punctuation">.</span>parent <span class="token operator">=</span> p<span class="token punctuation">.</span>parent<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>pp <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            root <span class="token operator">=</span> replacement<span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> pp<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            pp<span class="token punctuation">.</span>left <span class="token operator">=</span> replacement<span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            pp<span class="token punctuation">.</span>right <span class="token operator">=</span> replacement<span class="token punctuation">;</span> <span class="token comment">// 调整替代节点与 p 父节点的关系</span>
        p<span class="token punctuation">.</span>left <span class="token operator">=</span> p<span class="token punctuation">.</span>right <span class="token operator">=</span> p<span class="token punctuation">.</span>parent <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 清空 p 的引用</span>
    <span class="token punctuation">}</span>

    <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> r <span class="token operator">=</span> p<span class="token punctuation">.</span>red <span class="token operator">?</span> root <span class="token operator">:</span> <span class="token function">balanceDeletion</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> replacement<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 平衡删除操作</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>replacement <span class="token operator">==</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 断开 p 与其父节点的关系</span>
        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> pp <span class="token operator">=</span> p<span class="token punctuation">.</span>parent<span class="token punctuation">;</span>
        p<span class="token punctuation">.</span>parent <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>pp <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> pp<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
                pp<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> pp<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
                pp<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>movable<span class="token punctuation">)</span>
        <span class="token function">moveRootToFront</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果可移动，将根节点移动到桶头</span>
<span class="token punctuation">}</span>

</code></pre></div></div></section> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/blog/java-collection/五、Stack详解.html" class="prev">
          五、Stack详解
        </a></span> <span class="next"><a href="/blog/java-collection/七、LinkedHashMap详解.html">
          七、LinkedHashMap详解
        </a></span></p></div> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-b57cc07c data-v-7dd95ae2><li class="level-2" data-v-b57cc07c><a href="/blog/java-collection/%E5%85%AD%E3%80%81HashMap%E8%AF%A6%E8%A7%A3.html#_1、hashmap的继承体系" class="sidebar-link reco-side-_1、hashmap的继承体系" data-v-b57cc07c>1、HashMap的继承体系</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/java-collection/%E5%85%AD%E3%80%81HashMap%E8%AF%A6%E8%A7%A3.html#_2、hashmap底层数据结构" class="sidebar-link reco-side-_2、hashmap底层数据结构" data-v-b57cc07c>2、HashMap底层数据结构</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/java-collection/%E5%85%AD%E3%80%81HashMap%E8%AF%A6%E8%A7%A3.html#_3、hashmap的构造函数" class="sidebar-link reco-side-_3、hashmap的构造函数" data-v-b57cc07c>3、HashMap的构造函数</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E5%85%AD%E3%80%81HashMap%E8%AF%A6%E8%A7%A3.html#_1、无参构造" class="sidebar-link reco-side-_1、无参构造" data-v-b57cc07c>①、无参构造</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E5%85%AD%E3%80%81HashMap%E8%AF%A6%E8%A7%A3.html#_2、有参构造1-和-有参构造2-可以自定义初始容量和负载因子" class="sidebar-link reco-side-_2、有参构造1-和-有参构造2-可以自定义初始容量和负载因子" data-v-b57cc07c>②、有参构造1 和 有参构造2 (可以自定义初始容量和负载因子)</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E5%85%AD%E3%80%81HashMap%E8%AF%A6%E8%A7%A3.html#_3、有参构造3-接受一个map参数" class="sidebar-link reco-side-_3、有参构造3-接受一个map参数" data-v-b57cc07c>③、有参构造3(接受一个Map参数)</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E5%85%AD%E3%80%81HashMap%E8%AF%A6%E8%A7%A3.html#jdk-8之前版本的哈希方法" class="sidebar-link reco-side-jdk-8之前版本的哈希方法" data-v-b57cc07c>JDK 8之前版本的哈希方法：</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E5%85%AD%E3%80%81HashMap%E8%AF%A6%E8%A7%A3.html#jdk-8版本的哈希方法" class="sidebar-link reco-side-jdk-8版本的哈希方法" data-v-b57cc07c>JDK 8版本的哈希方法</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/java-collection/%E5%85%AD%E3%80%81HashMap%E8%AF%A6%E8%A7%A3.html#_4、拉链法解决哈希冲突" class="sidebar-link reco-side-_4、拉链法解决哈希冲突" data-v-b57cc07c>4、拉链法解决哈希冲突</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E5%85%AD%E3%80%81HashMap%E8%AF%A6%E8%A7%A3.html#什么是拉链法" class="sidebar-link reco-side-什么是拉链法" data-v-b57cc07c>什么是拉链法？</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E5%85%AD%E3%80%81HashMap%E8%AF%A6%E8%A7%A3.html#动画演示拉链法解决哈希冲突" class="sidebar-link reco-side-动画演示拉链法解决哈希冲突" data-v-b57cc07c>动画演示拉链法解决哈希冲突：</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E5%85%AD%E3%80%81HashMap%E8%AF%A6%E8%A7%A3.html#拉链法有哪些好处-还有其他解决哈希冲突的方式吗" class="sidebar-link reco-side-拉链法有哪些好处-还有其他解决哈希冲突的方式吗" data-v-b57cc07c>拉链法有哪些好处？ 还有其他解决哈希冲突的方式吗？</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/java-collection/%E5%85%AD%E3%80%81HashMap%E8%AF%A6%E8%A7%A3.html#_5、hashmap的put方法" class="sidebar-link reco-side-_5、hashmap的put方法" data-v-b57cc07c>5、HashMap的put方法</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E5%85%AD%E3%80%81HashMap%E8%AF%A6%E8%A7%A3.html#hashmap的属性注释" class="sidebar-link reco-side-hashmap的属性注释" data-v-b57cc07c>HashMap的属性注释</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E5%85%AD%E3%80%81HashMap%E8%AF%A6%E8%A7%A3.html#put方法" class="sidebar-link reco-side-put方法" data-v-b57cc07c>put方法</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E5%85%AD%E3%80%81HashMap%E8%AF%A6%E8%A7%A3.html#putval方法" class="sidebar-link reco-side-putval方法" data-v-b57cc07c>putVal方法</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E5%85%AD%E3%80%81HashMap%E8%AF%A6%E8%A7%A3.html#puttreeval方法" class="sidebar-link reco-side-puttreeval方法" data-v-b57cc07c>putTreeVal方法</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E5%85%AD%E3%80%81HashMap%E8%AF%A6%E8%A7%A3.html#treeifybin-方法" class="sidebar-link reco-side-treeifybin-方法" data-v-b57cc07c>treeifyBin 方法</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E5%85%AD%E3%80%81HashMap%E8%AF%A6%E8%A7%A3.html#node-k-v-静态内部类" class="sidebar-link reco-side-node-k-v-静态内部类" data-v-b57cc07c>Node静态内部类</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E5%85%AD%E3%80%81HashMap%E8%AF%A6%E8%A7%A3.html#resize方法" class="sidebar-link reco-side-resize方法" data-v-b57cc07c>resize方法</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E5%85%AD%E3%80%81HashMap%E8%AF%A6%E8%A7%A3.html#split方法" class="sidebar-link reco-side-split方法" data-v-b57cc07c>split方法</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E5%85%AD%E3%80%81HashMap%E8%AF%A6%E8%A7%A3.html#afternodeaccess方法" class="sidebar-link reco-side-afternodeaccess方法" data-v-b57cc07c>afterNodeAccess方法</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E5%85%AD%E3%80%81HashMap%E8%AF%A6%E8%A7%A3.html#afternodeinsertion方法" class="sidebar-link reco-side-afternodeinsertion方法" data-v-b57cc07c>afterNodeInsertion方法</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E5%85%AD%E3%80%81HashMap%E8%AF%A6%E8%A7%A3.html#hashmap的put方法执行流程图示" class="sidebar-link reco-side-hashmap的put方法执行流程图示" data-v-b57cc07c>HashMap的put方法执行流程图示</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/java-collection/%E5%85%AD%E3%80%81HashMap%E8%AF%A6%E8%A7%A3.html#_6、hashmap如何计算key的索引位置" class="sidebar-link reco-side-_6、hashmap如何计算key的索引位置" data-v-b57cc07c>6、HashMap如何计算key的索引位置</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E5%85%AD%E3%80%81HashMap%E8%AF%A6%E8%A7%A3.html#为什么hashmap的容量设计成总是2的整数倍" class="sidebar-link reco-side-为什么hashmap的容量设计成总是2的整数倍" data-v-b57cc07c>为什么HashMap的容量设计成总是2的整数倍？</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/java-collection/%E5%85%AD%E3%80%81HashMap%E8%AF%A6%E8%A7%A3.html#_7、hashmap的get方法" class="sidebar-link reco-side-_7、hashmap的get方法" data-v-b57cc07c>7、HashMap的get方法</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/java-collection/%E5%85%AD%E3%80%81HashMap%E8%AF%A6%E8%A7%A3.html#_8、hashmap的remove方法" class="sidebar-link reco-side-_8、hashmap的remove方法" data-v-b57cc07c>8、HashMap的remove方法</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/java-collection/%E5%85%AD%E3%80%81HashMap%E8%AF%A6%E8%A7%A3.html#_9、hashmap的迭代器" class="sidebar-link reco-side-_9、hashmap的迭代器" data-v-b57cc07c>9、HashMap的迭代器</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/java-collection/%E5%85%AD%E3%80%81HashMap%E8%AF%A6%E8%A7%A3.html#_10、hashmap的一些常见问题" class="sidebar-link reco-side-_10、hashmap的一些常见问题" data-v-b57cc07c>10、HashMap的一些常见问题</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E5%85%AD%E3%80%81HashMap%E8%AF%A6%E8%A7%A3.html#_1、jdk8为什么引入红黑树" class="sidebar-link reco-side-_1、jdk8为什么引入红黑树" data-v-b57cc07c>①、JDK8为什么引入红黑树？</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E5%85%AD%E3%80%81HashMap%E8%AF%A6%E8%A7%A3.html#_2、红黑树的数据结构有什么特点" class="sidebar-link reco-side-_2、红黑树的数据结构有什么特点" data-v-b57cc07c>②、红黑树的数据结构有什么特点  ？</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E5%85%AD%E3%80%81HashMap%E8%AF%A6%E8%A7%A3.html#_3、负载因子为什么是0-75" class="sidebar-link reco-side-_3、负载因子为什么是0-75" data-v-b57cc07c>③、负载因子为什么是0.75？</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E5%85%AD%E3%80%81HashMap%E8%AF%A6%E8%A7%A3.html#_4、为什么数组长度≥64且链表长度-≥8才树化" class="sidebar-link reco-side-_4、为什么数组长度≥64且链表长度-≥8才树化" data-v-b57cc07c>④、为什么数组长度≥64且链表长度 ≥8才树化？</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E5%85%AD%E3%80%81HashMap%E8%AF%A6%E8%A7%A3.html#_5、多线程下hashmap写操作可能出现哪些问题" class="sidebar-link reco-side-_5、多线程下hashmap写操作可能出现哪些问题" data-v-b57cc07c>⑤、多线程下HashMap写操作可能出现哪些问题？</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E5%85%AD%E3%80%81HashMap%E8%AF%A6%E8%A7%A3.html#_6、jdk8之前的put方法和之后的put方法有什么区别" class="sidebar-link reco-side-_6、jdk8之前的put方法和之后的put方法有什么区别" data-v-b57cc07c>⑥、JDK8之前的put方法和之后的put方法有什么区别  ？</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E5%85%AD%E3%80%81HashMap%E8%AF%A6%E8%A7%A3.html#_7、hashmap的红黑树什么情况下会退化成链表" class="sidebar-link reco-side-_7、hashmap的红黑树什么情况下会退化成链表" data-v-b57cc07c>⑦、HashMap的红黑树什么情况下会退化成链表？</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/blog/assets/js/app.f2787e20.js" defer></script><script src="/blog/assets/js/7.98eba54e.js" defer></script><script src="/blog/assets/js/2.5367abf9.js" defer></script><script src="/blog/assets/js/1.ae39e4f8.js" defer></script><script src="/blog/assets/js/47.745f27d2.js" defer></script>
  </body>
</html>
