<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>LinkedHashMap详解 | GM的博客</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="stylesheet" href="/blog/custom.css">
    <script src="/blog/custom.js"></script>
    <meta name="description" content="博观约取、厚积薄发。">
    
    <link rel="preload" href="/blog/assets/css/0.styles.0612dbff.css" as="style"><link rel="preload" href="/blog/assets/js/app.86d0dcf0.js" as="script"><link rel="preload" href="/blog/assets/js/7.4b97e329.js" as="script"><link rel="preload" href="/blog/assets/js/2.cc89bbf4.js" as="script"><link rel="preload" href="/blog/assets/js/1.fb256d2a.js" as="script"><link rel="preload" href="/blog/assets/js/41.2d4e929a.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.6c064207.js"><link rel="prefetch" href="/blog/assets/js/11.a693a8f3.js"><link rel="prefetch" href="/blog/assets/js/14.2a1ed16e.js"><link rel="prefetch" href="/blog/assets/js/15.c436ecdb.js"><link rel="prefetch" href="/blog/assets/js/16.5627e9c8.js"><link rel="prefetch" href="/blog/assets/js/17.d76a2ccb.js"><link rel="prefetch" href="/blog/assets/js/18.21f1f4b3.js"><link rel="prefetch" href="/blog/assets/js/19.c3aec7ee.js"><link rel="prefetch" href="/blog/assets/js/20.73f0a331.js"><link rel="prefetch" href="/blog/assets/js/21.108c76a9.js"><link rel="prefetch" href="/blog/assets/js/22.f6b8bd65.js"><link rel="prefetch" href="/blog/assets/js/23.8b148e1e.js"><link rel="prefetch" href="/blog/assets/js/24.f9175dcd.js"><link rel="prefetch" href="/blog/assets/js/25.29d310be.js"><link rel="prefetch" href="/blog/assets/js/26.692e69bd.js"><link rel="prefetch" href="/blog/assets/js/27.20ab0ec1.js"><link rel="prefetch" href="/blog/assets/js/28.99545882.js"><link rel="prefetch" href="/blog/assets/js/29.054ab9de.js"><link rel="prefetch" href="/blog/assets/js/3.c7991857.js"><link rel="prefetch" href="/blog/assets/js/30.2962fbba.js"><link rel="prefetch" href="/blog/assets/js/31.2fc639e9.js"><link rel="prefetch" href="/blog/assets/js/32.97324ada.js"><link rel="prefetch" href="/blog/assets/js/33.23619402.js"><link rel="prefetch" href="/blog/assets/js/34.d9e34b8a.js"><link rel="prefetch" href="/blog/assets/js/35.c4f7378c.js"><link rel="prefetch" href="/blog/assets/js/36.71d98d02.js"><link rel="prefetch" href="/blog/assets/js/37.234e0087.js"><link rel="prefetch" href="/blog/assets/js/38.cf3e4a36.js"><link rel="prefetch" href="/blog/assets/js/39.c75715a7.js"><link rel="prefetch" href="/blog/assets/js/4.e360d680.js"><link rel="prefetch" href="/blog/assets/js/40.f614977f.js"><link rel="prefetch" href="/blog/assets/js/42.47df6955.js"><link rel="prefetch" href="/blog/assets/js/43.2d140aa4.js"><link rel="prefetch" href="/blog/assets/js/44.d9013303.js"><link rel="prefetch" href="/blog/assets/js/45.2f402304.js"><link rel="prefetch" href="/blog/assets/js/46.057f8164.js"><link rel="prefetch" href="/blog/assets/js/47.2185b9f9.js"><link rel="prefetch" href="/blog/assets/js/48.d4179aba.js"><link rel="prefetch" href="/blog/assets/js/49.f4fbb16c.js"><link rel="prefetch" href="/blog/assets/js/5.56e9ad02.js"><link rel="prefetch" href="/blog/assets/js/50.86ade5e9.js"><link rel="prefetch" href="/blog/assets/js/51.fb57146c.js"><link rel="prefetch" href="/blog/assets/js/52.f06fea4e.js"><link rel="prefetch" href="/blog/assets/js/53.e138eaad.js"><link rel="prefetch" href="/blog/assets/js/54.e802ec15.js"><link rel="prefetch" href="/blog/assets/js/55.da85728d.js"><link rel="prefetch" href="/blog/assets/js/56.03097147.js"><link rel="prefetch" href="/blog/assets/js/57.6b93b5ea.js"><link rel="prefetch" href="/blog/assets/js/58.aecc6554.js"><link rel="prefetch" href="/blog/assets/js/59.70565292.js"><link rel="prefetch" href="/blog/assets/js/6.71cc5d94.js"><link rel="prefetch" href="/blog/assets/js/60.cfa40f6d.js"><link rel="prefetch" href="/blog/assets/js/61.fc998d09.js"><link rel="prefetch" href="/blog/assets/js/62.40fe6439.js"><link rel="prefetch" href="/blog/assets/js/63.2b40b104.js"><link rel="prefetch" href="/blog/assets/js/64.66baa9d8.js"><link rel="prefetch" href="/blog/assets/js/65.f090b70f.js"><link rel="prefetch" href="/blog/assets/js/66.3adeb4b7.js"><link rel="prefetch" href="/blog/assets/js/67.f0bda73a.js"><link rel="prefetch" href="/blog/assets/js/68.52c04798.js"><link rel="prefetch" href="/blog/assets/js/69.58f28854.js"><link rel="prefetch" href="/blog/assets/js/70.e1ed8eeb.js"><link rel="prefetch" href="/blog/assets/js/71.b66e8f4e.js"><link rel="prefetch" href="/blog/assets/js/72.785f61c5.js"><link rel="prefetch" href="/blog/assets/js/73.52e216f8.js"><link rel="prefetch" href="/blog/assets/js/74.07aa1ff0.js"><link rel="prefetch" href="/blog/assets/js/75.1cae44a0.js"><link rel="prefetch" href="/blog/assets/js/76.e8ae83b9.js"><link rel="prefetch" href="/blog/assets/js/77.4e4a65f3.js"><link rel="prefetch" href="/blog/assets/js/78.ad7f1544.js"><link rel="prefetch" href="/blog/assets/js/79.991a72fa.js"><link rel="prefetch" href="/blog/assets/js/8.92831dcf.js"><link rel="prefetch" href="/blog/assets/js/80.de239793.js"><link rel="prefetch" href="/blog/assets/js/81.8166ea73.js"><link rel="prefetch" href="/blog/assets/js/9.99883fee.js"><link rel="prefetch" href="/blog/assets/js/vendors~docsearch.6e140397.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.0612dbff.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>GM的博客</h3> <p class="description" data-v-59e6cb88>博观约取、厚积薄发。</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2024
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/head.jpg" alt="GM的博客" class="logo"> <span class="site-name">GM的博客</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://deepjava-gm.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  首页
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      GM的博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/deepjava-gm" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/qq_37883866" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><!----> <!----> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>43</h3> <h6 data-v-1fad0c41>文章</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>0</h3> <h6 data-v-1fad0c41>标签</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="https://deepjava-gm.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  首页
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      GM的博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/deepjava-gm" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/qq_37883866" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/blog/" class="sidebar-heading clickable router-link-active"><span>构建自己的Java知识体系</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/" aria-current="page" class="sidebar-link">引言</a></li><li><a href="/blog/contact.html" class="sidebar-link">反馈</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/blog/javabase/一、Java基础知识" class="sidebar-heading clickable"><span>Java基础</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/blog/java-collection/一、Java集合概述" class="sidebar-heading clickable open"><span>Java集合</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/java-collection/一、Java集合概述.html" class="sidebar-link">一、Java集合概述</a></li><li><a href="/blog/java-collection/二、ArrayList详解.html" class="sidebar-link">二、ArrayList详解</a></li><li><a href="/blog/java-collection/三、LinkedList详解.html" class="sidebar-link">三、LinkedList详解</a></li><li><a href="/blog/java-collection/四、CopyOnWriteArrayList详解.html" class="sidebar-link">四、CopyOnWriteArrayList详解</a></li><li><a href="/blog/java-collection/五、Stack详解.html" class="sidebar-link">五、Stack详解</a></li><li><a href="/blog/java-collection/六、HashMap详解.html" class="sidebar-link">六、HashMap详解</a></li><li><a href="/blog/java-collection/七、LinkedHashMap详解.html" class="active sidebar-link">七、LinkedHashMap详解</a></li><li><a href="/blog/java-collection/八、ConcurrentHashMap详解.html" class="sidebar-link">八、ConcurrentHashMap详解</a></li><li><a href="/blog/java-collection/九、ArrayDeque详解.html" class="sidebar-link">九、ArrayDeque详解</a></li><li><a href="/blog/java-collection/十、BlockingQueue详解.html" class="sidebar-link">十、BlockingQueue详解</a></li><li><a href="/blog/java-collection/十一、PriorityQueue详解.html" class="sidebar-link">十一、PriorityQueue详解</a></li><li><a href="/blog/java-collection/十二、DelayQueue详解.html" class="sidebar-link">十二、DelayQueue详解</a></li><li><a href="/blog/java-collection/十三、ConcurrentLinkedQueue详解.html" class="sidebar-link">十三、ConcurrentLinkedQueue详解</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/blog/java-concurrent/一、Java并发编程基础知识点" class="sidebar-heading clickable"><span>Java并发编程</span> <span class="arrow right"></span></a> <!----></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88></h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2024
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">LinkedHashMap详解</h1> <div data-v-8a445198><!----> <!----> <!----> <!----></div></div> <div class="theme-reco-content content__default"><h1 id="linkedhashmap详解"><a href="#linkedhashmap详解" class="header-anchor">#</a> LinkedHashMap详解</h1> <p>基于JDK8
LinkedHashMap相比于HashMap最显著的一个特性就是维持了插入的顺序，也可以设置其按照访问顺序排序。</p> <h2 id="_1、linkedhashmap的继承体系"><a href="#_1、linkedhashmap的继承体系" class="header-anchor">#</a> 1、LinkedHashMap的继承体系</h2> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword">extends</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword">implements</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><img src="/blog/images/22-1.png" alt="mixureSecure"> <p>可以看到LinkedHashMap继承了HashMap,所以HashMap能做的事情LinkedHashMap都能做。</p> <p>还记得<a href="https://deepjava.blog.csdn.net/article/details/139627417" target="_blank" rel="noopener noreferrer">HashMap详解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>这篇文章里面提到的两个方法吗？
<code>afterNodeAccess</code>和<code>afterNodeInsertion</code> 在 LinkedHashMap中就有对应的实现。下面会详细说到。</p> <h2 id="_2、linkedhashmap的特性介绍和代码示例"><a href="#_2、linkedhashmap的特性介绍和代码示例" class="header-anchor">#</a> 2、LinkedHashMap的特性介绍和代码示例</h2> <p>LinkedHashMap 是 HashMap 的子类，与 HashMap 类似，它也基于哈希表来存储键值对。但是，LinkedHashMap 维护了一个双向链表来记录插入顺序或者访问顺序，因此具备一些特有的特性和功能。</p> <p>双向链表在 <a href="https://deepjava.blog.csdn.net/article/details/139493362" target="_blank" rel="noopener noreferrer">LinkedList详解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>这篇文章中有介绍。</p> <p>LinkedHashMap 中使用双向链表维护顺序的图示：
绿色连线表示 双向链表的 pre和next指针。</p> <img src="/blog/images/22-2.png" alt="mixureSecure"> <h3 id="_1、特性"><a href="#_1、特性" class="header-anchor">#</a> ①、特性</h3> <p>插入顺序：默认情况下，LinkedHashMap 按照键值对的插入顺序来维护顺序。
<strong>插入顺序代码示例</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// ========== 演示插入顺序 ===============</span>
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;c&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;3&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;d&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;4&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;插入顺序遍历:&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> entry <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;: &quot;</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 插入顺序遍历:</span>
        <span class="token comment">//a: 1</span>
        <span class="token comment">//b: 2</span>
        <span class="token comment">//c: 3</span>
        <span class="token comment">//d: 4</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>访问顺序：可以通过构造函数设置 accessOrder 参数为 true，使其按照访问顺序来维护顺序。</p> <p><strong>访问顺序代码示例：</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">0.75f</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// ========== 插入元素 ===============</span>
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;c&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;3&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;d&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;4&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// ========== 访问其中一些元素 ===============</span>
        map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;c&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;访问顺序遍历:&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> entry <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;: &quot;</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// ========= 最新一次访问的排在最后</span>
        <span class="token comment">// 访问顺序遍历:</span>
        <span class="token comment">//b: 2</span>
        <span class="token comment">//d: 4</span>
        <span class="token comment">//c: 3</span>
        <span class="token comment">//a: 1</span>
    <span class="token punctuation">}</span>
</code></pre></div><h3 id="_2、适用场景"><a href="#_2、适用场景" class="header-anchor">#</a> ②、适用场景</h3> <p>**需要有序遍历的场景：**当需要按插入顺序或访问顺序遍历键值对时，LinkedHashMap 是一个很好的选择。</p> <p>**缓存：**由于 LinkedHashMap 可以按照访问顺序来维护键值对的顺序，因此非常适合用来实现 LRU（Least Recently Used，最近最少使用）缓存。</p> <h3 id="使用linkedhashmap-实现最简单的-lru缓存"><a href="#使用linkedhashmap-实现最简单的-lru缓存" class="header-anchor">#</a> 使用LinkedHashMap 实现最简单的 LRU缓存</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">LinkedHashMap</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Map</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestA</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 创建一个容量为 3 的 LRUCache</span>
        <span class="token class-name">LRUCache</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LRUCache</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 添加一些键值对到缓存中</span>
        cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">&quot;one&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">&quot;two&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">&quot;three&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 打印当前缓存内容</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Cache: &quot;</span> <span class="token operator">+</span> cache<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Cache: {1=one, 2=two, 3=three}</span>

        <span class="token comment">// 访问键 1 的值，使其成为最近访问的条目</span>
        cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cache<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {2=two, 3=three, 1=one}</span>
        <span class="token comment">// 添加新的键值对 4 -&gt; &quot;four&quot;  由于超过缓存容量 所以会删除 最近最久没使用的数据</span>
        cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">&quot;four&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 打印当前缓存内容，观察最老的条目是否被移除   （2被删除）</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;访问1 添加 4 后的缓存: &quot;</span> <span class="token operator">+</span> cache<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 访问1 添加 4 后的缓存: {3=three, 1=one, 4=four}</span>

        <span class="token comment">// 访问键 3 的值，使其成为最近访问的条目</span>
        cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cache<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {1=one, 4=four, 3=three}</span>
        <span class="token comment">// 添加新的键值对 5 -&gt; &quot;five&quot;   由于超过缓存容量 所以会删除 最近最久没使用的数据</span>
        cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">&quot;five&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 打印当前缓存内容，观察最老的条目是否被移除    （1被删除）</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;访问3 添加5 后的缓存: &quot;</span> <span class="token operator">+</span> cache<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 访问3 添加5 后的缓存: {4=four, 3=three, 5=five}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// LRUCache 类，继承 LinkedHashMap 实现最近最少使用 (LRU) 缓存</span>
<span class="token keyword">class</span> <span class="token class-name">LRUCache</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>

    <span class="token comment">// 缓存的最大容量</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> capacity<span class="token punctuation">;</span>

    <span class="token comment">// 构造函数，接受缓存的最大容量作为参数</span>
    <span class="token keyword">public</span> <span class="token class-name">LRUCache</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 调用父类的构造函数</span>
        <span class="token comment">// initialCapacity: 初始容量，设置为传入的 capacity</span>
        <span class="token comment">// loadFactor: 负载因子，设置为默认值 0.75F </span>
        <span class="token comment">// accessOrder: 设置为 true，表示按照访问顺序排序</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>capacity<span class="token punctuation">,</span> <span class="token number">0.75F</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span> <span class="token comment">// 初始化缓存容量</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 重写 LinkedHashMap 的 removeEldestEntry 方法</span>
    <span class="token comment">// 当添加一个新的键值对时，此方法会被调用，以判断是否需要删除最老的条目</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> eldest<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 当缓存元素个数大于我们设置的容量时  删除 最近最少使用的缓存元素</span>
        <span class="token keyword">return</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> capacity<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><h2 id="_3、linkedhashmap的构造函数"><a href="#_3、linkedhashmap的构造函数" class="header-anchor">#</a> 3、LinkedHashMap的构造函数</h2> <ul><li>①、空参构造</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">LinkedHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用父类(HashMap)的空参构造</span>
        accessOrder <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 不按照访问顺序排序</span>
    <span class="token punctuation">}</span>
</code></pre></div><ul><li>②、有参构造1
接收 initialCapacity 初始容量   loadFactor 负载因子</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">LinkedHashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 设置自定义的哈希表容量 和负载因子</span>
        accessOrder <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 不按照访问顺序排序</span>
    <span class="token punctuation">}</span>
</code></pre></div><ul><li>③、有参构造2
接收 initialCapacity: 初始容量   loadFactor: 负载因子  accessOrder: 是否按照访问顺序排序<br>
上面实现的LRUCache就是用的这个构造方法。</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">LinkedHashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span>
                         <span class="token keyword">float</span> loadFactor<span class="token punctuation">,</span>
                         <span class="token keyword">boolean</span> accessOrder<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>accessOrder <span class="token operator">=</span> accessOrder<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><ul><li>④、有参构造3
接收一个Map的实现。</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">LinkedHashMap</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用父类(HashMap)的空参构造</span>
        accessOrder <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 不按照访问顺序排序</span>
        <span class="token function">putMapEntries</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用HashMap的 putMapEntries方法</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>上面只列举了4个构造函数，还有一个直接收initialCapacity参数的就不列举了。</p> <h2 id="_4、linkedhashmap是如何存储元素的-底层数据结构是什么"><a href="#_4、linkedhashmap是如何存储元素的-底层数据结构是什么" class="header-anchor">#</a> 4、LinkedHashMap是如何存储元素的，底层数据结构是什么？</h2> <p>在HashMap详解的文章中 我们知道 HashMap的数组存储的是 <code>Node&lt;K,V&gt;</code>。</p> <p>而我们看LinkedHashMap的put方法是直接调用的父类HashMap的put方法。
上面已经介绍过了，LinkedHashMap使用双向链表维护每一个元素的插入顺序。<br>
那么LinkedHashMap是如何实现双向链表的，LinkedHashMap的底层数据结构是什么？
下面就来探讨这两个问题。<br>
在看LinkedHashMap源码之前，我们可以把HashMap和LinkedHashMap  类比ArrayList和LinkedList。
先猜测下LinkedHashMap里面一定也有类似LinkedList的Node节点，并且有pre和next指针实现双向链接。</p> <h3 id="linkedhashmap的属性注释"><a href="#linkedhashmap的属性注释" class="header-anchor">#</a> LinkedHashMap的属性注释</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword">extends</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword">implements</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span>
<span class="token punctuation">{</span>
   <span class="token comment">// 指向双向链表的头节点，即最早插入的键值对</span>
   <span class="token keyword">transient</span> <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> head<span class="token punctuation">;</span>
   
   <span class="token comment">// 指向双向链表的尾节点，即最后插入或访问的键值对</span>
   <span class="token keyword">transient</span> <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> tail<span class="token punctuation">;</span>
   
   <span class="token comment">// 标识链表是否按访问顺序维护</span>
   <span class="token comment">// 如果为 true，则每次访问（get 或 put）某个键值对时，该键值对将被移到链表尾部</span>
   <span class="token keyword">final</span> <span class="token keyword">boolean</span> accessOrder<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以看到LinkedHashMap是通过  <code>LinkedHashMap.Entry&lt;K,V&gt;</code>这个内部类 来保存链表节点的。</p> <h3 id="linkedhashmap的静态内部类entry-k-v"><a href="#linkedhashmap的静态内部类entry-k-v" class="header-anchor">#</a> LinkedHashMap的静态内部类<code>Entry&lt;K,V&gt;</code></h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// LinkedHashMap 的静态内部类 Entry，继承自 HashMap.Node</span>
<span class="token comment">// 此类在 LinkedHashMap 中用于维护双向链表，以记录键值对的插入顺序或访问顺序</span>
<span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">HashMap<span class="token punctuation">.</span>Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token comment">// 指向链表中前一个节点的引用</span>
    <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> before<span class="token punctuation">;</span>

    <span class="token comment">// 指向链表中后一个节点的引用</span>
    <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> after<span class="token punctuation">;</span>

    <span class="token comment">// 构造函数，用于创建一个新的 Entry 节点</span>
    <span class="token comment">// hash: 键的哈希值</span>
    <span class="token comment">// key: 键</span>
    <span class="token comment">// value: 值</span>
    <span class="token comment">// next: 指向哈希表中下一个节点的引用（用于处理哈希冲突）</span>
    <span class="token class-name">Entry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 调用父类 HashMap.Node 的构造函数，初始化 hash, key, value 和 next</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以看到不仅LinkedHashMap继承了HashMap，就连LinkedHashMap保存的元素 Entry都是继承HashMap的Node    <code>Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt;</code>  ，LinkedHashMap.Entry在HashMap.Node的基础上 添加了两个属性before和after用来保存链表的前一个和后一个引用。</p> <p>可以看下内部类的继承图：</p> <img src="/blog/images/22-3.png" alt="mixureSecure"> <p>图中可以看到，还有个TreeNode(红黑树的节点)是继承Entry的。</p> <p>我在HashMap详解的文章中并没有去看 TreeNode的源码，因为实现红黑树数据库结构的源码比较多，也比较难理解。要想写好注释 比较费力。</p> <h3 id="从treenode的继承结构引发一个关于设计类继承关系的思考"><a href="#从treenode的继承结构引发一个关于设计类继承关系的思考" class="header-anchor">#</a> 从TreeNode的继承结构引发一个关于设计类继承关系的思考？</h3> <p>      为什么在TreeNode和Node之间 还要搞个Entry来实现链表的功能，不如直接在Node节点加上before和after属性实现双向链表功能得了，这样还省事就不用再写一个Entry夹在中间了是不是。</p> <p>      这样做当然是可以的，只不过这样设计会使得HashMap本身不需要链表结构的每个元素都有before和after属性,当元素存储很多的是时候对于空间来说是浪费的。 如果再设计个Entry夹在中间，LinkedHashMap需要双向链表结构就用Entry，但是TreeNode有时候需要双向链表(比如LinkedHashMap需要转红黑树的时候)，有时候不需要双向链表(比如HashMap需要转红黑树的时候)。这个时候的TreeNode不管需不需要双向链表结构，都是已经继承Entry的了，所以会多出before和after属性。
      在HashMap需要转红黑树的情况下继承Entry实际上是一种空间浪费，但是别忘了概率， hash 值如果足够随机，则在 hash 表内按泊松分布，在负载因子 0.75 的情况下，长度超过8的链表出现概率是0.00000006。这么低的概率正常情况下注定红黑树节点在哈希表中不会有很多。</p> <p>      所以这么分析下来 搞个Entry夹在中间是个非常不错的设计。  既节省了HashMap的Node节点的空间占用，Entry又复用了Node的代码，TreeNode又复用了Entry的代码，实在是妙呀！</p> <h2 id="_5、linkedhashmap的put方法"><a href="#_5、linkedhashmap的put方法" class="header-anchor">#</a> 5、LinkedHashMap的put方法</h2> <p>是的你没有看错，LinkedHashMap并没有重写HashMap的put方法，直接调用的就是HashMap的put方法。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>那LinkedHashMap在put元素的时候又是如何把每个元素都链在一块形成双向链表的呢？</p> <p>LinkedHashMap实际上并不需要整体重写put方法，只需要重写<code>newNode</code>方法即可。
<code>HashMap的newNode方法</code></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">newNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>LinkedHashMap在重写的<code>newNode</code>方法中新建<code>LinkedHashMap.Entry&lt;K,V&gt;</code>元素。然后把元素链接到链表的尾部。</p> <h3 id="newnode方法"><a href="#newnode方法" class="header-anchor">#</a> <code>newNode</code>方法</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">newNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 创建一个新的 LinkedHashMap.Entry 节点，并初始化其哈希值、键、值和下一个节点指针</span>
    <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 将新节点插入到双向链表的尾部</span>
    <span class="token function">linkNodeLast</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 返回新创建的节点</span>
    <span class="token keyword">return</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><h3 id="linknodelast方法"><a href="#linknodelast方法" class="header-anchor">#</a> <code>linkNodeLast</code>方法</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">linkNodeLast</span><span class="token punctuation">(</span><span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当前的尾节点</span>
    <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> last <span class="token operator">=</span> tail<span class="token punctuation">;</span>
    <span class="token comment">// 将新节点设置为尾节点</span>
    tail <span class="token operator">=</span> p<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>last <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果链表为空，新节点即为头节点</span>
        head <span class="token operator">=</span> p<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 否则，将当前尾节点的 after 指针指向新节点</span>
        p<span class="token punctuation">.</span>before <span class="token operator">=</span> last<span class="token punctuation">;</span>
        last<span class="token punctuation">.</span>after <span class="token operator">=</span> p<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><h3 id="afternodeaccess方法"><a href="#afternodeaccess方法" class="header-anchor">#</a> <code>afterNodeAccess</code>方法</h3> <p>还记得 <a href="https://deepjava.blog.csdn.net/article/details/139627417" target="_blank" rel="noopener noreferrer">HashMap详解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>这篇文章中提过这个方法吗
LinkedHashMap就重写了 HashMap给的扩展方法。</p> <p>afterNodeAccess 方法在访问节点后调用，用于将被访问的节点移动到双向链表的尾部。<br>
这对于按访问顺序维护的 LinkedHashMap 特别重要。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">void</span> <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// move node to last</span>
    <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> last<span class="token punctuation">;</span>
    <span class="token comment">// 检查是否按访问顺序维护链表，并且被访问的节点不是当前的尾节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>accessOrder <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>last <span class="token operator">=</span> tail<span class="token punctuation">)</span> <span class="token operator">!=</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 将节点 e 转换为 LinkedHashMap.Entry 类型</span>
        <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> e<span class="token punctuation">;</span>
        <span class="token comment">// 获取节点 p 的前一个和后一个节点</span>
        <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> b <span class="token operator">=</span> p<span class="token punctuation">.</span>before<span class="token punctuation">,</span> a <span class="token operator">=</span> p<span class="token punctuation">.</span>after<span class="token punctuation">;</span>
        <span class="token comment">// 将 p 的 after 指针置为 null，表示它将成为新的尾节点</span>
        p<span class="token punctuation">.</span>after <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token comment">// 更新前一个节点和后一个节点的指针</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            head <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">// 如果 p 没有前一个节点，则它是头节点，更新头节点为 a</span>
        <span class="token keyword">else</span>
            b<span class="token punctuation">.</span>after <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">// 否则，将前一个节点的 after 指针指向 a</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            a<span class="token punctuation">.</span>before <span class="token operator">=</span> b<span class="token punctuation">;</span> <span class="token comment">// 如果 p 有后一个节点，将后一个节点的 before 指针指向 b</span>
        <span class="token keyword">else</span>
            last <span class="token operator">=</span> b<span class="token punctuation">;</span> <span class="token comment">// 如果 p 是当前的尾节点，更新 last 为 b</span>
        <span class="token comment">// 如果 last 为空，表示链表为空，将 p 设置为头节点</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>last <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            head <span class="token operator">=</span> p<span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">// 否则，将 p 插入到链表尾部</span>
            p<span class="token punctuation">.</span>before <span class="token operator">=</span> last<span class="token punctuation">;</span>
            last<span class="token punctuation">.</span>after <span class="token operator">=</span> p<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 更新尾节点为 p</span>
        tail <span class="token operator">=</span> p<span class="token punctuation">;</span>
        <span class="token comment">// 增加修改计数，以反映结构性修改</span>
        <span class="token operator">++</span>modCount<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><h3 id="afternodeinsertion方法"><a href="#afternodeinsertion方法" class="header-anchor">#</a> <code>afterNodeInsertion</code>方法</h3> <p>afterNodeInsertion 方法在插入节点后调用，用于检查是否需要移除最老的节点（头节点）。<br>
这对于按插入顺序维护的 LinkedHashMap 特别重要。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">void</span> <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// possibly remove eldest</span>
    <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> first<span class="token punctuation">;</span>
    <span class="token comment">// 如果需要移除元素，并且头节点不为空，并且需要移除最老的节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>evict <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>first <span class="token operator">=</span> head<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 获取头节点的键</span>
        <span class="token class-name">K</span> key <span class="token operator">=</span> first<span class="token punctuation">.</span>key<span class="token punctuation">;</span>
        <span class="token comment">// 根据键移除节点</span>
        <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><p>看了上面的代码注释就会明白，afterNodeAccess和afterNodeInsertion方法的主要目的都是为了实现按照访问顺序处理元素的位置。</p> <h2 id="_6、linkedhashmap的get方法"><a href="#_6、linkedhashmap的get方法" class="header-anchor">#</a> 6、LinkedHashMap的get方法</h2> <p>LinkedHashMap重写了 HashMap的get方法，主要新增了按访问顺序维护链表的功能。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span>
    <span class="token comment">// 调用 HashMap 的 getNode 方法，使用键的哈希值查找节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token comment">// 如果节点不存在，返回 null</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token comment">// 如果 accessOrder 为 true，表示按访问顺序维护链表</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>accessOrder<span class="token punctuation">)</span>
        <span class="token comment">// 调用 afterNodeAccess 方法，将访问的节点移动到链表尾部</span>
        <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 返回节点的值</span>
    <span class="token keyword">return</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p><code>afterNodeAccess</code>在上面已经详细注释了。</p> <h2 id="_7、linkedhashmap的remove方法"><a href="#_7、linkedhashmap的remove方法" class="header-anchor">#</a> 7、LinkedHashMap的remove方法</h2> <p>LinkedHashMap的remove方法在设计上和put方法有相似之处，LinkedHashMap并没有重写HashMap的remove方法，而是重写了<code>afterNodeRemoval</code>方法，在删除节点时维护双向链表。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">afterNodeRemoval</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// unlink</span>
    <span class="token comment">// 将节点 e 转换为 LinkedHashMap.Entry 类型</span>
    <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> e<span class="token punctuation">;</span>
    <span class="token comment">// 获取节点 p 的前一个和后一个节点</span>
    <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> b <span class="token operator">=</span> p<span class="token punctuation">.</span>before<span class="token punctuation">,</span> a <span class="token operator">=</span> p<span class="token punctuation">.</span>after<span class="token punctuation">;</span>
    <span class="token comment">// 将节点 p 的 before 和 after 指针置为 null</span>
    p<span class="token punctuation">.</span>before <span class="token operator">=</span> p<span class="token punctuation">.</span>after <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token comment">// 更新前一个节点和后一个节点的指针</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        head <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">// 如果 p 没有前一个节点，则它是头节点，更新头节点为 a</span>
    <span class="token keyword">else</span>
        b<span class="token punctuation">.</span>after <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">// 否则，将前一个节点的 after 指针指向 a</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        tail <span class="token operator">=</span> b<span class="token punctuation">;</span> <span class="token comment">// 如果 p 没有后一个节点，则它是尾节点，更新尾节点为 b</span>
    <span class="token keyword">else</span>
        a<span class="token punctuation">.</span>before <span class="token operator">=</span> b<span class="token punctuation">;</span> <span class="token comment">// 否则，将后一个节点的 before 指针指向 b</span>
<span class="token punctuation">}</span>

</code></pre></div><p>最后再整体看下HashMap中留给LinkedHashMap扩展的几个方法：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// Callbacks to allow LinkedHashMap post-actions</span>

	<span class="token comment">// 在访问节点（即调用 get 方法）后调用。</span>
	<span class="token comment">// 主要用途：LinkedHashMap 重写此方法，用于在访问一个节点后将其移动到双向链表的尾部，以维护访问顺序</span>
    <span class="token keyword">void</span> <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>

	<span class="token comment">// 在插入新节点后调用  </span>
	<span class="token comment">// 主要用途：LinkedHashMap 重写此方法，用于在插入新节点后检查并移除最老的节点，以维护固定大小的缓存或按照插入顺序迭代。</span>
    <span class="token keyword">void</span> <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>

	<span class="token comment">// 在删除节点后调用</span>
	<span class="token comment">// 主要用途：LinkedHashMap 重写此方法，用于在删除节点后调整双向链表的指针，确保链表的完整性。</span>
    <span class="token keyword">void</span> <span class="token function">afterNodeRemoval</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
</code></pre></div><p>其中afterNodeInsertion方法的参数 <code>boolean evict</code>,该参数指示当前的操作是否在创建模式下。如果为 false，表示哈希表处于创建模式；如果为 true，表示哈希表处于正常操作模式。此参数通常在初始化哈希表时使用，以避免在创建模式中触发删除操作。</p> <p><strong>evict 参数为 false 的情况：</strong><br>
在哈希表初始化时，通过 putMapEntries 方法调用 putVal，设置 evict 为 false。  HashMap的readObject反序列化方法也会调用 putVal，设置 evict 为 false。</p> <p><strong>evict 参数为 true 的情况：</strong><br>
正常操作（非创建模式）下，插入或更新元素时，evict 为 true，允许执行淘汰策略。</p> <h2 id="_8、linkedhashmap的迭代器"><a href="#_8、linkedhashmap的迭代器" class="header-anchor">#</a> 8、LinkedHashMap的迭代器</h2> <p>LinkedHashMap的迭代器可以对比 <a href="https://deepjava.blog.csdn.net/article/details/139627417" target="_blank" rel="noopener noreferrer">HashMap详解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 这篇文章的 HashMap的迭代器来学习。</p> <p>    二者本质的区别是由 LinkedHashMap 维护了双向链表而决定的。 LinkedHashMap的迭代器不会像HashMap的迭代器那样遍历全部的数组节点，而是通过双向链表的头结点，以及after指针一个一个往下遍历，这种方式就少了HashMap那种遍历全部数组节点的过程，直接通过after指针就能遍历全部的元素,这种方式比 HashMap 的迭代更为直接高效。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">LinkedHashIterator</span> <span class="token punctuation">{</span>
        <span class="token comment">// 下一个要返回的节点</span>
        <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span>        
        <span class="token comment">// 当前的节点</span>
        <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> current<span class="token punctuation">;</span>     
        <span class="token comment">// 用于快速失败的期望修改计数</span>
        <span class="token keyword">int</span> expectedModCount<span class="token punctuation">;</span>  

        <span class="token comment">// 构造方法</span>
        <span class="token class-name">LinkedHashIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 初始化下一个节点为链表的头节点</span>
            next <span class="token operator">=</span> head<span class="token punctuation">;</span>
            <span class="token comment">// 初始化期望的修改计数，等于当前的修改计数</span>
            expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span>
            <span class="token comment">// 初始化当前节点为null</span>
            current <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 判断是否有下一个元素</span>
        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 获取下一个节点</span>
        <span class="token keyword">final</span> <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">nextNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// e用于存储当前的下一个节点</span>
            <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> next<span class="token punctuation">;</span>
            <span class="token comment">// 如果哈希表的修改计数与期望的修改计数不同，抛出并发修改异常</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 如果下一个节点为空，抛出没有元素异常</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 将当前节点设为下一个节点</span>
            current <span class="token operator">=</span> e<span class="token punctuation">;</span>
            <span class="token comment">// 更新下一个节点为当前节点的下一个节点（after）</span>
            next <span class="token operator">=</span> e<span class="token punctuation">.</span>after<span class="token punctuation">;</span>
            <span class="token comment">// 返回当前的节点</span>
            <span class="token keyword">return</span> e<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

</code></pre></div><h2 id="_9、linkedhashmap的一些常见问题"><a href="#_9、linkedhashmap的一些常见问题" class="header-anchor">#</a> 9、LinkedHashMap的一些常见问题</h2> <h3 id="linkedhashmap-和-hashmap-的区别及适用场景"><a href="#linkedhashmap-和-hashmap-的区别及适用场景" class="header-anchor">#</a> LinkedHashMap 和 HashMap 的区别及适用场景</h3> <h3 id="数据结构对比"><a href="#数据结构对比" class="header-anchor">#</a> 数据结构对比</h3> <table><thead><tr><th>特性</th> <th>HashMap</th> <th>LinkedHashMap</th></tr></thead> <tbody><tr><td>数据结构</td> <td>数组 + 链表（红黑树）</td> <td>数组  + 链表（红黑树）+ 双向链表</td></tr> <tr><td>顺序保证</td> <td>无</td> <td>按插入顺序或访问顺序</td></tr> <tr><td>空间开销</td> <td>较低</td> <td>较高（需要额外维护链表指针）</td></tr></tbody></table> <h3 id="插入和迭代性能"><a href="#插入和迭代性能" class="header-anchor">#</a> 插入和迭代性能</h3> <table><thead><tr><th>操作</th> <th>HashMap</th> <th>LinkedHashMap</th></tr></thead> <tbody><tr><td>插入</td> <td>O(1) 平均，O(n) 最坏（哈希冲突）</td> <td>O(1) 平均，O(n) 最坏（哈希冲突）</td></tr> <tr><td>删除</td> <td>O(1) 平均，O(n) 最坏(未转红黑树的情况)</td> <td>O(1) 平均，O(n) 最坏(未转红黑树的情况)</td></tr> <tr><td>查找</td> <td>O(1) 平均，O(n) 最坏(未转红黑树的情况)</td> <td>O(1) 平均，O(n) 最坏(未转红黑树的情况)</td></tr> <tr><td>迭代</td> <td>与数据插入顺序无关，但是要循环数组</td> <td>按插入顺序或访问顺序，直接遍历链表，性能稍好</td></tr></tbody></table> <h3 id="适用场景"><a href="#适用场景" class="header-anchor">#</a> 适用场景</h3> <table><thead><tr><th>场景</th> <th>HashMap</th> <th>LinkedHashMap</th></tr></thead> <tbody><tr><td>快速查找和插入</td> <td>✔</td> <td>✔</td></tr> <tr><td>需要保证元素顺序</td> <td>✖</td> <td>✔</td></tr> <tr><td>LRU 缓存实现</td> <td>✖</td> <td>✔</td></tr> <tr><td>内存使用较少的场景</td> <td>✔</td> <td>✖</td></tr></tbody></table> <ul><li><p><strong>HashMap</strong>:</p> <ul><li>适用于对元素顺序没有要求的场景。</li> <li>高效的查找、插入和删除操作。</li> <li>内存占用较少。</li></ul></li> <li><p><strong>LinkedHashMap</strong>:</p> <ul><li>需要维护元素顺序的场景。</li> <li>实现 LRU（最近最少使用）缓存。</li> <li>适合需要顺序遍历的场景，且可以按插入顺序或访问顺序遍历。</li> <li>较高的内存开销。</li></ul></li></ul></div></section> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/blog/java-collection/六、HashMap详解.html" class="prev">
          六、HashMap详解
        </a></span> <span class="next"><a href="/blog/java-collection/八、ConcurrentHashMap详解.html">
          八、ConcurrentHashMap详解
        </a></span></p></div> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-b57cc07c data-v-7dd95ae2><li class="level-2" data-v-b57cc07c><a href="/blog/java-collection/%E4%B8%83%E3%80%81LinkedHashMap%E8%AF%A6%E8%A7%A3.html#_1、linkedhashmap的继承体系" class="sidebar-link reco-side-_1、linkedhashmap的继承体系" data-v-b57cc07c>1、LinkedHashMap的继承体系</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/java-collection/%E4%B8%83%E3%80%81LinkedHashMap%E8%AF%A6%E8%A7%A3.html#_2、linkedhashmap的特性介绍和代码示例" class="sidebar-link reco-side-_2、linkedhashmap的特性介绍和代码示例" data-v-b57cc07c>2、LinkedHashMap的特性介绍和代码示例</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E4%B8%83%E3%80%81LinkedHashMap%E8%AF%A6%E8%A7%A3.html#_1、特性" class="sidebar-link reco-side-_1、特性" data-v-b57cc07c>①、特性</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E4%B8%83%E3%80%81LinkedHashMap%E8%AF%A6%E8%A7%A3.html#_2、适用场景" class="sidebar-link reco-side-_2、适用场景" data-v-b57cc07c>②、适用场景</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E4%B8%83%E3%80%81LinkedHashMap%E8%AF%A6%E8%A7%A3.html#使用linkedhashmap-实现最简单的-lru缓存" class="sidebar-link reco-side-使用linkedhashmap-实现最简单的-lru缓存" data-v-b57cc07c>使用LinkedHashMap 实现最简单的 LRU缓存</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/java-collection/%E4%B8%83%E3%80%81LinkedHashMap%E8%AF%A6%E8%A7%A3.html#_3、linkedhashmap的构造函数" class="sidebar-link reco-side-_3、linkedhashmap的构造函数" data-v-b57cc07c>3、LinkedHashMap的构造函数</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/java-collection/%E4%B8%83%E3%80%81LinkedHashMap%E8%AF%A6%E8%A7%A3.html#_4、linkedhashmap是如何存储元素的-底层数据结构是什么" class="sidebar-link reco-side-_4、linkedhashmap是如何存储元素的-底层数据结构是什么" data-v-b57cc07c>4、LinkedHashMap是如何存储元素的，底层数据结构是什么？</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E4%B8%83%E3%80%81LinkedHashMap%E8%AF%A6%E8%A7%A3.html#linkedhashmap的属性注释" class="sidebar-link reco-side-linkedhashmap的属性注释" data-v-b57cc07c>LinkedHashMap的属性注释</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E4%B8%83%E3%80%81LinkedHashMap%E8%AF%A6%E8%A7%A3.html#linkedhashmap的静态内部类entry-k-v" class="sidebar-link reco-side-linkedhashmap的静态内部类entry-k-v" data-v-b57cc07c>LinkedHashMap的静态内部类Entry&lt;K,V&gt;</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E4%B8%83%E3%80%81LinkedHashMap%E8%AF%A6%E8%A7%A3.html#从treenode的继承结构引发一个关于设计类继承关系的思考" class="sidebar-link reco-side-从treenode的继承结构引发一个关于设计类继承关系的思考" data-v-b57cc07c>从TreeNode的继承结构引发一个关于设计类继承关系的思考？</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/java-collection/%E4%B8%83%E3%80%81LinkedHashMap%E8%AF%A6%E8%A7%A3.html#_5、linkedhashmap的put方法" class="sidebar-link reco-side-_5、linkedhashmap的put方法" data-v-b57cc07c>5、LinkedHashMap的put方法</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E4%B8%83%E3%80%81LinkedHashMap%E8%AF%A6%E8%A7%A3.html#newnode方法" class="sidebar-link reco-side-newnode方法" data-v-b57cc07c>newNode方法</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E4%B8%83%E3%80%81LinkedHashMap%E8%AF%A6%E8%A7%A3.html#linknodelast方法" class="sidebar-link reco-side-linknodelast方法" data-v-b57cc07c>linkNodeLast方法</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E4%B8%83%E3%80%81LinkedHashMap%E8%AF%A6%E8%A7%A3.html#afternodeaccess方法" class="sidebar-link reco-side-afternodeaccess方法" data-v-b57cc07c>afterNodeAccess方法</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E4%B8%83%E3%80%81LinkedHashMap%E8%AF%A6%E8%A7%A3.html#afternodeinsertion方法" class="sidebar-link reco-side-afternodeinsertion方法" data-v-b57cc07c>afterNodeInsertion方法</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/java-collection/%E4%B8%83%E3%80%81LinkedHashMap%E8%AF%A6%E8%A7%A3.html#_6、linkedhashmap的get方法" class="sidebar-link reco-side-_6、linkedhashmap的get方法" data-v-b57cc07c>6、LinkedHashMap的get方法</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/java-collection/%E4%B8%83%E3%80%81LinkedHashMap%E8%AF%A6%E8%A7%A3.html#_7、linkedhashmap的remove方法" class="sidebar-link reco-side-_7、linkedhashmap的remove方法" data-v-b57cc07c>7、LinkedHashMap的remove方法</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/java-collection/%E4%B8%83%E3%80%81LinkedHashMap%E8%AF%A6%E8%A7%A3.html#_8、linkedhashmap的迭代器" class="sidebar-link reco-side-_8、linkedhashmap的迭代器" data-v-b57cc07c>8、LinkedHashMap的迭代器</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/java-collection/%E4%B8%83%E3%80%81LinkedHashMap%E8%AF%A6%E8%A7%A3.html#_9、linkedhashmap的一些常见问题" class="sidebar-link reco-side-_9、linkedhashmap的一些常见问题" data-v-b57cc07c>9、LinkedHashMap的一些常见问题</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E4%B8%83%E3%80%81LinkedHashMap%E8%AF%A6%E8%A7%A3.html#linkedhashmap-和-hashmap-的区别及适用场景" class="sidebar-link reco-side-linkedhashmap-和-hashmap-的区别及适用场景" data-v-b57cc07c>LinkedHashMap 和 HashMap 的区别及适用场景</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E4%B8%83%E3%80%81LinkedHashMap%E8%AF%A6%E8%A7%A3.html#数据结构对比" class="sidebar-link reco-side-数据结构对比" data-v-b57cc07c>数据结构对比</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E4%B8%83%E3%80%81LinkedHashMap%E8%AF%A6%E8%A7%A3.html#插入和迭代性能" class="sidebar-link reco-side-插入和迭代性能" data-v-b57cc07c>插入和迭代性能</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E4%B8%83%E3%80%81LinkedHashMap%E8%AF%A6%E8%A7%A3.html#适用场景" class="sidebar-link reco-side-适用场景" data-v-b57cc07c>适用场景</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/blog/assets/js/app.86d0dcf0.js" defer></script><script src="/blog/assets/js/7.4b97e329.js" defer></script><script src="/blog/assets/js/2.cc89bbf4.js" defer></script><script src="/blog/assets/js/1.fb256d2a.js" defer></script><script src="/blog/assets/js/41.2d4e929a.js" defer></script>
  </body>
</html>
