<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>ConcurrentLinkedQueue详解 | GM的博客</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="stylesheet" href="/blog/custom.css">
    <script src="/blog/custom.js"></script>
    <meta name="description" content="博观约取、厚积薄发。">
    
    <link rel="preload" href="/blog/assets/css/0.styles.0612dbff.css" as="style"><link rel="preload" href="/blog/assets/js/app.c5880b14.js" as="script"><link rel="preload" href="/blog/assets/js/7.2f499a27.js" as="script"><link rel="preload" href="/blog/assets/js/2.c1d62214.js" as="script"><link rel="preload" href="/blog/assets/js/1.ad340df3.js" as="script"><link rel="preload" href="/blog/assets/js/50.d53378c7.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.255c6e88.js"><link rel="prefetch" href="/blog/assets/js/11.7c9f1dd0.js"><link rel="prefetch" href="/blog/assets/js/14.4fa15396.js"><link rel="prefetch" href="/blog/assets/js/15.81523984.js"><link rel="prefetch" href="/blog/assets/js/16.5627e9c8.js"><link rel="prefetch" href="/blog/assets/js/17.7cdae69c.js"><link rel="prefetch" href="/blog/assets/js/18.21f1f4b3.js"><link rel="prefetch" href="/blog/assets/js/19.2fef6aac.js"><link rel="prefetch" href="/blog/assets/js/20.18323053.js"><link rel="prefetch" href="/blog/assets/js/21.4268d6f7.js"><link rel="prefetch" href="/blog/assets/js/22.f6b8bd65.js"><link rel="prefetch" href="/blog/assets/js/23.ae61d454.js"><link rel="prefetch" href="/blog/assets/js/24.fc472665.js"><link rel="prefetch" href="/blog/assets/js/25.8a217a65.js"><link rel="prefetch" href="/blog/assets/js/26.692e69bd.js"><link rel="prefetch" href="/blog/assets/js/27.a396b304.js"><link rel="prefetch" href="/blog/assets/js/28.ea8f592d.js"><link rel="prefetch" href="/blog/assets/js/29.054ab9de.js"><link rel="prefetch" href="/blog/assets/js/3.b38c2113.js"><link rel="prefetch" href="/blog/assets/js/30.2962fbba.js"><link rel="prefetch" href="/blog/assets/js/31.39d4cb55.js"><link rel="prefetch" href="/blog/assets/js/32.97324ada.js"><link rel="prefetch" href="/blog/assets/js/33.23619402.js"><link rel="prefetch" href="/blog/assets/js/34.d9e34b8a.js"><link rel="prefetch" href="/blog/assets/js/35.c4f7378c.js"><link rel="prefetch" href="/blog/assets/js/36.71d98d02.js"><link rel="prefetch" href="/blog/assets/js/37.44dc0ca9.js"><link rel="prefetch" href="/blog/assets/js/38.d7a1b864.js"><link rel="prefetch" href="/blog/assets/js/39.1624183e.js"><link rel="prefetch" href="/blog/assets/js/4.73e76377.js"><link rel="prefetch" href="/blog/assets/js/40.59506fc5.js"><link rel="prefetch" href="/blog/assets/js/41.06d05dc9.js"><link rel="prefetch" href="/blog/assets/js/42.cca02087.js"><link rel="prefetch" href="/blog/assets/js/43.9c106d46.js"><link rel="prefetch" href="/blog/assets/js/44.fb4dae1b.js"><link rel="prefetch" href="/blog/assets/js/45.2d68b097.js"><link rel="prefetch" href="/blog/assets/js/46.d0ae85ff.js"><link rel="prefetch" href="/blog/assets/js/47.ab3905e9.js"><link rel="prefetch" href="/blog/assets/js/48.b77d35b8.js"><link rel="prefetch" href="/blog/assets/js/49.f3767c04.js"><link rel="prefetch" href="/blog/assets/js/5.29366f46.js"><link rel="prefetch" href="/blog/assets/js/51.c671da67.js"><link rel="prefetch" href="/blog/assets/js/52.775c6a7a.js"><link rel="prefetch" href="/blog/assets/js/53.987cfdd2.js"><link rel="prefetch" href="/blog/assets/js/54.a7acb48b.js"><link rel="prefetch" href="/blog/assets/js/55.3c96363f.js"><link rel="prefetch" href="/blog/assets/js/56.16a9846f.js"><link rel="prefetch" href="/blog/assets/js/57.e4b1e2cd.js"><link rel="prefetch" href="/blog/assets/js/58.3c9ca4ad.js"><link rel="prefetch" href="/blog/assets/js/59.caf8992e.js"><link rel="prefetch" href="/blog/assets/js/6.2775cf9f.js"><link rel="prefetch" href="/blog/assets/js/60.746df84c.js"><link rel="prefetch" href="/blog/assets/js/61.a781b7b8.js"><link rel="prefetch" href="/blog/assets/js/62.ab8862ca.js"><link rel="prefetch" href="/blog/assets/js/63.2aa3bf70.js"><link rel="prefetch" href="/blog/assets/js/64.59ba6830.js"><link rel="prefetch" href="/blog/assets/js/65.6971a77c.js"><link rel="prefetch" href="/blog/assets/js/66.c3314d41.js"><link rel="prefetch" href="/blog/assets/js/67.79a3cdd9.js"><link rel="prefetch" href="/blog/assets/js/68.38c45174.js"><link rel="prefetch" href="/blog/assets/js/69.403149a3.js"><link rel="prefetch" href="/blog/assets/js/8.10fb926e.js"><link rel="prefetch" href="/blog/assets/js/9.82e18295.js"><link rel="prefetch" href="/blog/assets/js/vendors~docsearch.6e140397.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.0612dbff.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>GM的博客</h3> <p class="description" data-v-59e6cb88>博观约取、厚积薄发。</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2024
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/head.jpg" alt="GM的博客" class="logo"> <span class="site-name">GM的博客</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://deepjava-gm.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  首页
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      GM的博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/deepjava-gm" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/qq_37883866" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><!----> <!----> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>31</h3> <h6 data-v-1fad0c41>文章</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>0</h3> <h6 data-v-1fad0c41>标签</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="https://deepjava-gm.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  首页
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      GM的博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/deepjava-gm" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/qq_37883866" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/blog/" class="sidebar-heading clickable router-link-active"><span>构建自己的Java知识体系</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/" aria-current="page" class="sidebar-link">引言</a></li><li><a href="/blog/contact.html" class="sidebar-link">反馈</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/blog/javabase/一、Java基础知识" class="sidebar-heading clickable"><span>Java基础</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/blog/java-collection/一、Java集合概述" class="sidebar-heading clickable open"><span>Java集合</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/java-collection/一、Java集合概述.html" class="sidebar-link">一、Java集合概述</a></li><li><a href="/blog/java-collection/二、ArrayList详解.html" class="sidebar-link">二、ArrayList详解</a></li><li><a href="/blog/java-collection/三、LinkedList详解.html" class="sidebar-link">三、LinkedList详解</a></li><li><a href="/blog/java-collection/四、CopyOnWriteArrayList详解.html" class="sidebar-link">四、CopyOnWriteArrayList详解</a></li><li><a href="/blog/java-collection/五、Stack详解.html" class="sidebar-link">五、Stack详解</a></li><li><a href="/blog/java-collection/六、HashMap详解.html" class="sidebar-link">六、HashMap详解</a></li><li><a href="/blog/java-collection/七、LinkedHashMap详解.html" class="sidebar-link">七、LinkedHashMap详解</a></li><li><a href="/blog/java-collection/八、ConcurrentHashMap详解.html" class="sidebar-link">八、ConcurrentHashMap详解</a></li><li><a href="/blog/java-collection/九、ArrayDeque详解.html" class="sidebar-link">九、ArrayDeque详解</a></li><li><a href="/blog/java-collection/十、BlockingQueue详解.html" class="sidebar-link">十、BlockingQueue详解</a></li><li><a href="/blog/java-collection/十一、PriorityQueue详解.html" class="sidebar-link">十一、PriorityQueue详解</a></li><li><a href="/blog/java-collection/十二、DelayQueue详解.html" class="sidebar-link">十二、DelayQueue详解</a></li><li><a href="/blog/java-collection/十三、ConcurrentLinkedQueue详解.html" class="active sidebar-link">十三、ConcurrentLinkedQueue详解</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/blog/java-concurrent/一、Java并发编程基础知识点" class="sidebar-heading clickable"><span>Java并发编程</span> <span class="arrow right"></span></a> <!----></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88></h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2024
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">ConcurrentLinkedQueue详解</h1> <div data-v-8a445198><!----> <!----> <!----> <!----></div></div> <div class="theme-reco-content content__default"><h1 id="concurrentlinkedqueue详解"><a href="#concurrentlinkedqueue详解" class="header-anchor">#</a> ConcurrentLinkedQueue详解</h1> <h2 id="_1、concurrentlinkedqueue简介"><a href="#_1、concurrentlinkedqueue简介" class="header-anchor">#</a> 1、ConcurrentLinkedQueue简介</h2> <p>ConcurrentLinkedQueue 是 Java 中 java.util.concurrent 包下的一个非阻塞线程安全队列实现。<br>
为什么要详细讲这个队列呢？  主要还是因为这个队列的高并发，无锁等特性。<br>
同时这个队列总结完之后，就开始进入Java并发相关的内容总结了。</p> <p>ConcurrentLinkedQueue 的一些关键特性：</p> <ul><li><p>①、 非阻塞算法
ConcurrentLinkedQueue 使用的是 Michael &amp; Scott 算法（Michael &amp; Scott 算法的提出者是 Maged M. Michael 和 Michael L. Scott）。Michael &amp; Scott 是无锁算法，允许多个线程并发访问队列，而无需显式的锁(通过使用 CAS 等原子操作保证线程安全)，从而减少了锁竞争和上下文切换的开销。</p></li> <li><p>②、 线程安全
该队列是线程安全的，允许多个线程同时进行插入和删除操作。所有的操作（如插入、删除和遍历）都是原子操作，不会出现线程间的竞态条件。</p></li> <li><p>③、高性能
由于采用了非阻塞算法，ConcurrentLinkedQueue 在高并发环境下性能优越，特别适用于需要高吞吐量的场景。</p></li></ul> <h2 id="_2、concurrentlinkedqueue继承体系"><a href="#_2、concurrentlinkedqueue继承体系" class="header-anchor">#</a> 2、ConcurrentLinkedQueue继承体系</h2> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcurrentLinkedQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>
        <span class="token keyword">implements</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span>
</code></pre></div><img src="/blog/images/28-1.png" alt="mixureSecure"> <p>上面简介已经说了ConcurrentLinkedQueue 是个线程安全的队列，从继承结构也可以看出其实现了Queue接口，具有队列的功能。</p> <h2 id="_3、concurrentlinkedqueue的构造函数"><a href="#_3、concurrentlinkedqueue的构造函数" class="header-anchor">#</a> 3、ConcurrentLinkedQueue的构造函数</h2> <p><strong>空参构造</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ConcurrentLinkedQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 初始化时，head 和 tail 都指向一个新的空节点</span>
    head <span class="token operator">=</span> tail <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>带一个集合参数的构造</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ConcurrentLinkedQueue</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// h 和 t 分别表示链表的头节点和尾节点</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> h <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> t <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

    <span class="token comment">// 遍历集合 c，将每个元素插入到队列中</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">E</span> e <span class="token operator">:</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 检查元素是否为 null，如果是则抛出 NullPointerException</span>
        <span class="token function">checkNotNull</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 创建一个包含元素 e 的新节点</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 如果 h 为空，表示这是第一个元素，初始化 h 和 t</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            h <span class="token operator">=</span> t <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">// 否则，将新节点添加到链表的尾部</span>
            t<span class="token punctuation">.</span><span class="token function">lazySetNext</span><span class="token punctuation">(</span>newNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
            t <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 如果集合 c 为空，初始化 h 和 t 为一个新的空节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        h <span class="token operator">=</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 将 head 和 tail 设置为链表的头和尾</span>
    head <span class="token operator">=</span> h<span class="token punctuation">;</span>
    tail <span class="token operator">=</span> t<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_4、concurrentlinkedqueue的数据结构"><a href="#_4、concurrentlinkedqueue的数据结构" class="header-anchor">#</a> 4、ConcurrentLinkedQueue的数据结构</h2> <h3 id="concurrentlinkedqueue类的属性注释"><a href="#concurrentlinkedqueue类的属性注释" class="header-anchor">#</a> ConcurrentLinkedQueue类的属性注释</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcurrentLinkedQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>
        <span class="token keyword">implements</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">{</span>

    <span class="token comment">// 使用 transient 和 volatile 修饰符来声明 head 和 tail，这两个字段不会被序列化，并且保证可见性</span>
    <span class="token comment">// head 表示队列的头节点，指向队列的第一个有效元素</span>
    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> head<span class="token punctuation">;</span>

    <span class="token comment">// tail 表示队列的尾节点，指向队列的最后一个有效元素</span>
    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> tail<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span>

</code></pre></div><p>可以看到ConcurrentLinkedQueue类的属性并不多，我们主要关注一个头结点head，一个尾结点tail。</p> <h3 id="concurrentlinkedqueue真正存储元素的类node-e"><a href="#concurrentlinkedqueue真正存储元素的类node-e" class="header-anchor">#</a> ConcurrentLinkedQueue真正存储元素的类<code>Node&lt;E&gt;</code></h3> <p>可以看到 这里的<code>Node&lt;E&gt;</code>节点只有一个next指针指向下一个元素，说明ConcurrentLinkedQueue是一个单向链表的结构。<br>
并且Node类中提供了一些CAS操作来更新节点的值。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// Node 类是一个私有的静态内部类，用于存储 ConcurrentLinkedQueue 中的元素</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token comment">// 存储节点中的元素，使用 volatile 修饰以确保可见性</span>
    <span class="token keyword">volatile</span> <span class="token class-name">E</span> item<span class="token punctuation">;</span>

    <span class="token comment">// 指向下一个节点，使用 volatile 修饰以确保可见性</span>
    <span class="token keyword">volatile</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span>

    <span class="token comment">/**
     * 构造一个新节点。使用 relaxed write，因为只有在通过 casNext 发布后，item 才能被看到。
     * @param item 节点存储的元素
     */</span>
    <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">E</span> item<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 使用 Unsafe 类直接操作内存，将 item 放入节点中</span>
        <span class="token constant">UNSAFE</span><span class="token punctuation">.</span><span class="token function">putObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> itemOffset<span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 使用 CAS 操作更新节点中的 item 字段</span>
    <span class="token keyword">boolean</span> <span class="token function">casItem</span><span class="token punctuation">(</span><span class="token class-name">E</span> cmp<span class="token punctuation">,</span> <span class="token class-name">E</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token constant">UNSAFE</span><span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> itemOffset<span class="token punctuation">,</span> cmp<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 延迟设置 next 字段的值，使用有序写入</span>
    <span class="token keyword">void</span> <span class="token function">lazySetNext</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token constant">UNSAFE</span><span class="token punctuation">.</span><span class="token function">putOrderedObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> nextOffset<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 使用 CAS 操作更新节点中的 next 字段</span>
    <span class="token keyword">boolean</span> <span class="token function">casNext</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> cmp<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token constant">UNSAFE</span><span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> nextOffset<span class="token punctuation">,</span> cmp<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Unsafe 相关的字段和静态代码块</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>Unsafe</span> <span class="token constant">UNSAFE</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> itemOffset<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> nextOffset<span class="token punctuation">;</span>

    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// 获取 Unsafe 实例</span>
            <span class="token constant">UNSAFE</span> <span class="token operator">=</span> <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>Unsafe</span><span class="token punctuation">.</span><span class="token function">getUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> k <span class="token operator">=</span> <span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>
            <span class="token comment">// 获取 item 字段的偏移量</span>
            itemOffset <span class="token operator">=</span> <span class="token constant">UNSAFE</span><span class="token punctuation">.</span><span class="token function">objectFieldOffset</span><span class="token punctuation">(</span>k<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">&quot;item&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 获取 next 字段的偏移量</span>
            nextOffset <span class="token operator">=</span> <span class="token constant">UNSAFE</span><span class="token punctuation">.</span><span class="token function">objectFieldOffset</span><span class="token punctuation">(</span>k<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">&quot;next&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><h3 id="concurrentlinkedqueue数据结构图示"><a href="#concurrentlinkedqueue数据结构图示" class="header-anchor">#</a> ConcurrentLinkedQueue数据结构图示</h3> <p>是不是有点印象，和LinkedBlockingQueue的数据结构是一样的。</p> <img src="/blog/images/28-2.png" alt="mixureSecure"> <p>自引用节点图示：</p> <img src="/blog/images/28-3.png" alt="mixureSecure"> <p>有些资料把这种节点叫哨兵节点。我还是习惯形似叫法，就叫它自引用节点吧。<br>
自己引用自己的节点叫自引用节点没毛病吧，生动形象。</p> <h2 id="_5、concurrentlinkedqueue的offer方法"><a href="#_5、concurrentlinkedqueue的offer方法" class="header-anchor">#</a> 5、ConcurrentLinkedQueue的<code>offer</code>方法</h2> <p><code>offer</code> 方法用于将指定的元素插入到 ConcurrentLinkedQueue 的尾部。<br>
如果插入成功，返回 true。</p> <h3 id="元素在入队时的三种情况"><a href="#元素在入队时的三种情况" class="header-anchor">#</a> 元素在入队时的三种情况</h3> <ul><li>①、当p的后继节点为空时（此时p为真正的尾节点），尝试CAS增加新节点，成功后尝试更新尾节点tail；</li> <li>②、当p等于p的后继节点时（p的next指向自己，说明p是自引用节点(<strong>移除元素或者遍历元素</strong>时可能构造出自引用节点)
此时判断尾节点是否被修改过，如果尾节点被修改过就定位到最新的尾节点，如果未被修改过（使用next无法继续遍历，因为自己指向了自己，next还是自己），只能定位到头节点，从头开始遍历；</li> <li>③、其他情况时，说明此时的p并不是真正的尾节点，需要定位到真正尾节点；此时如果p不是原来的尾节点并且尾节点被修改过，那就定位到尾节点，否则定位到p的后继节点q，继续遍历；</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 检查元素是否为 null，如果是，则抛出 NullPointerException</span>
    <span class="token function">checkNotNull</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 创建一个包含元素 e 的新节点</span>
    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 使用 for 循环尝试将新节点插入到队列的尾部</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> t <span class="token operator">=</span> tail<span class="token punctuation">,</span> p <span class="token operator">=</span> t<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> q <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>

        <span class="token comment">// 如果 p.next 为空，表示 p 是当前的最后一个节点</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>q <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 尝试使用 CAS 操作将 newNode 插入到 p 之后</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">casNext</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> newNode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 成功的 CAS 操作是将 e 插入队列的尾部</span>
                <span class="token comment">// newNode 现在成为队列中的实际节点</span>

                <span class="token comment">// 如果 p 不是 tail，尝试更新 tail 指针</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> t<span class="token punctuation">)</span>
                    <span class="token function">casTail</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> newNode<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 失败也没关系</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// CAS 操作失败，表示其他线程插入了新节点，重新读取 next</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 如果 p == p.next，表示我们已经脱离了链表</span>
            <span class="token comment">// 如果 tail 没有改变，说明 tail 也脱离了链表，需要从 head 重新开始</span>
            <span class="token comment">// 否则，新的 tail 是一个更好的选择</span>
            p <span class="token operator">=</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> <span class="token punctuation">(</span>t <span class="token operator">=</span> tail<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> t <span class="token operator">:</span> head<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">// 检查 tail 指针是否更新，如果没有更新，则继续向前移动</span>
            p <span class="token operator">=</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> t <span class="token operator">&amp;&amp;</span> t <span class="token operator">!=</span> <span class="token punctuation">(</span>t <span class="token operator">=</span> tail<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> t <span class="token operator">:</span> q<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><p>总结下：</p> <ul><li><p>①、检查输入：<br>
使用 checkNotNull(e) 检查元素是否为 null。如果元素为 null，则抛出 NullPointerException。</p></li> <li><p>②、创建新节点：<br>
使用 <code>new Node&lt;E&gt;(e)</code> 创建一个包含元素 e 的新节点 newNode。</p></li> <li><p>③、循环插入节点：
使用一个 for 循环不断尝试将 newNode 插入到队列的尾部。<br>
初始化 t 和 p 为当前的尾节点 tail。<br>
在循环中，通过 p.next 来检查当前节点是否是最后一个节点。<br>
如果 p.next 为空，则尝试使用 CAS 操作将 newNode 插入到 p 之后。<br>
如果 CAS 操作成功，将 newNode 插入队列，并尝试更新 tail 指针（如果 p 不是 tail）。<br>
如果 CAS 操作失败，表示有其他线程已经插入了新节点，重新读取 next 进行下一次尝试。<br>
如果 p == p.next，表示已经脱离了链表，需要重新设置 p 为 tail 或 head。<br>
如果 p.next 不为空且不等于 p，则向前移动 p，并在两步之后检查 tail 指针是否更新。</p></li></ul> <p>下面对变量再总结一下，方便下面进行多线程的分析：</p> <h3 id="offer方法中的变量"><a href="#offer方法中的变量" class="header-anchor">#</a> <code>offer</code>方法中的变量</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// t  表示队列临时的尾节点，初始时指向 tail。在多线程情况下，tail 可能随时变化。</span>
<span class="token comment">// p  表示队列真正的尾节点，初始时与 t 相同，当p节点为真正尾节点时才允许添加新节点。</span>
<span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> t <span class="token operator">=</span> tail<span class="token punctuation">,</span> p <span class="token operator">=</span> t<span class="token punctuation">;</span>

<span class="token comment">//  q 表示 p 节点的下一个节点。</span>
<span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> q <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>

<span class="token comment">// 下面这段代码很重要 </span>
<span class="token comment">// 这段代码检查 tail 是否发生了变化。如果 tail 发生了变化，p 会重新指向新的 tail；否则，p 会指向 head。</span>
 p <span class="token operator">=</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> <span class="token punctuation">(</span>t <span class="token operator">=</span> tail<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> t <span class="token operator">:</span> head<span class="token punctuation">;</span>
</code></pre></div><h3 id="动画演示单线程环境下offer的入队过程"><a href="#动画演示单线程环境下offer的入队过程" class="header-anchor">#</a> 动画演示单线程环境下<code>offer</code>的入队过程</h3> <p>代码示例：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestA</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token class-name">ConcurrentLinkedQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentLinkedQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">&quot;A&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">&quot;B&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">&quot;C&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">&quot;D&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>动画演示：</p> <img src="/blog/images/28-4.gif" alt="mixureSecure"> <p>从源码的步骤中我们可以得知，当第一个元素添加完成后，head和tail指针并没有移动仍然是指向默认的空Node节点，当第二个元素添加完毕的时候tail指针才会移动到新添加的Node上。</p> <p>我们继续添加两个元素</p> <div class="language-java extra-class"><pre class="language-java"><code>queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">&quot;C&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">&quot;D&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><img src="/blog/images/28-5.gif" alt="mixureSecure"> <p>可以看到添加C的时候没有移动tail指针，添加D的时候tail指针移动到了尾部。</p> <h2 id="注意避坑☆☆☆☆☆"><a href="#注意避坑☆☆☆☆☆" class="header-anchor">#</a> 注意避坑☆☆☆☆☆</h2> <h3 id="concurrentlinkedqueue断点offer方法或者打印队列的坑"><a href="#concurrentlinkedqueue断点offer方法或者打印队列的坑" class="header-anchor">#</a> ConcurrentLinkedQueue断点<code>offer</code>方法或者打印队列的坑</h3> <p>我习惯利用反射打印集合的内部状态，来验证自己分析的是否正确。</p> <p>但是这次遇到ConcurrentLinkedQueue算是彻彻底底掉进了坑里。</p> <p>问题复现：
先描述下问题
当我去看offer方法的源码时，我发现<code>offer(&quot;A&quot;)</code>之后的确没有改变head和tail的指针，然后head和tail指针依然是指向dummy Node，也就是初始化ConcurrentLinkedQueue时的那个初始化节点，同时把该节点的next设置成A节点。</p> <p>我为了验证下刚添加完A节点的状态，利用反射，打印了head和tail指针的hashCode，以及初始化节点的item和next，和队列queue。</p> <p>然后坑就来了：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">Field</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">ConcurrentLinkedQueue</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestA</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token comment">// 创建一个新的 ConcurrentLinkedQueue</span>
        <span class="token class-name">ConcurrentLinkedQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentLinkedQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> queueClass <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;================刚初始化================&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Field</span> head1 <span class="token operator">=</span> queueClass<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">&quot;head&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        head1<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Field</span> tail1 <span class="token operator">=</span> queueClass<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">&quot;tail&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        tail1<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Head node: &quot;</span> <span class="token operator">+</span> head1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Tail node: &quot;</span> <span class="token operator">+</span> tail1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 将元素 &quot;A&quot; 插入到队列中</span>
        queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">&quot;A&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;================插入A后================&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 打印队列</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 获取队列的 Class 对象</span>
        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> aClass <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 获取 head 和 tail 字段</span>
        <span class="token class-name">Field</span> headField <span class="token operator">=</span> aClass<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">&quot;head&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Field</span> tailField <span class="token operator">=</span> aClass<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">&quot;tail&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        headField<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        tailField<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 获取 head 和 tail 的值</span>
        <span class="token class-name">Object</span> head <span class="token operator">=</span> headField<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Object</span> tail <span class="token operator">=</span> tailField<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 打印 head 和 tail 的值</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Head node: &quot;</span> <span class="token operator">+</span> head<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Tail node: &quot;</span> <span class="token operator">+</span> tail<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 获取 head 和 tail 节点的 item 和 next 字段的值</span>
        <span class="token class-name">Field</span> itemField <span class="token operator">=</span> head<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">&quot;item&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Field</span> nextField <span class="token operator">=</span> head<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">&quot;next&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        itemField<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        nextField<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Head item: &quot;</span> <span class="token operator">+</span> itemField<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&quot;Head next: &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>nextField<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token operator">+</span>nextField<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Tail item: &quot;</span> <span class="token operator">+</span> itemField<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>tail<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Tail next: &quot;</span> <span class="token operator">+</span> nextField<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>tail<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>运行结果：</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>刚初始化<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span>
Head node: <span class="token number">356573597</span>
Tail node: <span class="token number">356573597</span>
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>插入A后<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
<span class="token punctuation">[</span>A<span class="token punctuation">]</span>
Head node: <span class="token number">1735600054</span>
Tail node: <span class="token number">356573597</span>
Head item: A
Head next: <span class="token number">0</span>
Tail item: null
Tail next: <span class="token number">356573597</span>
</code></pre></div><p>看到上面这个结果当时就懵了！！！<br>
这个结果就对应下图(这谁看了不迷糊)：</p> <img src="/blog/images/28-6.png" alt="mixureSecure"> <p>本来按照源码预想的结果应该是这样：</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>刚初始化<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
Head node: <span class="token number">356573597</span>
Tail node: <span class="token number">356573597</span>
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>插入A后<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
Head node: <span class="token number">356573597</span>
Tail node: <span class="token number">356573597</span>
Head item: null
Head next: <span class="token number">1735600054</span>
Tail item: null
Tail next: <span class="token number">1735600054</span>
</code></pre></div><p>应该对应这样的图：
<img src="/blog/images/28-7.png" alt="mixureSecure"></p> <p><strong>所以到底是什么原因呢？</strong></p> <h3 id="原因探究"><a href="#原因探究" class="header-anchor">#</a> 原因探究</h3> <p>为了去探究具体原因，我于是在<code>queue.offer(&quot;A&quot;);</code>进行了断点，准备一步一步去看，结果当<code>queue.offer(&quot;A&quot;);</code>执行完，return true；之后发现并没有什么特殊的。<br>
但是再看head和tail的状态，就发现不对了， head指向了A节点， tail指向初始节点，初始节点的next指向了自身。到底是什么神秘力量修改了head和tail呢？</p> <p>至此我是彻底懵了，仿佛陷入了罗生门，到底是凭看源码得到的结果对，还是断点看到的结果或者反射打印得到的结果对？</p> <h3 id="回到问题的本质"><a href="#回到问题的本质" class="header-anchor">#</a> 回到问题的本质</h3> <p>接下来就是漫长的排除法，首先排除多线程造成的影响，因为我使用的一直是单个主线程，再者排除反射的影响(一开始怀疑是反射的问题)，因为反射只是获取队列内部成员变量的状态，并不会造成数据结构的改变，而且即使不用反射打印head和tail，debug也会出现 tail指向初始节点，初始节点的next指向自身，head指向A节点的问题。</p> <p>开始查资料，百度，谷歌，chatGPT4o, 通义千问、文心一言。。。半天已经过去了。。。    没什么进展。。。</p> <p>晚上，又去查了B站，分析ConcurrentLinkedQueue的视频到是不少，但是没有找到去断点offer方法的，大都是照着源码分析，结果可想而知，按照源码分析一定是下面的结果：</p> <img src="/blog/images/28-8.png" alt="mixureSecure"> <p>然后又去知乎，找到一篇关于ConcurrentLinkedQueue的文章找到了点突破口。</p> <p>然后开始思考问题的本质<br>
这个问题本质上是出现了指向自身的节点：</p> <img src="/blog/images/28-9.png" alt="mixureSecure"> <p>而这种把初始节点的next指针指向自身的操作，在ConcurrentLinkedQueue中是存在的。</p> <p>我们就把 这种自身的next指针指向自己的节点叫自引用节点吧。</p> <p>至于自引用节点的作用后续再说，现在先把这个坑给过了。</p> <p>既然ConcurrentLinkedQueue内部存储的元素都是<code>Node</code>,那就从Node入手，看下Node中有哪些设置Node的next指针的方法：
可以看到有下面这两个方法：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">lazySetNext</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token constant">UNSAFE</span><span class="token punctuation">.</span><span class="token function">putOrderedObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> nextOffset<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>  

<span class="token keyword">boolean</span> <span class="token function">casNext</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> cmp<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">return</span> <span class="token constant">UNSAFE</span><span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> nextOffset<span class="token punctuation">,</span> cmp<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
</code></pre></div><p><code>putOrderedObject</code>是一个有序写操作。它确保写操作在Java内存模型中的某些情况下具有有序性，但不像volatile写操作那样强制所有的内存可见性保证。它可能比普通的volatile写操作稍微快一些。</p> <p>为了找到问题 我需要找到到底哪些<code>Node</code>节点对象 调用了这两个方法，并且传的next值是对象本身。</p> <p>最终发现是这个方法：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * 尝试将头节点更新为新的节点。如果成功，将旧的头节点设置为指向自身，作为一个自引用节点。
 * 
 * @param h 当前的头节点
 * @param p 新的头节点
 */</span>
<span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">updateHead</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> h<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 检查当前头节点和新头节点是否不同，并尝试使用CAS操作将头节点从h更新为p</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> p <span class="token operator">&amp;&amp;</span> <span class="token function">casHead</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果CAS操作成功，将旧的头节点的next字段设置为指向自身</span>
        h<span class="token punctuation">.</span><span class="token function">lazySetNext</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><p><code>h.lazySetNext(h);</code>  这不就是把自己的next指针指向自己了嘛~<br>
答案就近在眼前了。</p> <p>我只要再找到是哪里调用了<code>updateHead</code>方法就行了。</p> <p>发现有下面的方法调用了<code>updateHead</code>：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span>、 <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span>、<span class="token function">first</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
</code></pre></div><p>又懵了~。。。</p> <p>我只调用了offer方法 添加了一个A ,压根没调用过什么 获取元素的方法呀~<br>
不信邪了，继续看 哪里调用了<code>poll()、 peek()、first()</code>。  这几个方法真的太多地方调用了。
经过漫长的查找。</p> <p>终于在调用first方法的某个地方发现了端倪！！！<br>
看这个是什么？</p> <img src="/blog/images/28-10.png" alt="mixureSecure"> <p>迭代器！  惊不惊喜、意不意外。</p> <p>什么时候会调用迭代器？ 我上面代码没有显式的调用迭代器来遍历元素。但是，但是，但是 <code>System.out.println(queue);</code>我打印了队列，会调用队列的toString。<br>
实际上会调用AbstractCollection的toString方法:</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> it <span class="token operator">=</span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token string">&quot;[]&quot;</span><span class="token punctuation">;</span>

        <span class="token class-name">StringBuilder</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token char">'['</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">E</span> e <span class="token operator">=</span> it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token keyword">this</span> <span class="token operator">?</span> <span class="token string">&quot;(this Collection)&quot;</span> <span class="token operator">:</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token char">']'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token char">','</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token char">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>里面创建迭代器的方法调用的是 ConcurrentLinkedQueue的迭代器构造方法；</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> it <span class="token operator">=</span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Itr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token class-name">Itr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">advance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 初始化时调用 advance 方法以定位第一个有效元素</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token class-name">E</span> <span class="token function">advance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    lastRet <span class="token operator">=</span> nextNode<span class="token punctuation">;</span> <span class="token comment">// 记录当前节点</span>
    <span class="token class-name">E</span> x <span class="token operator">=</span> nextItem<span class="token punctuation">;</span> <span class="token comment">// 记录当前元素</span>

    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> pred<span class="token punctuation">,</span> p<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nextNode <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果当前节点为空，从头开始遍历</span>
        p <span class="token operator">=</span> <span class="token function">first</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        pred <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 否则从当前节点的下一个节点开始遍历</span>
        pred <span class="token operator">=</span> nextNode<span class="token punctuation">;</span>
        p <span class="token operator">=</span> <span class="token function">succ</span><span class="token punctuation">(</span>nextNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果节点为空，表示遍历结束</span>
            nextNode <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            nextItem <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> x<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">E</span> item <span class="token operator">=</span> p<span class="token punctuation">.</span>item<span class="token punctuation">;</span> <span class="token comment">// 获取节点的元素</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>item <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果元素不为空，更新 nextNode 和 nextItem 并返回 x</span>
            nextNode <span class="token operator">=</span> p<span class="token punctuation">;</span>
            nextItem <span class="token operator">=</span> item<span class="token punctuation">;</span>
            <span class="token keyword">return</span> x<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 否则跳过空元素</span>
            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> next <span class="token operator">=</span> <span class="token function">succ</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取下一个节点</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                pred<span class="token punctuation">.</span><span class="token function">casNext</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 使用 CAS 操作将前驱节点的 next 指针指向下一个节点</span>
            p <span class="token operator">=</span> next<span class="token punctuation">;</span> <span class="token comment">// 更新当前节点</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><p>创建ConcurrentLinkedQueue的迭代器，会调用<code>advance</code>方法，这个方法里面会定位第一个有效元素。<br> <code>p = first();</code></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">first</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    restartFromHead<span class="token operator">:</span> <span class="token comment">// 定义一个标签，用于从头重新开始遍历</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 无限循环，直到找到第一个有效节点或队列为空</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> h <span class="token operator">=</span> head<span class="token punctuation">,</span> p <span class="token operator">=</span> h<span class="token punctuation">,</span> q<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 初始化 h 和 p 为队列的头节点</span>
            <span class="token keyword">boolean</span> hasItem <span class="token operator">=</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>item <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 检查当前节点 p 是否有元素</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>hasItem <span class="token operator">||</span> <span class="token punctuation">(</span>q <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果 p 有元素或者 p 是最后一个节点</span>
                <span class="token function">updateHead</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 更新队列的头节点</span>
                <span class="token keyword">return</span> hasItem <span class="token operator">?</span> p <span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 如果 p 有元素，返回 p，否则返回 null</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> q<span class="token punctuation">)</span> <span class="token comment">// 如果 p 自引用（即 p == p.next），重新从头遍历</span>
                <span class="token keyword">continue</span> restartFromHead<span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token comment">// 否则，移动到下一个节点</span>
                p <span class="token operator">=</span> q<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><p>最终是迭代器调用了first方法，导致head和tail被更新出现下面的这种情况：</p> <img src="/blog/images/28-11.png" alt="mixureSecure"> <h3 id="找到问题"><a href="#找到问题" class="header-anchor">#</a> 找到问题</h3> <p>终于找到问题了
原来是打印队列，导致队列创建迭代器，调用了first方法，然后把head指针设置到了新加的A节点，tail指针还是不变并且指向了自身。</p> <p>这个时候把打印队列那两行代码注释掉：
<strong>再运行一下：</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">Field</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">ConcurrentLinkedQueue</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestA</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token comment">// 创建一个新的 ConcurrentLinkedQueue</span>
        <span class="token class-name">ConcurrentLinkedQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentLinkedQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> queueClass <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;================刚初始化================&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//        System.out.println(queue);</span>
        <span class="token class-name">Field</span> head1 <span class="token operator">=</span> queueClass<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">&quot;head&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        head1<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Field</span> tail1 <span class="token operator">=</span> queueClass<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">&quot;tail&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        tail1<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Head node: &quot;</span> <span class="token operator">+</span> head1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Tail node: &quot;</span> <span class="token operator">+</span> tail1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 将元素 &quot;A&quot; 插入到队列中</span>
        queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">&quot;A&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;================插入A后================&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 打印队列</span>
<span class="token comment">//        System.out.println(queue);</span>

        <span class="token comment">// 获取队列的 Class 对象</span>
        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> aClass <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 获取 head 和 tail 字段</span>
        <span class="token class-name">Field</span> headField <span class="token operator">=</span> aClass<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">&quot;head&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Field</span> tailField <span class="token operator">=</span> aClass<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">&quot;tail&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        headField<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        tailField<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 获取 head 和 tail 的值</span>
        <span class="token class-name">Object</span> head <span class="token operator">=</span> headField<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Object</span> tail <span class="token operator">=</span> tailField<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 打印 head 和 tail 的值</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Head node: &quot;</span> <span class="token operator">+</span> head<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Tail node: &quot;</span> <span class="token operator">+</span> tail<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 获取 head 和 tail 节点的 item 和 next 字段的值</span>
        <span class="token class-name">Field</span> itemField <span class="token operator">=</span> head<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">&quot;item&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Field</span> nextField <span class="token operator">=</span> head<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">&quot;next&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        itemField<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        nextField<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Head item: &quot;</span> <span class="token operator">+</span> itemField<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&quot;Head next: &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>nextField<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token operator">+</span>nextField<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Tail item: &quot;</span> <span class="token operator">+</span> itemField<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>tail<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Tail next: &quot;</span> <span class="token operator">+</span> nextField<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>tail<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>运行结果：</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>刚初始化<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
Head node: <span class="token number">1254526270</span>
Tail node: <span class="token number">1254526270</span>
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>插入A后<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
Head node: <span class="token number">1254526270</span>
Tail node: <span class="token number">1254526270</span>
Head item: null
Head next: <span class="token number">662441761</span>
Tail item: null
Tail next: <span class="token number">662441761</span>
</code></pre></div><p>这就符合我们从源码观察到的结论了：</p> <img src="/blog/images/28-12.png" alt="mixureSecure"> <h3 id="奇怪的事情又发生了"><a href="#奇怪的事情又发生了" class="header-anchor">#</a> 奇怪的事情又发生了</h3> <p>上面问题我们已经解决了，我高兴的认为只要我不打印队列，反射获取的队列内部head和tail的状态都是对的了，的确不打印队列得到了正确的结果。</p> <p>基于此只要我不打印队列，我使用<strong>IDEA断点</strong>一定也和上面的结论一致(太天真了~)。</p> <p>结果奇怪的事情又发生了。我断点的时候发现，又出现自引用节点了。head指针设置到了新加的A节点，tail指针还是不变并且指向了自身。</p> <p>整个人瞬间又不好了。</p> <p>不过还好有上面的排查过程，导致去思考这个IDEA的断点问题没走那么多弯路。<br>
于是去查资料，IDEA断点会调用 toString吗？  结果还真是。</p> <h3 id="idea断点设置的坑"><a href="#idea断点设置的坑" class="header-anchor">#</a> IDEA断点设置的坑</h3> <p>IDEA的断点默认设置：</p> <img src="/blog/images/28-13.png" alt="mixureSecure"> <p>把IDEA的断点设置 Enable   'toString()' object view: 选项给取消勾选。<br>
再次断点<code>queue.offer(&quot;A&quot;);</code>就正常了。</p> <p>建议把上面标注的三个都取消勾选，这样debug能快些，对于集合的内部状态也能在断点的时候看到。<br>
最后断点的效果如下：</p> <img src="/blog/images/28-14.png" alt="mixureSecure"> <p>大概花了大半天时间，趟过了这个坑。(详细记录下，以供读者参考避坑)</p> <h2 id="_6、concurrentlinkedqueue的poll方法"><a href="#_6、concurrentlinkedqueue的poll方法" class="header-anchor">#</a> 6、ConcurrentLinkedQueue的<code>poll</code>方法</h2> <p>poll方法 用于从队列头部移除并返回一个元素。<br>
如果队列中存在至少一个元素，poll()方法会返回该元素并在队列中将其移除。<br>
如果队列为空则返回null。</p> <h3 id="元素在出队时的四种情况"><a href="#元素在出队时的四种情况" class="header-anchor">#</a> 元素在出队时的四种情况</h3> <ul><li>①、当p为真正头节点时(即当前节点的元素item不为空)，CAS将头节点数据设置为空，然后判断head是否为真正头节点，不是则更新头节点，然后将原来的头节点next指向它自己构建自引用节点，下面有动画演示;</li> <li>②、当p的后继节点为空时，说明队列遍历完毕，队列为空，尝试CAS将头节点修改成p;</li> <li>③、如果p的后继节点是它自己，说明有其他线程<strong>移除或者遍历了队列</strong> 构建成了自引用节点，跳出本次外部循环，重头开始遍历;</li> <li>④、其他情况继续向后遍历;</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    restartFromHead<span class="token operator">:</span> <span class="token comment">// 定义一个标签，用于从头重新开始遍历</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 无限循环，直到成功移除一个元素或确认队列为空</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> h <span class="token operator">=</span> head<span class="token punctuation">,</span> p <span class="token operator">=</span> h<span class="token punctuation">,</span> q<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 初始化 h 和 p 为队列的头节点  初始化q表示当前节点的下一个节点，此时并没有赋值</span>
            <span class="token class-name">E</span> item <span class="token operator">=</span> p<span class="token punctuation">.</span>item<span class="token punctuation">;</span> <span class="token comment">// 获取当前节点 p 的元素</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span>item <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span><span class="token function">casItem</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
                <span class="token comment">// 如果当前节点 p 有元素且成功使用 CAS 操作将其设为 null</span>
                <span class="token comment">// 成功的 CAS 操作是元素从队列中移除的线性化点</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> h<span class="token punctuation">)</span> <span class="token comment">// 如果 p 不是头节点，则尝试跳过两个节点</span>
                    <span class="token function">updateHead</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>q <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> q <span class="token operator">:</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> item<span class="token punctuation">;</span> <span class="token comment">// 返回移除的元素</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>q <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 赋值q为下一个节点</span>
                <span class="token comment">// 如果下一个节点 q 为 null，表示队列遍历完毕</span>
                <span class="token function">updateHead</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 更新头节点为 p</span>
                <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 队列为空，返回 null</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 如果 p 自引用（即 p == p.next），重新从头遍历</span>
                <span class="token keyword">continue</span> restartFromHead<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token comment">// 否则，移动到下一个节点</span>
                p <span class="token operator">=</span> q<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><p>总结下步骤：</p> <ul><li><p>①、标签 restartFromHead: 用于在检测到某个节点自引用（即 p == p.next ）的情况下，重新从队列头开始遍历。</p></li> <li><p>②、无限循环<code>for ( ; ; )</code> :  持续尝试直到成功移除一个元素或确认队列为空。</p></li> <li><p>③、内部循环 <code>for (Node&lt;E&gt; h = head, p = h, q;;)</code> :
初始化 <code>h</code> 和 <code>p</code> 为队列的头节点（head）。
<code>q</code> 用于存储 <code>p</code>的下一个节点。</p></li> <li><p>④、获取当前节点元素 <code>E item = p.item</code>:<br>
获取当前节点<code>p</code> 的元素。</p></li> <li><p>⑤、检查并移除元素 <code>if (item != null &amp;&amp; p.casItem(item, null))</code>:
如果当前节点<code>p</code> 有元素且成功使用 CAS 操作将其设为 null，则表示移除元素成功。
成功的 CAS 操作是元素从队列中移除的线性化点。</p></li> <li><p>⑥、更新头节点 <code>if (p != h) updateHead(h, ((q = p.next) != null) ? q : p)</code>:
如果<code>p</code>不是头节点，则尝试跳过两个节点更新头节点。
这是为了优化头节点，使未来的遍历更快。</p></li> <li><p>⑦、返回移除的元素 <code>return item</code>:
成功移除元素后，返回该元素。</p></li> <li><p>⑧、处理队列为空<code>else if ((q = p.next) == null)</code>:
如果 <code>p</code>是最后一个节点<code>（p.next 为 null）</code>，则更新头节点为<code>p</code>并返回 null，表示队列为空。</p></li> <li><p>⑨、处理自引用节点 <code>else if (p == q)</code>:
如果 p 自引用（即 p == p.next），则进入 continue restartFromHead 重新从头节点开始遍历。</p></li> <li><p>⑩、移动到下一个节点<code>else p = q</code>:
如果当前节点<code>p</code>没有元素且<code>p.next</code> 不为 null，则移动到下一个节点<code>p = q</code>，继续内部循环。</p></li></ul> <h3 id="poll方法中的变量"><a href="#poll方法中的变量" class="header-anchor">#</a> <code>poll</code>方法中的变量</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// h 表示队列临时的头节点，初始时指向 head。在多线程情况下，head 可能随时变化。</span>
<span class="token comment">// p 表示队列真正的头节点，初始时与 h 相同，当p节点为真正头节点时才允许删除节点。</span>
<span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> h <span class="token operator">=</span> head<span class="token punctuation">,</span> p <span class="token operator">=</span> h<span class="token punctuation">,</span> q<span class="token punctuation">;</span>

<span class="token comment">// item  表示 p 节点存储的元素。</span>
<span class="token class-name">E</span> item <span class="token operator">=</span> p<span class="token punctuation">.</span>item<span class="token punctuation">;</span>

<span class="token comment">// q 表示 p 节点的下一个节点。</span>
q <span class="token operator">=</span> p<span class="token punctuation">.</span>next
</code></pre></div><h3 id="动画演示下单线程poll出队过程"><a href="#动画演示下单线程poll出队过程" class="header-anchor">#</a> 动画演示下单线程<code>poll</code>出队过程：</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token comment">// 创建一个新的 ConcurrentLinkedQueue</span>
        <span class="token class-name">ConcurrentLinkedQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentLinkedQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">&quot;A&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">&quot;B&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">&quot;C&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">&quot;D&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>A、B、C、D添加后的状态:
把IDEA的 Enable   'toString()' object view: 设置去掉之后，断点也是一致的了，再把IDEA的 Enable alternative view for collections classes设置去掉之后，断点内集合的内容也能直接看到head和tail的状态了。</p> <img src="/blog/images/28-15.png" alt="mixureSecure"> <img src="/blog/images/28-16.png" alt="mixureSecure"> <p>// todo  poll过程动画 做的有点瑕疵 ，后续有空 会优化一下，暂时不影响观看</p> <p>下面是动画演示：</p> <img src="/blog/images/28-17.gif" alt="mixureSecure"> <p>再继续<code>poll</code>:</p> <img src="/blog/images/28-18.gif" alt="mixureSecure"> <p>再把最后一个D也给<code>poll</code>了:</p> <img src="/blog/images/28-19.gif" alt="mixureSecure"> <h2 id="_7、分析下t-t-tail"><a href="#_7、分析下t-t-tail" class="header-anchor">#</a> 7、分析下<code>t != (t = tail)</code></h2> <p>截取部分源码如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> t <span class="token operator">=</span> tail<span class="token punctuation">,</span> p <span class="token operator">=</span> t<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 p <span class="token operator">=</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> <span class="token punctuation">(</span>t <span class="token operator">=</span> tail<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> t <span class="token operator">:</span> head<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>分析下  <code>t != (t = tail))</code>这个复合表达式：<br>
可以分为两步：</p> <ul><li>①、比较操作  t !=</li> <li>②、赋值操作并返回赋的值  t=tail</li></ul> <p>这个复合操作的顺序按照代码顺序来看：</p> <ul><li>①、先读取  != 左边的t值</li> <li>②、再执行 != 右边的 (t=tail) 把最新的tail 赋值给 t  并返回tail的最新值作为 != 右边需要被比较的值<br>
(注意虽然这一步 把最新的tail赋值给了t，但是执行比较时候 != 左边的值 按照代码顺序 已经读取了旧的tail值)</li> <li>③、比较 t_旧 != t_新</li></ul> <p>在单线程条件下： 由于t=tail ，tail没有被其他线程修改过所以  最终  t_旧 != t_新  是false。</p> <p>在多线程条件下： 由于t=tail ，  tail如果被其他线程修改过，且修改为不同的值， 最终  t_旧 != t_新  就是true。</p> <p>下面代码演示了多线程情况下  <code>t_旧 != t_新</code> 结果是true的情况：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">CountDownLatch</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestA</span> <span class="token punctuation">{</span>

    <span class="token comment">// 定义一个共享变量a 使用volatile修饰保证其可见性</span>
    <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token class-name">Integer</span> a <span class="token operator">=</span> <span class="token number">256</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token comment">// 定义两个线程同步器，来控制线程的执行顺序</span>
        <span class="token class-name">CountDownLatch</span> latchT1Start <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">CountDownLatch</span> latchT1Done <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                latchT1Start<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 等待 t2 线程读取完a的值256后，再更新a的值为512</span>
                a <span class="token operator">=</span> <span class="token number">512</span><span class="token punctuation">;</span> <span class="token comment">// 修改 a 的值</span>
                latchT1Done<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 通知 t2 线程 t1 线程已修改 a 当前a的最新值是512</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">&quot;t1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token class-name">Integer</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">// 读取 a 的初始值 256</span>
                latchT1Start<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 通知 t1 线程可以继续执行</span>
                latchT1Done<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 等待 t1 线程修改 a的值为512后 再继续向下执行</span>
                <span class="token comment">// 重新读取 a 的最值 并和a的旧值比较</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">!=</span> <span class="token punctuation">(</span>b <span class="token operator">=</span> a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;其他线程修改了a，a的最新值是：&quot;</span> <span class="token operator">+</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;a的值没有被修改过！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>

            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">&quot;t2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><p>执行结果：</p> <div class="language-shell extra-class"><pre class="language-shell"><code>其他线程修改了a，a的最新值是：512
</code></pre></div><p>我对此的分析也是建立在，查一些网上资料和自己对于Java的理解基础上总结而来， != 在java中是个 原子操作，但是并不意味着 != 左右两边的共享变量不会被其他线程修改，只是 != 这个原子操作不会被其他线程打断而已。 所以我分析 <code>t != (t = tail)</code> 就直接按照 单线程的代码执行顺序，并结合 volatile 共享变量的可见性去分析得到的这个总结性的结论。  如果有不同看法的读者，欢迎分享自己的看法。</p> <h2 id="_8、多线程下的offer和poll方法"><a href="#_8、多线程下的offer和poll方法" class="header-anchor">#</a> 8、多线程下的<code>offer</code>和<code>poll</code>方法</h2> <p>单线程下,只要把IDEA的断点选项设置好，断点走一遍还是比较好理解的。<br>
在多线程并发的条件下，ConcurrentLinkedQueue无锁的设计，加上并发的加持，会让程序变得不太好理解。</p> <h3 id="多线程下offer-和-poll有四种情况"><a href="#多线程下offer-和-poll有四种情况" class="header-anchor">#</a> 多线程下<code>offer</code>  和 <code>poll</code>有四种情况</h3> <ul><li>①、线程t1执行offer的过程中，其他线程同时也在<code>offer</code></li> <li>②、线程t1执行offer的过程中，其他线程同时在<code>poll</code></li> <li>③、线程t1执行<code>poll</code>的过程中，其他线程同时也在<code>poll</code></li> <li>④、线程t1执行<code>poll</code>的过程中，其他线程同时在<code>offer</code></li></ul> <h3 id="利用idea断点演示多线程下的offer"><a href="#利用idea断点演示多线程下的offer" class="header-anchor">#</a> 利用IDEA断点演示多线程下的<code>offer</code></h3> <p>代码如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">ConcurrentLinkedQueue</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestA</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token class-name">ConcurrentLinkedQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentLinkedQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">&quot;A&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">&quot;t1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


        <span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">&quot;B&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">&quot;t2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;运行结束~&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>断点前设置下IDEA<br>
断点前设置下IDEA<br>
断点前设置下IDEA
重要的事情说三遍~</p> <img src="/blog/images/28-20.png" alt="mixureSecure"> <p>在offer方法的源码处打上条件断点：</p> <img src="/blog/images/28-21.png" alt="mixureSecure"> <p>断点条件为，鼠标右键点击断点即可设置：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">&quot;t1&quot;</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">&quot;t2&quot;</span><span class="token punctuation">)</span> 
</code></pre></div><p>这样就可以控制t1、t2线程的执行顺序来达到我们想要的条件了。</p> <p>下面只演示一个简单的CAS失败的情况。</p> <p>t1线程添加A元素，先让t1线程走到下面这个位置。<br>
即t1已经判断了当前队列的尾节点的下一个节点为空，走到了casNext方法准备插入A。</p> <img src="/blog/images/28-22.png" alt="mixureSecure"> <p>此时切换t2线程运行，让t2线程casNext执行完毕并返回true。</p> <img src="/blog/images/28-23.png" alt="mixureSecure"> <img src="/blog/images/28-24.png" alt="mixureSecure"> <p>再继续执行t1，由于此时t1，casNext期望值是null，但是计算得出值为<code>B!=null</code>（因为t2线程已经插入了B），所以t1会CAS失败。</p> <img src="/blog/images/28-25.png" alt="mixureSecure"> <p>此时队列状态为：</p> <img src="/blog/images/28-26.png" alt="mixureSecure"> <p>t1线程继续往下走  ，第二次循环<br>
此时q=p.next=B节点<br>
p!=q<br>
走到<code>p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</code><br>
由于 <code>(p != t &amp;&amp; t != (t = tail))</code> ，tail指针并没没修改，所以计算得到是false。<br>
p=q, 也就是p指向了B节点</p> <img src="/blog/images/28-27.png" alt="mixureSecure"> <p>这个地方其实也可以再加一个线程，去添加C节点，导致tail指针改变的情况，这里就不演示了。可以自己去试下。</p> <p>t1线程继续下次循环<br>
这次q=p.next=null了 进入了casNext方法，并且预期值 <code>null==null</code>,成功添加A节点。</p> <img src="/blog/images/28-28.png" alt="mixureSecure"> <p>这里 再判断 <code>p != t</code>  结果true，表示这是第二次CAS成功了， 需要尝试CAS更新尾节点。<br> <code>casTail(t, newNode);</code> 这个地方也可以再搞个线程，让本次cas失败。这里也不演示了。直接让casTail成功。  返回true。</p> <p>再看下此时队列的元素和head、tail</p> <img src="/blog/images/28-29.png" alt="mixureSecure"> <p>符合正确的预期结果：</p> <img src="/blog/images/28-30.png" alt="mixureSecure"> <p>上面只是演示了最简单的一种多线程offer的情况，可以看到CAS失败之后t1线程又循环了2次，成功添加了元素。并且保证了数据的一致性。没有出现数据丢失或者覆盖的情况。最重要的是整个过程没有加锁。<br>
其他更复杂的情况，还是建议多debug瞅瞅。</p> <h2 id="_9、为什么每两次入队或出队操作才更新一次head或tail"><a href="#_9、为什么每两次入队或出队操作才更新一次head或tail" class="header-anchor">#</a> 9、为什么每两次入队或出队操作才更新一次<code>head或tail</code></h2> <h3 id="hops"><a href="#hops" class="header-anchor">#</a> HOPS</h3> <p>HOPS 设计（Hop-by-hop Operations Performed Sequentially）是一种优化策略，用于减少高频次的 CAS（Compare-And-Swap）操作，从而降低处理器缓存一致性流量的开销，提高队列操作的性能。</p> <p>HOPS 设计的主要思想<br>
HOPS 的主要思想是通过跳跃节点来减少每次操作中对 head 和 tail 指针进行 CAS 更新的频率。<br>
具体来说，就是在更新 head 或 tail 指针时，尽量一次跳过多个节点，而不是每处理一个节点就更新指针。(ConcurrentLinkedQueue中是每处理2个节点更新一下指针)。</p> <p>这对应的源码如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> t<span class="token punctuation">)</span> <span class="token comment">// hop two nodes at a time</span>
<span class="token function">casTail</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> newNode<span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre></div><div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> h<span class="token punctuation">)</span> <span class="token comment">// hop two nodes at a time</span>
<span class="token function">updateHead</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>q <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> q <span class="token operator">:</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>hop two nodes at a time：一次跳过两个节点。</p> <p>其实JUC里面的工具，包括并发集合，线程同步器等。源码中又许多奇奇怪怪的操作，我们只要抓住2个本质就好了。<br>
①、线程安全是前提
②、在满足①的前提下，一切为性能服务。</p> <p>所以每两次入队或出队操作才更新一次<code>head或tail</code>是为了提高并发条件下的队列入队或者出队的性能。</p> <h3 id="具体体现在以下方面"><a href="#具体体现在以下方面" class="header-anchor">#</a> 具体体现在以下方面：</h3> <ul><li>①、减少CAS操作的频率
CAS操作比较昂贵，因为它需要进行内存屏障操作以确保内存的可见性。因此，减少CAS操作的频率可以显著提高系统的性能。</li></ul> <p>在入队操作中：<code>if (p != t) casTail(t, newNode);</code><br>
这里的逻辑是每次入队时，如果新节点的前一个节点p不等于当前的尾节点t，则执行casTail(t, newNode)，将尾节点更新为新节点。这个条件实际上确保了每两次入队操作才更新一次尾节点。</p> <img src="/blog/images/28-31.png" alt="mixureSecure"> <p>在出队操作中：<code>if (p != h) updateHead(h, ((q = p.next) != null) ? q : p);</code><br>
这里的逻辑是每次出队时，如果当前节点p不等于头节点h，则执行<code>updateHead(h, ((q = p.next) != null) ? q : p)</code>，将头节点更新为当前节点的下一个节点。这个条件实际上确保了每两次出队操作才更新一次头节点。</p> <img src="/blog/images/28-32.png" alt="mixureSecure"> <ul><li>②、提高吞吐量
通过减少对head和tail的频繁更新，可以减少多个线程之间的竞争，从而提高整个队列操作的吞吐量。在高并发场景下，这种优化尤为重要，因为过多的CAS操作会导致大量的处理器缓存一致性流量，从而降低系统性能。</li></ul> <h3 id="为什么不是三次操作一次更新"><a href="#为什么不是三次操作一次更新" class="header-anchor">#</a> 为什么不是三次操作一次更新</h3> <p>这就和 HashMap的负载因子为什么默认是0.75 这种问题类似。</p> <p>选择每两次操作更新一次head或tail，而不是每三次或更多次，是经过权衡后的结果。<br>
这样既能显著减少CAS操作的频率，提高性能，又能保持代码的简单性和执行效率。<br>
在设计并发数据结构时，找到一个合理的平衡点是至关重要的，每两次操作的策略在实际应用中表现出较好的效果。<br>
并且如果再增加操作次数，必定需要维护更多的状态和计数器来跟踪操作次数。这种复杂性可能导致代码更加难以维护和理解。</p> <h3 id="cas操作对系统整体性能的影响"><a href="#cas操作对系统整体性能的影响" class="header-anchor">#</a> CAS操作对系统整体性能的影响</h3> <p>在多处理器系统中，处理器缓存一致性是一个重要的概念，用于确保每个处理器缓存中的数据与主内存中的数据保持一致。<br>
CAS（Compare-And-Swap）操作是一种用于实现并发安全的原子操作，但它在执行时会触发缓存一致性协议，从而带来一定的性能开销。</p> <p><strong>处理器缓存一致性协议的概念：</strong>
现代多处理器系统通常具有多级缓存结构（如L1、L2、L3缓存）。<br>
每个处理器都有自己的缓存，当一个处理器对某个缓存行进行写操作时，其他处理器缓存中相同缓存行的数据可能会变得过期。<br>
为了解决这个问题，处理器使用缓存一致性协议（如MESI、MOESI）来确保所有缓存中的数据是一致的。</p> <p><strong>CAS操作对处理器缓存一致性的影响：</strong><br>
CAS操作是一种原子性操作，它会先读取某个变量的值，比较它与预期值是否相同，如果相同则更新它。这个操作需要在硬件层面确保其原子性，通常会触发缓存一致性协议。</p> <p><strong>比如以下具体的几个方面的影响：</strong>
缓存行失效：
当一个处理器执行CAS操作时，它需要锁定包含目标变量的缓存行，以确保其他处理器在操作期间不能修改该缓存行的数据。这会导致其他处理器的缓存中相同的缓存行失效。</p> <p>缓存一致性通信：<br>
为了保证一致性，处理器之间需要通信以传播缓存行的状态变化。这种通信会带来一定的延迟和额外的带宽开销。</p> <p>内存屏障：
CAS操作会引入内存屏障（memory barrier），确保在操作前后的内存操作不会被重排序。这种屏障会影响处理器的指令流水线，降低执行效率。</p> <p><strong>举个简单的例子说明CAS操作带来的性能开销：</strong><br>
假设有个多核处理器，内核A和内核B，它们都有各自的缓存，并且它们都缓存了某个变量X的值：</p> <p>内核A执行CAS操作，尝试更新变量X。<br>
内核A需要确保在操作期间变量X的缓存行是独占的。<br>
内核A通过缓存一致性协议通知内核B，使内核B缓存中的X失效。
内核A完成CAS操作，更新变量X。
内核B下一次访问X时，发现其缓存中的X已失效，需要从主内存中重新读取X。
这种缓存行失效和一致性通信会带来额外的性能开销，特别是在高并发环境下，处理器的多个内核频繁进行CAS操作时，这种开销会显著增加，导致系统整体性能下降。</p> <p>所以ConcurrentLinkedQueue中的优化，通过每两次操作才更新一次head或tail，  可以显著减少CAS操作的频率，从而：<br>
减少缓存一致性流量：减少缓存行失效和内存屏障带来的开销。
提高性能：提高处理器缓存的利用率和整体系统性能。</p> <h2 id="_10、初始化节点-自引用节点的用处"><a href="#_10、初始化节点-自引用节点的用处" class="header-anchor">#</a> 10、初始化节点，自引用节点的用处</h2> <p>初始化的head和tail节点
初始状态
在创建ConcurrentLinkedQueue实例时，会初始化一个空节点作为head和tail：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ConcurrentLinkedQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    head <span class="token operator">=</span> tail <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个空节点（dummy node）的item为null，并且头指针和尾指针都指向它。</p> <p>作用</p> <ul><li>①、简化逻辑：<br>
初始化一个空节点可以简化入队和出队操作的逻辑。无论队列是否为空，头节点和尾节点始终存在，这避免了在操作时检查队列是否为空的特殊情况。</li> <li>②、确保一致性：<br>
通过始终保持一个有效的头节点和尾节点，可以确保在多线程环境中进行并发操作时，头指针和尾指针的引用始终有效，从而保证操作的线程安全性。</li></ul> <p>自引用节点：<br>
在ConcurrentLinkedQueue的操作中，有时会出现自引用节点（即一个节点的next指向它自己）。<br>
这是通过设置节点的next指针为自身来实现的，对应源码：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> p <span class="token operator">&amp;&amp;</span> <span class="token function">casHead</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">)</span>
            h<span class="token punctuation">.</span><span class="token function">lazySetNext</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>作用</p> <ul><li>①、标记删除：<br>
自引用节点通常用作逻辑删除标记。这种标记方式使得其他线程可以识别并跳过这些节点，避免误用。</li> <li>②、垃圾回收：<br>
通过有效管理队列中的节点状态和引用关系，自引用节点间接地减少了内存泄漏，并帮助垃圾回收器识别和回收无效节点。</li></ul> <h2 id="_11、总结"><a href="#_11、总结" class="header-anchor">#</a> 11、总结</h2> <p>ConcurrentLinkedQueue 是 Java 提供的一个无界、非阻塞、线程安全、高性能的队列，基于Michael &amp; Scott 队列算法(一种无锁算法)实现。<br>
它适用于高并发环境下的多线程访问，广泛应用于需要高效、线程安全队列的场景。</p> <p>ConcurrentLinkedQueue 的设计目标：</p> <ul><li>①、线程安全</li> <li>②、保证线程安全的前提下提高性能</li></ul> <p>主要有以下几个特点：<br>
初始化的 head 和 tail 即 空节点（dummy node）<br>
自引用节点<br>
CAS操作<br>
头尾指针的延迟更新</p></div></section> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/blog/java-collection/十二、DelayQueue详解.html" class="prev">
          十二、DelayQueue详解
        </a></span> <span class="next"><a href="/blog/java-concurrent/一、Java并发编程基础知识点.html">
          一、Java并发编程基础知识点
        </a></span></p></div> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-b57cc07c data-v-7dd95ae2><li class="level-2" data-v-b57cc07c><a href="/blog/java-collection/%E5%8D%81%E4%B8%89%E3%80%81ConcurrentLinkedQueue%E8%AF%A6%E8%A7%A3.html#_1、concurrentlinkedqueue简介" class="sidebar-link reco-side-_1、concurrentlinkedqueue简介" data-v-b57cc07c>1、ConcurrentLinkedQueue简介</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/java-collection/%E5%8D%81%E4%B8%89%E3%80%81ConcurrentLinkedQueue%E8%AF%A6%E8%A7%A3.html#_2、concurrentlinkedqueue继承体系" class="sidebar-link reco-side-_2、concurrentlinkedqueue继承体系" data-v-b57cc07c>2、ConcurrentLinkedQueue继承体系</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/java-collection/%E5%8D%81%E4%B8%89%E3%80%81ConcurrentLinkedQueue%E8%AF%A6%E8%A7%A3.html#_3、concurrentlinkedqueue的构造函数" class="sidebar-link reco-side-_3、concurrentlinkedqueue的构造函数" data-v-b57cc07c>3、ConcurrentLinkedQueue的构造函数</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/java-collection/%E5%8D%81%E4%B8%89%E3%80%81ConcurrentLinkedQueue%E8%AF%A6%E8%A7%A3.html#_4、concurrentlinkedqueue的数据结构" class="sidebar-link reco-side-_4、concurrentlinkedqueue的数据结构" data-v-b57cc07c>4、ConcurrentLinkedQueue的数据结构</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E5%8D%81%E4%B8%89%E3%80%81ConcurrentLinkedQueue%E8%AF%A6%E8%A7%A3.html#concurrentlinkedqueue类的属性注释" class="sidebar-link reco-side-concurrentlinkedqueue类的属性注释" data-v-b57cc07c>ConcurrentLinkedQueue类的属性注释</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E5%8D%81%E4%B8%89%E3%80%81ConcurrentLinkedQueue%E8%AF%A6%E8%A7%A3.html#concurrentlinkedqueue真正存储元素的类node-e" class="sidebar-link reco-side-concurrentlinkedqueue真正存储元素的类node-e" data-v-b57cc07c>ConcurrentLinkedQueue真正存储元素的类Node&lt;E&gt;</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E5%8D%81%E4%B8%89%E3%80%81ConcurrentLinkedQueue%E8%AF%A6%E8%A7%A3.html#concurrentlinkedqueue数据结构图示" class="sidebar-link reco-side-concurrentlinkedqueue数据结构图示" data-v-b57cc07c>ConcurrentLinkedQueue数据结构图示</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/java-collection/%E5%8D%81%E4%B8%89%E3%80%81ConcurrentLinkedQueue%E8%AF%A6%E8%A7%A3.html#_5、concurrentlinkedqueue的offer方法" class="sidebar-link reco-side-_5、concurrentlinkedqueue的offer方法" data-v-b57cc07c>5、ConcurrentLinkedQueue的offer方法</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E5%8D%81%E4%B8%89%E3%80%81ConcurrentLinkedQueue%E8%AF%A6%E8%A7%A3.html#元素在入队时的三种情况" class="sidebar-link reco-side-元素在入队时的三种情况" data-v-b57cc07c>元素在入队时的三种情况</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E5%8D%81%E4%B8%89%E3%80%81ConcurrentLinkedQueue%E8%AF%A6%E8%A7%A3.html#offer方法中的变量" class="sidebar-link reco-side-offer方法中的变量" data-v-b57cc07c>offer方法中的变量</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E5%8D%81%E4%B8%89%E3%80%81ConcurrentLinkedQueue%E8%AF%A6%E8%A7%A3.html#动画演示单线程环境下offer的入队过程" class="sidebar-link reco-side-动画演示单线程环境下offer的入队过程" data-v-b57cc07c>动画演示单线程环境下offer的入队过程</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/java-collection/%E5%8D%81%E4%B8%89%E3%80%81ConcurrentLinkedQueue%E8%AF%A6%E8%A7%A3.html#注意避坑☆☆☆☆☆" class="sidebar-link reco-side-注意避坑☆☆☆☆☆" data-v-b57cc07c>注意避坑☆☆☆☆☆</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E5%8D%81%E4%B8%89%E3%80%81ConcurrentLinkedQueue%E8%AF%A6%E8%A7%A3.html#concurrentlinkedqueue断点offer方法或者打印队列的坑" class="sidebar-link reco-side-concurrentlinkedqueue断点offer方法或者打印队列的坑" data-v-b57cc07c>ConcurrentLinkedQueue断点offer方法或者打印队列的坑</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E5%8D%81%E4%B8%89%E3%80%81ConcurrentLinkedQueue%E8%AF%A6%E8%A7%A3.html#原因探究" class="sidebar-link reco-side-原因探究" data-v-b57cc07c>原因探究</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E5%8D%81%E4%B8%89%E3%80%81ConcurrentLinkedQueue%E8%AF%A6%E8%A7%A3.html#回到问题的本质" class="sidebar-link reco-side-回到问题的本质" data-v-b57cc07c>回到问题的本质</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E5%8D%81%E4%B8%89%E3%80%81ConcurrentLinkedQueue%E8%AF%A6%E8%A7%A3.html#找到问题" class="sidebar-link reco-side-找到问题" data-v-b57cc07c>找到问题</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E5%8D%81%E4%B8%89%E3%80%81ConcurrentLinkedQueue%E8%AF%A6%E8%A7%A3.html#奇怪的事情又发生了" class="sidebar-link reco-side-奇怪的事情又发生了" data-v-b57cc07c>奇怪的事情又发生了</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E5%8D%81%E4%B8%89%E3%80%81ConcurrentLinkedQueue%E8%AF%A6%E8%A7%A3.html#idea断点设置的坑" class="sidebar-link reco-side-idea断点设置的坑" data-v-b57cc07c>IDEA断点设置的坑</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/java-collection/%E5%8D%81%E4%B8%89%E3%80%81ConcurrentLinkedQueue%E8%AF%A6%E8%A7%A3.html#_6、concurrentlinkedqueue的poll方法" class="sidebar-link reco-side-_6、concurrentlinkedqueue的poll方法" data-v-b57cc07c>6、ConcurrentLinkedQueue的poll方法</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E5%8D%81%E4%B8%89%E3%80%81ConcurrentLinkedQueue%E8%AF%A6%E8%A7%A3.html#元素在出队时的四种情况" class="sidebar-link reco-side-元素在出队时的四种情况" data-v-b57cc07c>元素在出队时的四种情况</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E5%8D%81%E4%B8%89%E3%80%81ConcurrentLinkedQueue%E8%AF%A6%E8%A7%A3.html#poll方法中的变量" class="sidebar-link reco-side-poll方法中的变量" data-v-b57cc07c>poll方法中的变量</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E5%8D%81%E4%B8%89%E3%80%81ConcurrentLinkedQueue%E8%AF%A6%E8%A7%A3.html#动画演示下单线程poll出队过程" class="sidebar-link reco-side-动画演示下单线程poll出队过程" data-v-b57cc07c>动画演示下单线程poll出队过程：</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/java-collection/%E5%8D%81%E4%B8%89%E3%80%81ConcurrentLinkedQueue%E8%AF%A6%E8%A7%A3.html#_7、分析下t-t-tail" class="sidebar-link reco-side-_7、分析下t-t-tail" data-v-b57cc07c>7、分析下t != (t = tail)</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/java-collection/%E5%8D%81%E4%B8%89%E3%80%81ConcurrentLinkedQueue%E8%AF%A6%E8%A7%A3.html#_8、多线程下的offer和poll方法" class="sidebar-link reco-side-_8、多线程下的offer和poll方法" data-v-b57cc07c>8、多线程下的offer和poll方法</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E5%8D%81%E4%B8%89%E3%80%81ConcurrentLinkedQueue%E8%AF%A6%E8%A7%A3.html#多线程下offer-和-poll有四种情况" class="sidebar-link reco-side-多线程下offer-和-poll有四种情况" data-v-b57cc07c>多线程下offer  和 poll有四种情况</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E5%8D%81%E4%B8%89%E3%80%81ConcurrentLinkedQueue%E8%AF%A6%E8%A7%A3.html#利用idea断点演示多线程下的offer" class="sidebar-link reco-side-利用idea断点演示多线程下的offer" data-v-b57cc07c>利用IDEA断点演示多线程下的offer</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/java-collection/%E5%8D%81%E4%B8%89%E3%80%81ConcurrentLinkedQueue%E8%AF%A6%E8%A7%A3.html#_9、为什么每两次入队或出队操作才更新一次head或tail" class="sidebar-link reco-side-_9、为什么每两次入队或出队操作才更新一次head或tail" data-v-b57cc07c>9、为什么每两次入队或出队操作才更新一次head或tail</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E5%8D%81%E4%B8%89%E3%80%81ConcurrentLinkedQueue%E8%AF%A6%E8%A7%A3.html#hops" class="sidebar-link reco-side-hops" data-v-b57cc07c>HOPS</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E5%8D%81%E4%B8%89%E3%80%81ConcurrentLinkedQueue%E8%AF%A6%E8%A7%A3.html#具体体现在以下方面" class="sidebar-link reco-side-具体体现在以下方面" data-v-b57cc07c>具体体现在以下方面：</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E5%8D%81%E4%B8%89%E3%80%81ConcurrentLinkedQueue%E8%AF%A6%E8%A7%A3.html#为什么不是三次操作一次更新" class="sidebar-link reco-side-为什么不是三次操作一次更新" data-v-b57cc07c>为什么不是三次操作一次更新</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-collection/%E5%8D%81%E4%B8%89%E3%80%81ConcurrentLinkedQueue%E8%AF%A6%E8%A7%A3.html#cas操作对系统整体性能的影响" class="sidebar-link reco-side-cas操作对系统整体性能的影响" data-v-b57cc07c>CAS操作对系统整体性能的影响</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/java-collection/%E5%8D%81%E4%B8%89%E3%80%81ConcurrentLinkedQueue%E8%AF%A6%E8%A7%A3.html#_10、初始化节点-自引用节点的用处" class="sidebar-link reco-side-_10、初始化节点-自引用节点的用处" data-v-b57cc07c>10、初始化节点，自引用节点的用处</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/java-collection/%E5%8D%81%E4%B8%89%E3%80%81ConcurrentLinkedQueue%E8%AF%A6%E8%A7%A3.html#_11、总结" class="sidebar-link reco-side-_11、总结" data-v-b57cc07c>11、总结</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/blog/assets/js/app.c5880b14.js" defer></script><script src="/blog/assets/js/7.2f499a27.js" defer></script><script src="/blog/assets/js/2.c1d62214.js" defer></script><script src="/blog/assets/js/1.ad340df3.js" defer></script><script src="/blog/assets/js/50.d53378c7.js" defer></script>
  </body>
</html>
