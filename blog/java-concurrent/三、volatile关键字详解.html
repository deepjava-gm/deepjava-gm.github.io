<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>volatile 详解 | GM的博客</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="stylesheet" href="/blog/custom.css">
    <script src="/blog/custom.js"></script>
    <meta name="description" content="博观约取、厚积薄发。">
    
    <link rel="preload" href="/blog/assets/css/0.styles.0612dbff.css" as="style"><link rel="preload" href="/blog/assets/js/app.77fe304b.js" as="script"><link rel="preload" href="/blog/assets/js/7.ae6c34c4.js" as="script"><link rel="preload" href="/blog/assets/js/2.aafcebc4.js" as="script"><link rel="preload" href="/blog/assets/js/1.2830a972.js" as="script"><link rel="preload" href="/blog/assets/js/55.e5635d7c.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.920b7d6e.js"><link rel="prefetch" href="/blog/assets/js/11.20adb65b.js"><link rel="prefetch" href="/blog/assets/js/14.f3a08cb2.js"><link rel="prefetch" href="/blog/assets/js/15.feb3f68a.js"><link rel="prefetch" href="/blog/assets/js/16.5627e9c8.js"><link rel="prefetch" href="/blog/assets/js/17.cf799d13.js"><link rel="prefetch" href="/blog/assets/js/18.94e52d84.js"><link rel="prefetch" href="/blog/assets/js/19.e7bdbff9.js"><link rel="prefetch" href="/blog/assets/js/20.edcc8fad.js"><link rel="prefetch" href="/blog/assets/js/21.4268d6f7.js"><link rel="prefetch" href="/blog/assets/js/22.f6b8bd65.js"><link rel="prefetch" href="/blog/assets/js/23.35d678c5.js"><link rel="prefetch" href="/blog/assets/js/24.6cbe1cce.js"><link rel="prefetch" href="/blog/assets/js/25.29d310be.js"><link rel="prefetch" href="/blog/assets/js/26.692e69bd.js"><link rel="prefetch" href="/blog/assets/js/27.a396b304.js"><link rel="prefetch" href="/blog/assets/js/28.d05525df.js"><link rel="prefetch" href="/blog/assets/js/29.0156b5cc.js"><link rel="prefetch" href="/blog/assets/js/3.29479eab.js"><link rel="prefetch" href="/blog/assets/js/30.2962fbba.js"><link rel="prefetch" href="/blog/assets/js/31.39d4cb55.js"><link rel="prefetch" href="/blog/assets/js/32.746948c7.js"><link rel="prefetch" href="/blog/assets/js/33.72f5128a.js"><link rel="prefetch" href="/blog/assets/js/34.d9e34b8a.js"><link rel="prefetch" href="/blog/assets/js/35.598b443d.js"><link rel="prefetch" href="/blog/assets/js/36.71d98d02.js"><link rel="prefetch" href="/blog/assets/js/37.d91b968d.js"><link rel="prefetch" href="/blog/assets/js/38.26defef0.js"><link rel="prefetch" href="/blog/assets/js/39.e3701bb9.js"><link rel="prefetch" href="/blog/assets/js/4.0a37db01.js"><link rel="prefetch" href="/blog/assets/js/40.d28af403.js"><link rel="prefetch" href="/blog/assets/js/41.4c4e79ca.js"><link rel="prefetch" href="/blog/assets/js/42.33c0bcd1.js"><link rel="prefetch" href="/blog/assets/js/43.6a194844.js"><link rel="prefetch" href="/blog/assets/js/44.45063565.js"><link rel="prefetch" href="/blog/assets/js/45.65ed5be0.js"><link rel="prefetch" href="/blog/assets/js/46.f8015114.js"><link rel="prefetch" href="/blog/assets/js/47.67b2cefe.js"><link rel="prefetch" href="/blog/assets/js/48.da5c571a.js"><link rel="prefetch" href="/blog/assets/js/49.836d55ba.js"><link rel="prefetch" href="/blog/assets/js/5.305f3bef.js"><link rel="prefetch" href="/blog/assets/js/50.7adcf158.js"><link rel="prefetch" href="/blog/assets/js/51.05606dab.js"><link rel="prefetch" href="/blog/assets/js/52.09affb71.js"><link rel="prefetch" href="/blog/assets/js/53.9deb507e.js"><link rel="prefetch" href="/blog/assets/js/54.cf09e1f6.js"><link rel="prefetch" href="/blog/assets/js/56.4621426d.js"><link rel="prefetch" href="/blog/assets/js/57.edcd154d.js"><link rel="prefetch" href="/blog/assets/js/58.eca614ee.js"><link rel="prefetch" href="/blog/assets/js/59.4b3ba6aa.js"><link rel="prefetch" href="/blog/assets/js/6.aeeed0ef.js"><link rel="prefetch" href="/blog/assets/js/60.6aee2e03.js"><link rel="prefetch" href="/blog/assets/js/61.9b9c4ab1.js"><link rel="prefetch" href="/blog/assets/js/62.da7dc994.js"><link rel="prefetch" href="/blog/assets/js/63.27c0bb7d.js"><link rel="prefetch" href="/blog/assets/js/64.ebb40448.js"><link rel="prefetch" href="/blog/assets/js/65.9504eca3.js"><link rel="prefetch" href="/blog/assets/js/66.325c6ecd.js"><link rel="prefetch" href="/blog/assets/js/67.59614689.js"><link rel="prefetch" href="/blog/assets/js/68.f650eb7f.js"><link rel="prefetch" href="/blog/assets/js/69.acc371a4.js"><link rel="prefetch" href="/blog/assets/js/70.4e449d6d.js"><link rel="prefetch" href="/blog/assets/js/71.cebd37d1.js"><link rel="prefetch" href="/blog/assets/js/72.516e8bed.js"><link rel="prefetch" href="/blog/assets/js/73.947717e2.js"><link rel="prefetch" href="/blog/assets/js/74.24a41228.js"><link rel="prefetch" href="/blog/assets/js/75.307afa38.js"><link rel="prefetch" href="/blog/assets/js/8.821d0483.js"><link rel="prefetch" href="/blog/assets/js/9.82e18295.js"><link rel="prefetch" href="/blog/assets/js/vendors~docsearch.6e140397.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.0612dbff.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>GM的博客</h3> <p class="description" data-v-59e6cb88>博观约取、厚积薄发。</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2024
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/head.jpg" alt="GM的博客" class="logo"> <span class="site-name">GM的博客</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://deepjava-gm.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  首页
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      GM的博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/deepjava-gm" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/qq_37883866" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><!----> <!----> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>37</h3> <h6 data-v-1fad0c41>文章</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>0</h3> <h6 data-v-1fad0c41>标签</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="https://deepjava-gm.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  首页
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      GM的博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/deepjava-gm" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/qq_37883866" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/blog/" class="sidebar-heading clickable router-link-active"><span>构建自己的Java知识体系</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/" aria-current="page" class="sidebar-link">引言</a></li><li><a href="/blog/contact.html" class="sidebar-link">反馈</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/blog/javabase/一、Java基础知识" class="sidebar-heading clickable"><span>Java基础</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/blog/java-collection/一、Java集合概述" class="sidebar-heading clickable"><span>Java集合</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/blog/java-concurrent/一、Java并发编程基础知识点" class="sidebar-heading clickable open"><span>Java并发编程</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/java-concurrent/一、Java并发编程基础知识点.html" class="sidebar-link">一、Java并发编程基础知识点</a></li><li><a href="/blog/java-concurrent/二、JMM(Java内存模型)详解.html" class="sidebar-link">二、JMM(Java内存模型)详解</a></li><li><a href="/blog/java-concurrent/三、volatile关键字详解.html" class="active sidebar-link">三、volatile关键字详解</a></li><li><a href="/blog/java-concurrent/四、synchronized关键字详解.html" class="sidebar-link">四、synchronized关键字详解</a></li><li><a href="/blog/java-concurrent/五、AQS详解.html" class="sidebar-link">五、AQS详解</a></li><li><a href="/blog/java-concurrent/六、LockSupport详解.html" class="sidebar-link">六、LockSupport详解</a></li><li><a href="/blog/java-concurrent/七、JUC包下的并发工具类.html" class="sidebar-link">七、JUC包下的并发工具类</a></li><li><a href="/blog/java-concurrent/八、ThreadLocal详解.html" class="sidebar-link">八、ThreadLocal详解</a></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88></h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2024
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">volatile 详解</h1> <div data-v-8a445198><!----> <!----> <!----> <!----></div></div> <div class="theme-reco-content content__default"><h1 id="volatile-详解"><a href="#volatile-详解" class="header-anchor">#</a> volatile 详解</h1> <h2 id="_1、volatile-关键字的作用"><a href="#_1、volatile-关键字的作用" class="header-anchor">#</a> 1、volatile 关键字的作用</h2> <p>保证变量的可见性和有序性。  那原子性呢？最后再说</p> <h2 id="_2、volatile-关键字保证可见性的原理"><a href="#_2、volatile-关键字保证可见性的原理" class="header-anchor">#</a> 2、volatile 关键字保证可见性的原理</h2> <p>依赖处理器的<code>lock</code>前缀指令和处理器的缓存一致性协议。</p> <h3 id="先看个可见性问题的例子"><a href="#先看个可见性问题的例子" class="header-anchor">#</a> 先看个可见性问题的例子：</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">TimeUnit</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestA</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            i<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;循环了&quot;</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">&quot;次&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>运行结果：<br>
会出现死循环。<br>
因为共享变量<code>flag</code>没有使用 <code>volatile</code>关键字修饰，所以没办法保证<code>flag</code>变量的可见性，main线程可能无法读取到t线程对<code>flag</code>共享变量的最新修改结果,导致死循环。<br>
如果我们使用 <code>volatile</code>关键字修饰<code>flag</code>变量，则程序可以正常结束循环，并打印出循环次数。</p> <h3 id="从程序运行结果分析volatile的作用"><a href="#从程序运行结果分析volatile的作用" class="header-anchor">#</a> 从程序运行结果分析volatile的作用：</h3> <p>我们可以这么理解，当一个变量被<code>volatile</code>关键字修饰后，一个线程修改了自己工作内存中的该共享变量后，会立即被更新到主内存中，
同时其他线程的工作内存存储的该变量副本变为失效状态，当其他线程再次读取或者修改该共享变量时，会直接从主内存中读取最新的值。</p> <h3 id="从底层实现分析"><a href="#从底层实现分析" class="header-anchor">#</a> 从底层实现分析：</h3> <p>下面会涉及处理器的一些简单知识点，有这些作为铺垫更方便理解<code>volatile</code>的底层原理。</p> <h3 id="先思考在处理器-cpu-层面实现变量的可见性-有哪些方式"><a href="#先思考在处理器-cpu-层面实现变量的可见性-有哪些方式" class="header-anchor">#</a> 先思考在处理器(CPU)层面实现变量的可见性，有哪些方式？</h3> <p>主要有下面几种方式：</p> <h3 id="_1、缓存一致性协议-mesi"><a href="#_1、缓存一致性协议-mesi" class="header-anchor">#</a> ①、缓存一致性协议(MESI)</h3> <p>我们电脑上的处理器大都是多核处理器，可以使用缓存一致性协议（如 MESI 协议）来确保多个处理器核心的缓存数据一致。通过缓存行状态的管理和消息传递机制，确保一个核心对共享变量的更新可以被其他核心及时看到。</p> <p><strong>介绍下缓存行</strong><br>
缓存行（Cache Line）是 CPU 缓存中的一个基本单位，用于存储从主内存加载的数据块。缓存行的大小通常为 32 字节、64 字节或 128 字节，这取决于具体的处理器架构(大多数现代 x86-64 架构处理器，如 Intel 和 AMD 的大部分64位处理器，都使用 64 字节的缓存行大小)。</p> <p>当 CPU 需要访问内存中的某个数据时，它会将包含该数据的整个缓存行加载到缓存中。缓存行不仅包含目标数据，还包含其周围的一些数据。这种批量加载的方式有助于提高缓存命中率，因为程序中的数据访问通常具有局部性，即连续的内存地址更有可能被连续访问。</p> <p>在多核处理器中，每个核心都有自己的 L1 和 L2 缓存，并共享一个 L3 缓存。缓存一致性协议确保多个核心之间的数据一致性。例如，当一个核心修改了某个缓存行的数据时，协议会确保其他核心中相应的缓存行无效，以便它们下次访问时从主内存或共享缓存中获取最新的数据。(这就能和上面说的<code>同时其他线程的工作内存存储的该变量副本变为失效状态</code>对应起来)</p> <p><strong>L1、L2、L3三级缓存设计的作用？</strong>
L1缓存是最接近CPU核心的，具有最快的访问速度，但容量相对较小。L2缓存位于L1缓存之外，容量更大，访问速度略慢于L1，但仍比主内存快得多。L1和L2缓存都是每个核心私有的，这意味着它们只服务于其对应的核心。<br>
L3（三级）缓存则是共享的，所有核心都可以访问。L3缓存的容量比L1和L2都要大，但访问速度慢于这两者。L3缓存的存在是为了进一步减少主内存访问的需求，并充当不同核心之间的数据共享区域，特别是在多线程或多任务环境中，当多个核心可能需要访问相同数据集的情况。</p> <p><strong>再介绍下MESI 协议</strong>
MESI 协议是最常见的缓存一致性协议之一，包含四种缓存行状态：<br>
Modified（修改态）：缓存行的数据已被修改，且该数据只存在于当前缓存中，其他缓存中没有该数据。
Exclusive（独占态）：缓存行的数据是最新的，但还没有被修改，且该数据只存在于当前缓存中。
Shared（共享态）：缓存行的数据没有被修改，可以存在于多个缓存中。
Invalid（无效态）：缓存行的数据无效。
当一个核心写入一个缓存行时，会将其他核心中相同的缓存行状态设为无效（Invalid）。这样，其他核心在访问该数据时必须从主内存中重新读取最新的数据。</p> <h3 id="_2、cpu内存屏障指令"><a href="#_2、cpu内存屏障指令" class="header-anchor">#</a> ②、CPU内存屏障指令</h3> <p>先理解下Store和Load，可以把Store认为是保存或者写的含义，把Load认为是加载或者读的含义。</p> <table><thead><tr><th>内存屏障类型名称</th> <th style="text-align:left;">指令名称</th> <th style="text-align:left;">描述</th> <th style="text-align:left;">示例</th></tr></thead> <tbody><tr><td>读屏障</td> <td style="text-align:left;"><code>lfence</code></td> <td style="text-align:left;">Load Fence，防止读操作的重排序。确保在它之后的所有读操作都在它之前的读操作完成后执行。</td> <td style="text-align:left;">在读取敏感数据前，确保所有先前的读操作已完成。</td></tr> <tr><td>写屏障</td> <td style="text-align:left;"><code>sfence</code></td> <td style="text-align:left;">Store Fence，确保所有先前的写操作都已在它之前完成，并且不会被重新排序到该指令之后。</td> <td style="text-align:left;">在关键数据写入后，确保所有先前的写操作已完成并反映在内存中。</td></tr> <tr><td>全屏障</td> <td style="text-align:left;"><code>mfence</code></td> <td style="text-align:left;">Memory Fence，防止读/写的重排序。确保在它之后的所有读/写操作都在它之前的读/写操作完成后执行。</td> <td style="text-align:left;">在并发操作中，确保所有内存在它之前的操作按顺序执行，常用于多线程同步。</td></tr></tbody></table> <p>在 Java 中，<code>volatile</code> 关键字会在读和写操作前后插入相应的内存屏障(JVM层面实现和上面三个指令没啥关系)，以确保内存操作的顺序和可见性(稍后会再详细分析)。</p> <h3 id="_3、带lock-前缀的指令"><a href="#_3、带lock-前缀的指令" class="header-anchor">#</a> ③、带lock 前缀的指令</h3> <p>处理器提供的 lock 前缀可以用于一些指令(比如 add)，确保这些指令在多处理器系统中的原子性和可见性。</p> <p>我们在JIT编译器编译后的汇编代码中可以找到这种带 lock 前缀的指令。</p> <p><a href="https://chriswhocodes.com/hsdis/" target="_blank" rel="noopener noreferrer">先下载hsdis工具，下载地址。https://chriswhocodes.com/hsdis/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a><br>
我是Window 64位系统就下载 红框里这个</p> <img src="/blog/images/31-1.png" alt="mixureSecure"> <p>IDEA中添加下面的JVM启动参数：<br>
参数如下</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token parameter variable">-server</span> <span class="token parameter variable">-XX:+UnlockDiagnosticVMOptions</span> <span class="token parameter variable">-XX:+PrintAssembly</span> <span class="token parameter variable">-XX:+LogCompilation</span>
</code></pre></div><p>运行代码(注意Java代码中变量flag加了volatile)， 在IDEA的日志打印界面看到，JVM打印出由即时编译器（JIT Compiler）生成的本地机器码（assembly code）。我运行Java程序的机器是64位Windows系统，所以这里生成的本地机器码是指 x86-64架构下的汇编代码。</p> <p><strong>补充小知识点：</strong> <strong>x86:</strong>
x86 是一系列基于英特尔架构（Intel Architecture，IA）的计算机芯片指令集架构的总称，最初由英特尔公司在 1978 年推出的 16 位微处理器 8086 开始。</p> <p><strong>x86-64:</strong>
x86-64，也称为 AMD64 或 x64，是一种由 AMD 设计的 64 位微处理器架构。</p> <p>下图是利用 hsdis工具，配合JVM启动命令来打印的JIT编译器编译后的本地机器码（assembly code）。</p> <img src="/blog/images/31-2.png" alt="mixureSecure"> <p>可以看到这里面就有用到lock前缀的汇编指令。<br>
这里先对 <code>lock addl $0x0,(%rsp)</code>留个印象，后面会讲到这个指令。</p> <h3 id="_4、总线锁定"><a href="#_4、总线锁定" class="header-anchor">#</a> ④、总线锁定</h3> <p>总线锁定是一种通过锁定系统总线来确保内存操作原子性的技术。当一个处理器执行一个涉及总线锁定的操作时，其他处理器无法访问内存。这种方法效率较低，因为它会阻止其他处理器的全部访问内存的操作。
总线锁定通常用于需要高度同步的场合，例如在执行复杂的内存事务或硬件初始化过程中，但它可能导致显著的性能下降，尤其是在高并发的多处理器系统中。</p> <h3 id="区分jvm实现的内存屏障方法和cpu的内存屏障指令"><a href="#区分jvm实现的内存屏障方法和cpu的内存屏障指令" class="header-anchor">#</a> 区分JVM实现的内存屏障方法和CPU的内存屏障指令</h3> <p>我们需要先明确一点，无论使用什么编译型的编程语言，最终所有的代码都是在处理器(CPU)上运行的，并且需要经过以下步骤：</p> <p>1.源代码 -&gt; 2. 编译 -&gt; 3. 汇编代码 -&gt; 4. 二进制机器码 -&gt; 5. 处理器执行
每一步都是将代码转换为更接近处理器能够直接理解和执行的形式，最终实现程序的功能。</p> <p>JVM内存屏障方法依赖于CPU的内存屏障指令来最终实现底层的内存操作顺序控制和可见性保证。</p> <h3 id="jvm内存屏障方法的实现"><a href="#jvm内存屏障方法的实现" class="header-anchor">#</a> JVM内存屏障方法的实现</h3> <p>先下载OpenJDK的jdk8u版本的  hotspot vm 源码看一下：
(亲自去找一下JVM对于内存屏障的实现源码，方便下面区分JVM层面和CPU指令层面的内存屏障)<br> <a href="https://hg.openjdk.org/jdk8u/jdk8u/hotspot/archive/tip.zip" target="_blank" rel="noopener noreferrer">OpenJDK的jdk8u版本的 hotspot源码下载地址：https://hg.openjdk.org/jdk8u/jdk8u/hotspot/archive/tip.zip<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>
可以直接使用IDEA打开去查看源码。<br>
我这里为了和自己电脑的CPU架构对应起来，直接去看的windows_x86 的 <code>orderAccess_windows_x86.inline.hpp</code>文件，因为我是用Windows系统运行的上面Java代码。</p> <p><strong>C++小知识点：</strong><br>
.hpp 和 .cpp 是C++编程中常见的文件扩展名，它们分别代表了头文件（Header File）和源文件（Source File）。</p> <p><strong>.hpp</strong>：头文件通常包含类的声明、函数原型、常量和宏定义等。这些文件被其他源文件通过 #include 指令引用，使得在编译时可以访问其中定义的类型和函数。使用头文件可以避免代码重复，并且方便在多个地方共享相同的代码定义。</p> <p><strong>.cpp</strong>：源文件包含了具体的函数实现和代码逻辑，并可以引入.hpp文件。
例如：unsafe.cpp 就引入了  <code>orderAccess_windows_x86.inline.hpp</code></p> <img src="/blog/images/31-3.png" alt="mixureSecure"> <p>我们看下 <code>orderAccess_windows_x86.inline.hpp</code>里面对于内存屏障的实现：</p> <img src="/blog/images/31-4.png" alt="mixureSecure"> <p>可以看到源码中有这么几行：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token class-name">OrderAccess</span><span class="token double-colon punctuation">::</span><span class="token function">loadload</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token punctuation">{</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token class-name">OrderAccess</span><span class="token double-colon punctuation">::</span><span class="token function">storestore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token class-name">OrderAccess</span><span class="token double-colon punctuation">::</span><span class="token function">loadstore</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token class-name">OrderAccess</span><span class="token double-colon punctuation">::</span><span class="token function">storeload</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span> <span class="token function">fence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
</code></pre></div><p>稍微解释下源码的含义：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>    <span class="token comment">// acquire() 方法在非 AMD64 平台上插入一个对 esp 的读操作，</span>
    <span class="token comment">// 以阻止编译器和 CPU 在其前后的内存读操作之间进行重排序。(具体是怎么防止编译器重排序的还不太清楚)</span>
    <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">AMD64</span></span>
        __asm <span class="token punctuation">{</span>
            mov eax<span class="token punctuation">,</span> dword ptr <span class="token punctuation">[</span>esp<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 读 esp 的值到 eax，创建一个读屏障。</span>
        <span class="token punctuation">}</span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">// !AMD64</span></span>
    <span class="token punctuation">}</span>

    <span class="token comment">// release() 方法通过一个C++代码的 volatile 存储操作，确保其前面的写操作</span>
    <span class="token comment">// 不会被重排序到其后面。</span>
    <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 使用 C++ 的 volatile变量 存储操作提供 release 语义。</span>
        <span class="token keyword">volatile</span> jint local_dummy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 一个无实际赋值作用的 volatile 变量存储操作，但是尤其独特的其他作用。</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// fence() 方法实现了一个全内存屏障，确保在屏障前的所有写操作完成后</span>
    <span class="token comment">// 再执行屏障后的读操作。</span>
    <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">fence</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">AMD64</span></span>
        <span class="token comment">// 对于 AMD64 平台，调用平台特定的内存屏障函数。</span>
        <span class="token function">StubRoutines_fence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
        <span class="token comment">// 对于非 AMD64 平台，如果系统是多处理器系统，</span>
        <span class="token comment">// 使用内联汇编的 lock 指令提供全内存屏障。</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>os<span class="token double-colon punctuation">::</span><span class="token function">is_MP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            __asm <span class="token punctuation">{</span>
                lock add dword ptr <span class="token punctuation">[</span>esp<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 使用 lock 前缀的 add 指令创建一个全内存屏障。</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">// AMD64</span></span>
    <span class="token punctuation">}</span>

<span class="token comment">// 函数实现解释：</span>

<span class="token comment">// acquire() 函数在非 AMD64 平台上使用内联汇编，通过读取 esp 寄存器的值</span>
<span class="token comment">// 到 eax 寄存器，防止编译器和 CPU 对前后的内存读操作进行重排序。</span>
<span class="token comment">// 这种方式通常被称为读屏障。</span>

<span class="token comment">// release() 函数通过一个C++语言的volatile变量的存储操作，防止编译器和 CPU 对前后的</span>
<span class="token comment">// 内存写操作进行重排序。这种方式通常被称为写屏障。C++的 volatile 关键字确保了</span>
<span class="token comment">// 编译器不会优化掉这个存储操作，提供了必要的顺序保证。</span>

<span class="token comment">// fence() 函数通过平台特定的方法提供全内存屏障。在 AMD64 平台上，调用</span>
<span class="token comment">// StubRoutines_fence() 函数（该函数是平台特定的内存屏障实现，从我打印的汇编指令来看x86-64平台是基于lock前缀指令实现的内存屏障）。</span>
<span class="token comment">// 在非 AMD64 平台上，如果系统是多处理器系统（os::is_MP() 返回 true），</span>
<span class="token comment">// 使用 lock 前缀的 add 指令创建一个全内存屏障，防止 CPU 对前后的内存操作进行重排序。</span>
<span class="token comment">// 全内存屏障确保屏障前的所有存储操作在屏障后的读取操作之前完成。</span>
</code></pre></div><p><strong>内联汇编：</strong>
内联汇编是一种在高级语言（如C/C++）中直接嵌入汇编代码的技术。</p> <p><strong>补充知识点 C++ 语言特性：</strong>
在 C++ 中，也有volatile 关键字，volatile告诉编译器不要对这个变量进行任何优化。<br>
对于 volatile jint local_dummy = 0;，编译器会确保实际生成一条写入指令，将 0 写入 local_dummy。<br>
尽管 local_dummy 变量本身没有实际作用，但通过对它的写操作，可以创建一个 &quot;release&quot; 屏障，防止编译器对前后的内存操作进行重排序。(这涉及到下面要说的有序性原理，现在只讨论可见性，先不展开讨论有序性)</p> <h3 id="铺垫-java语言是编译和解释共存的语言"><a href="#铺垫-java语言是编译和解释共存的语言" class="header-anchor">#</a> 铺垫：Java语言是编译和解释共存的语言</h3> <p>Java语言的执行模型开始时对源代码进行编译(这里是指使用javac进行编译生成与平台无关的.class字节码文件)，然后在运行时通过JVM解释执行字节码。但是，通过JIT(即时编译器Just-In-Time Compiler)的介入，它能够动态地将部分热点字节码转换为机器码(特定平台架构下的汇编程序)并缓存起来，从而获得接近于编译型语言的性能。</p> <p><strong>javac编译阶段：</strong>
Java源代码（.java 文件）首先被Java编译器（如 javac）编译成字节码（.class 文件）。字节码是一种中间代码，它不是针对任何特定硬件平台的机器代码，而是为Java虚拟机（JVM）设计的。这一阶段类似于编译型语言，因为代码在运行之前就被转换成了另一种形式，而不是直接解释执行（只不过这里编译后的是字节码面对的是JVM）。</p> <p><strong>解释阶段：</strong><br>
生成的字节码随后由JVM加载和执行。早期的JVM完全以解释方式执行字节码，即逐条读取字节码指令并立即执行。这种方式类似于解释型语言，因为它不需要在执行前生成最终的机器代码。</p> <p><strong>即时编译（JIT）：</strong>
随着时间的推移，JVM引入了一项重要技术——即时编译器（Just-In-Time Compiler）。JIT编译器监控程序运行，并识别出那些频繁执行的“热点”代码段。当检测到热点代码时，JIT编译器会将相应的字节码编译成本地机器代码(上面的例子就是编译成了x86-64平台架构的汇编代码)，这大大提高了执行效率。编译后的代码被缓存，以便在后续调用中直接使用，避免了重复编译。这种方式结合了编译型语言的性能优势，因为代码在运行时被优化和转换为高效的机器码(汇编)。</p> <h3 id="搞清楚内存屏障-memory-barriers-这个概念的双层含义"><a href="#搞清楚内存屏障-memory-barriers-这个概念的双层含义" class="header-anchor">#</a> 搞清楚内存屏障(Memory Barriers)这个概念的双层含义</h3> <p>通过上面的铺垫再继续分析，内存屏障(Memory Barriers)。</p> <p><strong>第一层：编译器层面</strong>
在编译阶段，编译器(对于Java来说，例如：JIT编译器)会尝试优化代码，这可能包括重新安排指令的顺序以便更高效地利用处理器资源。然而，某些操作的顺序对于程序的正确运行至关重要，特别是当涉及到多线程或多处理器环境下的共享内存访问时。</p> <p>所以我们讨论的内存屏障第一层含义有编译器屏障的意思。
编译屏障（Compiler Barrier） 是一种指示给编译器的指令，告诉它不要在屏障之前的指令与之后的指令之间进行任何优化或重排序。这样可以确保编译器生成的汇编代码保持程序员期望的执行顺序，从而维护内存操作的顺序性。</p> <p><strong>第二层：CPU执行指令层面</strong>
在硬件层面上，CPU为了提高效率，可能会采用乱序执行。这意味着处理器可能不会按照指令的原始顺序执行它们，而是基于资源可用性、依赖性分析等策略来动态调整执行顺序。此外，处理器还有可能使用缓存来进一步优化内存访问。</p> <p>所以内存屏障第二层含义有硬件内存屏障。<br>
硬件内存屏障或者叫内存栅栏（Memory Fence）或者叫CPU屏障(随便你怎么叫，只要理解这是CPU硬件层面的屏障即可)，  是CPU提供的一种特殊指令(上面第二点<code>②、CPU内存屏障指令</code> 有介绍)，它强制处理器在执行屏障后的指令前完成所有屏障前的内存操作。这确保了指令之间的内存访问顺序，并且使得所有处理器核心能够看到一致的内存状态(通过MESI协议和Snoopying机制,下面会介绍)，这对于维持并发程序的正确性非常关键。</p> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结：</h3> <p>经过上面那么多的铺垫，我们再来总结下，整体思路就非常清晰了。</p> <p>JVM中通过下面这四个函数<code>loadload() 、storestore()、loadstore()、storeload()</code> 来实现编译器屏障和 CPU指令(硬件)屏障</p> <h3 id="jvm内存屏障方法"><a href="#jvm内存屏障方法" class="header-anchor">#</a> JVM内存屏障方法</h3> <table><thead><tr><th>函数</th> <th style="text-align:left;">作用</th> <th style="text-align:left;">备注</th></tr></thead> <tbody><tr><td><code>loadload()</code></td> <td style="text-align:left;">确保后续的读操作不会被重排序到前面的读操作之前</td> <td style="text-align:left;">调用 <code>acquire()</code> 实现</td></tr> <tr><td><code>storestore()</code></td> <td style="text-align:left;">确保后续的写操作不会被重排序到前面的写操作之前</td> <td style="text-align:left;">调用 <code>release()</code> 实现</td></tr> <tr><td><code>loadstore()</code></td> <td style="text-align:left;">确保后续的写操作不会被重排序到前面的读操作之前</td> <td style="text-align:left;">调用 <code>acquire()</code> 实现</td></tr> <tr><td><code>storeload()</code></td> <td style="text-align:left;">确保后续的读操作不会被重排序到前面的写操作之前，并保证内存屏障</td> <td style="text-align:left;">调用 <code>fence()</code> 实现</td></tr></tbody></table> <p>我们暂时不讨论有序性。 对于可见性主要看上面对于 <code>storeload()</code>源码的分析。</p> <h3 id="cpu内存屏障指令"><a href="#cpu内存屏障指令" class="header-anchor">#</a> CPU内存屏障指令</h3> <p>上面已经介绍过了，这里拿过来方便阅读：<br>
先理解下Store和Load，可以把Store认为是保存或者写的含义，把Load认为是加载或者读的含义。</p> <table><thead><tr><th>内存屏障类型名称</th> <th>指令名称</th> <th style="text-align:left;">描述</th> <th style="text-align:left;">示例</th></tr></thead> <tbody><tr><td>读屏障</td> <td><code>lfence</code></td> <td style="text-align:left;">Load Fence，防止读操作的重排序。确保在它之后的所有读操作都在它之前的读操作完成后执行。</td> <td style="text-align:left;">读敏感数据前确保所有先前的读操作已完成。</td></tr> <tr><td>写屏障</td> <td><code>sfence</code></td> <td style="text-align:left;">Store Fence，防止写操作的重排序。确保在它之后的所有写入数据后确保所有先前的写操作已完成。</td> <td style="text-align:left;">所有先前的写操作都已在它之前完成。</td></tr> <tr><td>全屏障</td> <td><code>mfence</code></td> <td style="text-align:left;">Memory Fence，防止读/写的重排序。确保在它之后的所有读/写操作都在它之前的读/写操作完成后执行。</td> <td style="text-align:left;">确保所有内存在它之前的操作顺序。</td></tr></tbody></table> <p>实现CPU内存屏障指令的效果还有一个特殊的方式，那就是 前面提到的 <code>lock</code> 前缀指令。</p> <p>JVM的4个内存屏障方法<code>loadload() 、storestore()、loadstore()、storeload()</code> , 并不是单独作用于编译器的指令确保编译器生成的代码保持程序员期望的执行顺序。这四个方法同样能够确保硬件层面上CPU指令之间的内存访问顺序。(这几个方法如何确保编译器有序性的底层机制还是不太清楚，可能需要再研究研究JIT编译器的细节，这里就不细说了，因为我不太了解JIT)</p> <p>在上面知识铺垫的过程中，通过查看汇编代码和JVM的源码发现 JVM在处理 <code>volatile</code> 关键字的多线程写，最终生成的汇编代码是通过 <code>lock</code>前缀指令来实现的。
对应JVM源码 中<code>storeload()</code>方法 ,对应的汇编代码指令 <code>lock addl $0x0,(%rsp)</code> 。</p> <p><strong><code>lock addl $0x0,(%rsp)</code>指令的作用：</strong><br>
这条指令在 x86-64 架构的处理器中，虽然从表面上看，addl $0x0, (%rsp)只是将0加到%rsp指向的内存位置，并不会改变内存中的值，但由于addl操作涉及写入内存，所以这个操作仍然会触发内存访问和缓存一致性操作。 同时 lock 前缀确保了在多处理器系统中，当一个处理器正在执行这个指令时，其他处理器不能访问被锁定的内存位置(最小粒度锁的是缓存行)，从而保证了操作的原子性。<br>
并且CPU还会利用缓存一致性协议和Snoopying(嗅探)机制来实现缓存数据的一致性。</p> <p><strong>这种<code>lock</code>前缀指令用法常见于以下几种场景：</strong>
内存屏障（Memory Barrier）：确保在此指令之前的所有内存读写操作在所有处理器看来已经完成。相当于一个全局的内存屏障。（涉及有序性后面再说）<br>
刷新缓存：迫使处理器刷新其缓存，确保其他处理器看到最新的数据。(就是现在说的可见性)<br>
实现锁机制：在一些低级别的同步原语实现中，用于确保内存访问的原子性。（涉及到原子性后面再说）</p> <p>那为什么不用 <code>lfence、sfence、mfence</code>指令呢？<br>
想一想，可能是因为 <code>lock</code> 前缀指令在提供必要的内存屏障（防止重排序）和实现缓存一致性方面(可见性)具有一些独特的优势。（经典废话文学。。。哈哈）</p> <h3 id="lock-前缀指令的优势"><a href="#lock-前缀指令的优势" class="header-anchor">#</a> lock 前缀指令的优势</h3> <p><code>lock</code>前缀不是一种内存屏障，但它能完成类似内存屏障的功能。</p> <p><strong>统一的全内存屏障：</strong><br>
lock 前缀指令提供了一个统一的全内存屏障，既可以防止读操作和写操作的重排序，又能确保缓存一致性。
例如，<code>lock add dword ptr [esp], 0</code> 既会阻止指令重排序，又会确保所有处理器缓存中对于相应内存位置的修改是可见的。</p> <p><strong>缓存一致性：</strong><br> <code>lock</code> 前缀指令通过使用<strong>总线锁定</strong>或<strong>缓存锁定</strong>来确保在多处理器系统中缓存的一致性。这点需要再展开讲一下。</p> <p><strong>总线锁定</strong>： 在比较老的处理器中，或者当内存区域不在缓存中时，<code>lock</code> 前缀会触发总线锁定。此时，处理器通过拉起其 #LOCK 引脚电位来锁定总线，确保在指令执行期间其他处理器无法访问这段内存。但是这种方式会导致其他处理器(其他的CPU内核)无法访问内存，总线利用率低，影响系统性能。</p> <p><strong>缓存锁定</strong>：从 P6 架构（P6  是英特尔于1995年推出的一种处理器架构，首个使用该架构的处理器是 Pentium Pro）开始，如果指令访问的内存区域已经存在于处理器的内部缓存(CPU Cache)中，则 lock 前缀不会引起总线锁定，而是锁定本处理器的内部缓存。缓存一致性协议（如 MESI 协议）会确保其他处理器的缓存中相应的缓存行失效（invalidate），从而保持缓存一致性。</p> <p>在现代 x86或者x86-64 架构处理器中，如 Intel Core 系列和 AMD Ryzen 系列，<code>lock</code> 前缀指令的实现如下：
<strong>Intel Core 系列：</strong><br>
在 Core 微架构（如 Nehalem、Sandy Bridge、Skylake 等）中，lock 前缀指令通过锁定缓存行（仅锁定缓存行那一小块内存区域）并利用缓存一致性协议（如 MESI）来确保原子操作。
<strong>AMD Ryzen 系列：</strong><br>
在 AMD 的 Zen 微架构中，lock 前缀指令也主要通过锁定缓存行来实现，利用缓存一致性协议（如 MOESI）来确保数据的一致性和原子性。</p> <p>关于CPU缓存锁定后的内存一致性实现机制再简单解释下：<br>
Snoopying（嗅探机制）：
Snoopying 是一种基于总线的缓存一致性维护机制，其中每个处理器的缓存控制器snoop（监视）总线上发生的内存操作，以确保缓存一致性。<br>
每个处理器的缓存控制器会监视总线上的内存请求。如果一个处理器请求访问一个内存地址，其他处理器的缓存控制器会检查其缓存是否包含该地址的最新副本，并作出相应的响应。</p> <p>Snoopying 和 MESI 一起工作：在多处理器系统中，Snoopying 机制负责监视总线上所有的内存操作。当某个处理器发出读或写请求时，其他处理器会检测到这个请求并作出响应。MESI 协议则通过定义缓存行的四种状态（修改，独占，共享，无效），管理这些响应如何进行，确保缓存行的状态转换符合一致性要求。</p> <p>举个栗子：<br>
画个动画演示下比较好理解</p> <img src="/blog/images/31-5.gif" alt="mixureSecure"> <p>最后的状态再截个图吧，防止太快了需要眨眼补帧</p> <img src="/blog/images/31-6.png" alt="mixureSecure"> <p>对于另外三个CPU内存屏障指令<code>lfence、sfence、mfence</code> 。我觉得都不如 <code>lock</code>前缀指令来的直接,并且现代处理器会利用缓存锁定的模式来提升性能。同时缓存锁定不仅仅是保证了可见性。(目前一直在讨论的可见性)
缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，所以也能够保证对锁定内存区域修改的原子性。(原子性最后再说)
<code>lock</code>前缀指令还提供了一个统一的全内存屏障，可以防止读操作和写操作的重排序。(有序性下面再说)<br>
所以<code>lock</code>前缀指令等于是个&quot;全能型选手&quot;。</p> <h3 id="最后再整体总结下volatile保证可见性的底层实现"><a href="#最后再整体总结下volatile保证可见性的底层实现" class="header-anchor">#</a> 最后再整体总结下<code>volatile</code>保证可见性的底层实现</h3> <p>当一个变量被<code>volatile</code>关键字修饰时，JVM会在适当的位置插入内存屏障指令(通过<code>loadload() 、storestore()、loadstore()、storeload()</code> 方法)，并依赖于特定的处理器指令(<code>lock</code>前缀指令)和处理器的缓存一致性协议来保证可见性。</p> <p>具体流程如下：<br> <strong>写 volatile 变量：</strong><br>
JVM插入<code>storeload()</code>屏障 (这里不讨论有序性)，<code>storeload()</code>会调用 <code>fence()</code> 向最终生成的汇编代码中插入<br> <code>lock addl $0x0,(%rsp)</code> 指令，这个指令保证volatile 变量的最新值被刷新到主内存。</p> <p><strong>更新 volatile 变量：</strong><br>
缓存一致性协议和Snoopying机制使得其他CPU核心的缓存中相应的缓存行无效 。</p> <p><strong>读 volatile 变量：</strong><br>
缓存一致性协议确保任何后续的读操作或更新操作，获取缓存中相应的缓存行无效时都从主内存中获取最新的值。</p> <h2 id="_3、volatile-关键字保证有序性的原理"><a href="#_3、volatile-关键字保证有序性的原理" class="header-anchor">#</a> 3、volatile 关键字保证有序性的原理</h2> <p>一定要把上面的知识点都看了，再来看这个。因为前面有大量的铺垫帮助理解。</p> <h3 id="volatile-关键字保证有序性的两个方面"><a href="#volatile-关键字保证有序性的两个方面" class="header-anchor">#</a> volatile 关键字保证有序性的两个方面</h3> <p>①、保证编译器生成的汇编代码的有序性<br>
编译器在生成汇编代码时，通常会进行各种优化，包括生成汇编代码的时候把指令序列重排，以提高执行效率。然而，这些优化在多线程环境中可能会导致数据不一致性。volatile关键字通过告诉编译器，对volatile变量的访问不能被优化或重排，让编译器生成程序员期望的有序代码，从而保证访问的顺序性。</p> <p>②、保证CPU执行指令的有序性
即使编译器生成了有序的汇编代码，CPU在执行这些指令时也可能进行重排，以优化执行效率。volatile关键字在一定程度上通过内存屏障来保证CPU执行指令的有序性。</p> <h3 id="先看编译器重排序规则"><a href="#先看编译器重排序规则" class="header-anchor">#</a> 先看编译器重排序规则</h3> <p>JMM针对编译器制定的volatile重排序规则：
下面表格内容来源于书籍：《并发编程的艺术》<br>
这里重新制作了一下。<br> <img src="/blog/images/31-7.png" alt="mixureSecure"></p> <p>JMM针对编译器制定的volatile重排序规则约束还是挺多的  只有第一个操作是普通读写，第二个操作也是普通读写。<br>
第一个操作是普通读写，第二个操作是volatile读。这两种情况才允许编译器重排序这两个操作。<br>
不过要明确，这两种情况也不是一定就会被编译器重排序。</p> <p>在上一篇文章<a href="https://deepjava.blog.csdn.net/article/details/140087696" target="_blank" rel="noopener noreferrer">JMM(Java内存模型)详解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>中有说过什么情况下可能发生重排序。</p> <p>JMM内存屏障插入策略，这就能接上上面提到的 <code>JVM内存屏障方法的实现</code>了。</p> <p>在每个volatile写操作的前面插入一个StoreStore屏障，对应JVM源码中的<code>storestore()</code>方法。<br>
在每个volatile写操作的后面插入一个StoreLoad屏障，对应JVM源码中的<code>storeload()</code>方法。<br>
在每个volatile读操作的后面插入一个LoadLoad屏障，对应JVM源码中的<code>loadload()</code>方法。<br>
在每个volatile读操作的后面插入一个LoadStore屏障，对应JVM源码中的<code>loadstore()</code>方法。</p> <p>把上面内容再拿下来一份：</p> <table><thead><tr><th>函数</th> <th style="text-align:left;">作用</th> <th style="text-align:left;">备注</th></tr></thead> <tbody><tr><td><code>loadload()</code></td> <td style="text-align:left;">确保后续的读操作不会被重排序到前面的读操作之前</td> <td style="text-align:left;">调用 <code>acquire()</code> 实现</td></tr> <tr><td><code>storestore()</code></td> <td style="text-align:left;">确保后续的写操作不会被重排序到前面的写操作之前</td> <td style="text-align:left;">调用 <code>release()</code> 实现</td></tr> <tr><td><code>loadstore()</code></td> <td style="text-align:left;">确保后续的写操作不会被重排序到前面的读操作之前</td> <td style="text-align:left;">调用 <code>acquire()</code> 实现</td></tr> <tr><td><code>storeload()</code></td> <td style="text-align:left;">确保后续的读操作不会被重排序到前面的写操作之前，并保证内存屏障</td> <td style="text-align:left;">调用 <code>fence()</code> 实现</td></tr></tbody></table> <p>上述内存屏障插入策略可以保证在任意的Java程序和任意的处理器平台都能得到正确的volatile作用。</p> <p>下面是插入内存屏障后生成的指令序列示意图：
原图内容来源于书籍：《并发编程的艺术》<br>
这里只是重做了一下图片。</p> <img src="/blog/images/31-8.png" alt="mixureSecure"> <p>实际上编译器可以根据具体情况省略不必要的屏障但是前提是必须保证JMM对于volatile关键字作用的定义。</p> <p>比如出现连续两个volatile写，那么编译器在生成汇编代码时，只会在第一个volatile写下面插入StoreStore屏障,在第二个volatile写后面插入StoreLoad屏障,这样能够保证JMM对于volatile关键字作用的定义，并且能够最小化插入屏障的数量来提高性能。</p> <h3 id="x86架构处理器的指令重排序规则"><a href="#x86架构处理器的指令重排序规则" class="header-anchor">#</a> x86架构处理器的指令重排序规则</h3> <p>x86处理器（这里包含了x86/x86-64）,JVM源码注释中x86-64使用的名称是AMD64实际上就是x86-64, 仅会对写-读操作做重排序。x86不会对读-读、读-写和写-写操作做重排序。<br>
所以JVM在实现<code>loadload() 、storestore()、loadstore()、storeload()</code> 方法时会针对特定处理器架构有不同的处理。<br>
这里再把上面的JVM   <code>orderAccess_windows_x86.inline.hpp</code>文件的部分源码拿下来：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token class-name">OrderAccess</span><span class="token double-colon punctuation">::</span><span class="token function">loadload</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token punctuation">{</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token class-name">OrderAccess</span><span class="token double-colon punctuation">::</span><span class="token function">storestore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token class-name">OrderAccess</span><span class="token double-colon punctuation">::</span><span class="token function">loadstore</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token class-name">OrderAccess</span><span class="token double-colon punctuation">::</span><span class="token function">storeload</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span> <span class="token function">fence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
</code></pre></div><p>稍微解释下源码的含义：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>    <span class="token comment">// acquire() 方法在非 AMD64 平台上插入一个对 esp 的读操作，</span>
    <span class="token comment">// 以阻止编译器和 CPU 在其前后的内存读操作之间进行重排序。</span>
    <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">AMD64</span></span>
        __asm <span class="token punctuation">{</span>
            mov eax<span class="token punctuation">,</span> dword ptr <span class="token punctuation">[</span>esp<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 读 esp 的值到 eax，创建一个读屏障。</span>
        <span class="token punctuation">}</span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">// !AMD64</span></span>
    <span class="token punctuation">}</span>

    <span class="token comment">// release() 方法通过一个C++代码的 volatile 存储操作，确保其前面的写操作</span>
    <span class="token comment">// 不会被重排序到其后面。</span>
    <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 使用 volatile 存储操作提供 release 语义。</span>
        <span class="token keyword">volatile</span> jint local_dummy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 一个无实际赋值作用的 volatile 变量存储操作。</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// fence() 方法实现了一个全内存屏障，确保在屏障前的所有写操作完成后</span>
    <span class="token comment">// 再执行屏障后的读操作。</span>
    <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">fence</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">AMD64</span></span>
        <span class="token comment">// 对于 AMD64 平台，调用平台特定的内存屏障函数。</span>
        <span class="token function">StubRoutines_fence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
        <span class="token comment">// 对于非 AMD64 平台，如果系统是多处理器系统，</span>
        <span class="token comment">// 使用内联汇编的 lock 指令提供全内存屏障。</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>os<span class="token double-colon punctuation">::</span><span class="token function">is_MP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            __asm <span class="token punctuation">{</span>
                lock add dword ptr <span class="token punctuation">[</span>esp<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 使用 lock 前缀的 add 指令创建一个全内存屏障。</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">// AMD64</span></span>
    <span class="token punctuation">}</span>

<span class="token comment">// 函数实现解释：</span>

<span class="token comment">// acquire() 函数在非 AMD64 平台上使用内联汇编，通过读取 esp 寄存器的值</span>
<span class="token comment">// 到 eax 寄存器，防止编译器和 CPU 对前后的内存读操作进行重排序。</span>
<span class="token comment">// 这种方式通常被称为读屏障。</span>

<span class="token comment">// release() 函数通过一个C++语言的volatile变量的存储操作，防止编译器和 CPU 对前后的</span>
<span class="token comment">// 内存写操作进行重排序。这种方式通常被称为写屏障。C++的 volatile 关键字确保了</span>
<span class="token comment">// 编译器不会优化掉这个存储操作，提供了必要的顺序保证。</span>

<span class="token comment">// fence() 函数通过平台特定的方法提供全内存屏障。在 AMD64 平台上，调用</span>
<span class="token comment">// StubRoutines_fence() 函数（该函数是平台特定的内存屏障实现）。</span>
<span class="token comment">// 在非 AMD64 平台上，如果系统是多处理器系统（os::is_MP() 返回 true），</span>
<span class="token comment">// 使用 lock 前缀的 add 指令创建一个全内存屏障，防止 CPU 对前后的内存操作进行重排序。</span>
<span class="token comment">// 全内存屏障确保屏障前的所有存储操作在屏障后的读取操作之前完成。</span>
</code></pre></div><p>可以看到，<code>loadload()和loadstore()</code>调用的是<code>acquire()</code>方法，这个方法中在ADM64平台并没做任何操作。<br>
因为ADM64(x86-64)处理器平台的 <code>读-读、读-写</code>在处理器执行指令时并不会重排序。</p> <p>处理器的重排序规则(N：表示处理器不允许两个操作重排序   Y: 表示允许两个操作重排序)
表格内容来源于书籍《并发编程的艺术》<br>
这里重新做了一下表格样式。</p> <img src="/blog/images/31-9.png" alt="mixureSecure"> <p>补充知识点：<br> <strong>编译器屏障：</strong><br>
在 C/C++ 中，常见的编译器屏障是 asm volatile (&quot;&quot; ::: &quot;memory&quot;)。这个指令告诉编译器不要对内存操作进行重排序，它不会生成实际的机器指令，但会影响编译器的优化过程。<br>
Java 中则没有直接的编译器屏障语法，但是JVM中的<code>release()</code>方法，利用C++语言的volatile变量的存储操作<code>volatile jint local_dummy = 0;</code>，防止编译器和 CPU 对前后的内存写操作进行重排序。(具体是怎么防止编译器重排序的不太清楚，没去深入研究过JIT编译器)</p> <h3 id="总结下"><a href="#总结下" class="header-anchor">#</a> 总结下：</h3> <p>volatile 关键字保证有序性的原理：<br>
JVM通过JMM（Java内存模型）规范定义volatile关键字保证有序性，主要是通过内存屏障机制(包括编译器屏障，CPU指令屏障)来确保编译器生成的汇编代码保持程序员期望的执行顺序，并且确保处理器(CPU)按照顺序执行指令。</p> <h2 id="_4、volatile无法保证原子性吗"><a href="#_4、volatile无法保证原子性吗" class="header-anchor">#</a> 4、volatile无法保证原子性吗？</h2> <h3 id="先说结论"><a href="#先说结论" class="header-anchor">#</a> 先说结论：</h3> <p>对任意单个volatile变量的读/写具有原子性，类似于<code>count++</code>这种复合操作不具有原子性。</p> <p>具体分析：
对任意单个volatile变量的读/写具有原子性：<br>
例如：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">volatile</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">// 单个volatile 读</span>
a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">// 单个volatile变量的写</span>
</code></pre></div><p>但是也有例外(64位的long型和double型变量):</p> <h3 id="知识铺垫-总线事务-这部分内容来源于书籍《并发编程的艺术》"><a href="#知识铺垫-总线事务-这部分内容来源于书籍《并发编程的艺术》" class="header-anchor">#</a> 知识铺垫：总线事务  (这部分内容来源于书籍《并发编程的艺术》)</h3> <p>在计算机中，数据通过总线在处理器和内存之间传递。每次处理器和内存之间的数据传递都是通过一系列步骤来完成的，这一系列步骤称之为总线事务（Bus Transaction）。总线事务包括读事务（Read Transaction）和写事务（WriteTransaction）。读事务从内存传送数据到处理器，写事务从处理器传送数据到内存，每个事务会读/写内存中一个或多个物理上连续的字。这里的关键是，总线会同步试图并发使用总线的事务。在一个处理器执行总线事务期间，总线会禁止其他的处理器和I/O设备执行内存的读/写。</p> <p><strong>JMM不保证对64位的long型和double型变量的写操作具有原子性。</strong><br>
在一些32位的处理器上，如果要求对64位数据的写操作具有原子性，会有比较大的开销。为了照顾这种处理器，Java语言规范鼓励但不强求JVM对64位的long型变量和double型变量的写操作具有原子性。当JVM在这种处理器上运行时，可能会把一个64位long/double型变量的写操作拆分为两个32位的写操作来执行。这两个32位的写操作可能会被分配到不同的总线事务中执行，此时对这个64位变量的写操作将不具有原子性。</p> <p>在JSR-133之前的旧内存模型中，一个64位long/double型变量的读/写操作可以被拆分为两个32位的读/写操作来执行。从JSR-133内存模型开始（即从JDK5开始），仅仅只允许把一个64位long/double型变量的写操作拆分为两个32位的写操作来执行，任意的读操作在JSR133中都必须具有原子性（即任意读操作必须要在单个读事务中执行）。通过确保读操作的原子性，JSR-133 保证了一个线程在读取 long 或 double变量时，要么看到的是完全的旧值，要么看到的是完全的新值，而不是混合的中间状态。</p> <p>目前大部分商用JVM会把 64 位数据的读写操作作为原子操作来对待，这样即使我们共享long/double型变量，也不用加volatile关键字了。</p> <h3 id="类似于count-这种复合操作不具有原子性"><a href="#类似于count-这种复合操作不具有原子性" class="header-anchor">#</a> 类似于<code>count++</code>这种复合操作不具有原子性</h3> <p>主要是因为count++是复合操作包括以下步骤：</p> <ul><li>读取count的值。</li> <li>对count加1。</li> <li>将count值写回内存。<br>
实际上已经包含了读写操作。</li></ul> <p>代码示例：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">CountDownLatch</span></span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestA</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>

        <span class="token class-name">CountDownLatch</span> startSignal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                startSignal<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    count<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">&quot;t1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                startSignal<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    count<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">&quot;t2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 让t1，t2 同时开始</span>
        startSignal<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><p>实际上IDEA也会提示，对volatile变量进行了非原子操作。</p> <img src="/blog/images/31-10.png" alt="mixureSecure"> <p>结果：   期望得到20000这个结果，但是实际上很难得到20000这个结果。</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token number">12435</span><span class="token punctuation">(</span>也可能是其他大于0且小于等于20000的整数<span class="token punctuation">)</span>
</code></pre></div><h2 id="_5、volatile怎么用"><a href="#_5、volatile怎么用" class="header-anchor">#</a> 5、volatile怎么用</h2> <h3 id="推荐用volatile的一种情况-纸上谈兵的时候"><a href="#推荐用volatile的一种情况-纸上谈兵的时候" class="header-anchor">#</a> 推荐用volatile的一种情况（纸上谈兵的时候）</h3> <p>就是如果你找工作面试的时候，有面试官问如何实现线程安全的单例模式。<br>
那么这种情况下你可以利用volatile关键字和双检锁来实现，或者用静态内部类实现。</p> <p><strong>利用volatile关键字和双检锁代码如下：</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestA</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token punctuation">{</span>
                <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 验证是否单例</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


<span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token comment">// volatile声明变量</span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span>

    <span class="token comment">// 构造函数私有化</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 双检锁</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>利用静态内部类实现：</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>

    <span class="token comment">//声明为 private 避免调用默认构造方法创建对象</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

   <span class="token comment">// 声明为 private 表明静态内部该类只能在该 Singleton 类中被访问</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SingletonHolder</span> <span class="token punctuation">{</span>
        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Singleton</span> <span class="token constant">INSTANCE</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">SingletonHolder</span><span class="token punctuation">.</span><span class="token constant">INSTANCE</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><h3 id="生产不太推荐使用volatile"><a href="#生产不太推荐使用volatile" class="header-anchor">#</a> 生产不太推荐使用volatile</h3> <p>为什么不太推荐在生产环境使用volatile来实现并发安全的程序呢，主要还是容易出错。 以空间换时间或者时间换空间这类优化是常见的，但是不会有系统能够容忍以正确性换性能的情况。所以当你没有十足的把握掌握volatile 的正确使用时，保证并发安全，还是建议使用JDK提供的其他方式，比如锁或者原子类。</p> <ul><li>①、volatile仅保证最低限度的原子操作。如果想保证原子性又不想显式加锁可以尝试使用原子类。大部分需要同步的并发操作还是推荐synchronized 、或者Lock锁，在JDK5及之后 synchronized 关键字已经被充分优化，JUC并发包中也使用了synchronized ，所以不用怀疑其性能(后面会详细介绍synchronized )。</li> <li>②、使用volatile对技术要求太高，使用不当很可能会导致程序出bug。</li></ul> <h3 id="心得"><a href="#心得" class="header-anchor">#</a> 心得：</h3> <p>写完这篇文章，断断续续花了大概一周时间。<br>
参考了很多资料，尤其是《并发编程的艺术》、《JAVA并发编程实战》这两本书，也使用了各种AI工具，最好用的还是ChatGPT4o,只不过免费版每天的提问次数有限。
还参考了一些博客下面附上部分参考的博客链接：<br>
https://javaguide.cn/java/concurrent/jmm.html<br>
https://pdai.tech/md/java/thread/java-thread-x-key-volatile.html<br>
https://javabetter.cn/thread/volatile.html</p> <p>再回头去看写的这篇文章，有点感觉这不就是东拼西凑出来的东西吗？<br>
很多内容理解的还是比较模糊，比如JVM中关于编译器屏障的一些细节，这个点我还是比较模糊的。 再比如JIT编译的 x86-64架构下的汇编代码，到底哪一条确定的指令对应着volatile变量的修改，我尝试把volatile变量修改成特殊的数字然后尝试找到具体对应的一条指令，但是没找到，我把特殊的数字转成16进制去搜索打印的汇编代码日志，也没搜到。 还有一些似懂非懂模糊不清的原理或者概念等问题。<br>
但是呢，我觉得本来打算写这个 《构建自己的Java知识体系》 一系列文章的目的，本质上是为了梳理、巩固、拓展自己的Java知识体系，很多文章虽然看起来像是东拼西凑，实际上是有自己的思考和补充理解在里面，同时会按照符合自己阅读习惯的方式来记录。<br>
有时候自认为了解或者已经掌握了某个知识点后，但当自己真正去整理的时候才会发现，自己许多的不足之处。<br>
纸上谈兵终究浅显，实际操作才能深刻理解呀~</p> <p><a href="https://deepjava-gm.github.io/" target="_blank" rel="noopener noreferrer">欢迎访问我的主页：https://deepjava-gm.github.io<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>
里面有《构建自己的Java知识体系》系列技术博客，以及对开发者非常有用的站点分享。<br>
如果github访问比较慢可以参考这篇文章加速 <a href="https://deepjava.blog.csdn.net/article/details/140143860" target="_blank" rel="noopener noreferrer">增加Github访问稳定性<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。<br>
也欢迎关注我的公众号： DeepJava</p></div></section> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/blog/java-concurrent/二、JMM(Java内存模型)详解.html" class="prev">
          二、JMM(Java内存模型)详解
        </a></span> <span class="next"><a href="/blog/java-concurrent/四、synchronized关键字详解.html">
          四、synchronized关键字详解
        </a></span></p></div> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-b57cc07c data-v-7dd95ae2><li class="level-2" data-v-b57cc07c><a href="/blog/java-concurrent/%E4%B8%89%E3%80%81volatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3.html#_1、volatile-关键字的作用" class="sidebar-link reco-side-_1、volatile-关键字的作用" data-v-b57cc07c>1、volatile 关键字的作用</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/java-concurrent/%E4%B8%89%E3%80%81volatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3.html#_2、volatile-关键字保证可见性的原理" class="sidebar-link reco-side-_2、volatile-关键字保证可见性的原理" data-v-b57cc07c>2、volatile 关键字保证可见性的原理</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E4%B8%89%E3%80%81volatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3.html#先看个可见性问题的例子" class="sidebar-link reco-side-先看个可见性问题的例子" data-v-b57cc07c>先看个可见性问题的例子：</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E4%B8%89%E3%80%81volatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3.html#从程序运行结果分析volatile的作用" class="sidebar-link reco-side-从程序运行结果分析volatile的作用" data-v-b57cc07c>从程序运行结果分析volatile的作用：</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E4%B8%89%E3%80%81volatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3.html#从底层实现分析" class="sidebar-link reco-side-从底层实现分析" data-v-b57cc07c>从底层实现分析：</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E4%B8%89%E3%80%81volatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3.html#先思考在处理器-cpu-层面实现变量的可见性-有哪些方式" class="sidebar-link reco-side-先思考在处理器-cpu-层面实现变量的可见性-有哪些方式" data-v-b57cc07c>先思考在处理器(CPU)层面实现变量的可见性，有哪些方式？</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E4%B8%89%E3%80%81volatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3.html#_1、缓存一致性协议-mesi" class="sidebar-link reco-side-_1、缓存一致性协议-mesi" data-v-b57cc07c>①、缓存一致性协议(MESI)</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E4%B8%89%E3%80%81volatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3.html#_2、cpu内存屏障指令" class="sidebar-link reco-side-_2、cpu内存屏障指令" data-v-b57cc07c>②、CPU内存屏障指令</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E4%B8%89%E3%80%81volatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3.html#_3、带lock-前缀的指令" class="sidebar-link reco-side-_3、带lock-前缀的指令" data-v-b57cc07c>③、带lock 前缀的指令</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E4%B8%89%E3%80%81volatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3.html#_4、总线锁定" class="sidebar-link reco-side-_4、总线锁定" data-v-b57cc07c>④、总线锁定</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E4%B8%89%E3%80%81volatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3.html#区分jvm实现的内存屏障方法和cpu的内存屏障指令" class="sidebar-link reco-side-区分jvm实现的内存屏障方法和cpu的内存屏障指令" data-v-b57cc07c>区分JVM实现的内存屏障方法和CPU的内存屏障指令</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E4%B8%89%E3%80%81volatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3.html#jvm内存屏障方法的实现" class="sidebar-link reco-side-jvm内存屏障方法的实现" data-v-b57cc07c>JVM内存屏障方法的实现</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E4%B8%89%E3%80%81volatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3.html#铺垫-java语言是编译和解释共存的语言" class="sidebar-link reco-side-铺垫-java语言是编译和解释共存的语言" data-v-b57cc07c>铺垫：Java语言是编译和解释共存的语言</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E4%B8%89%E3%80%81volatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3.html#搞清楚内存屏障-memory-barriers-这个概念的双层含义" class="sidebar-link reco-side-搞清楚内存屏障-memory-barriers-这个概念的双层含义" data-v-b57cc07c>搞清楚内存屏障(Memory Barriers)这个概念的双层含义</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E4%B8%89%E3%80%81volatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3.html#总结" class="sidebar-link reco-side-总结" data-v-b57cc07c>总结：</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E4%B8%89%E3%80%81volatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3.html#jvm内存屏障方法" class="sidebar-link reco-side-jvm内存屏障方法" data-v-b57cc07c>JVM内存屏障方法</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E4%B8%89%E3%80%81volatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3.html#cpu内存屏障指令" class="sidebar-link reco-side-cpu内存屏障指令" data-v-b57cc07c>CPU内存屏障指令</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E4%B8%89%E3%80%81volatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3.html#lock-前缀指令的优势" class="sidebar-link reco-side-lock-前缀指令的优势" data-v-b57cc07c>lock 前缀指令的优势</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E4%B8%89%E3%80%81volatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3.html#最后再整体总结下volatile保证可见性的底层实现" class="sidebar-link reco-side-最后再整体总结下volatile保证可见性的底层实现" data-v-b57cc07c>最后再整体总结下volatile保证可见性的底层实现</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/java-concurrent/%E4%B8%89%E3%80%81volatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3.html#_3、volatile-关键字保证有序性的原理" class="sidebar-link reco-side-_3、volatile-关键字保证有序性的原理" data-v-b57cc07c>3、volatile 关键字保证有序性的原理</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E4%B8%89%E3%80%81volatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3.html#volatile-关键字保证有序性的两个方面" class="sidebar-link reco-side-volatile-关键字保证有序性的两个方面" data-v-b57cc07c>volatile 关键字保证有序性的两个方面</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E4%B8%89%E3%80%81volatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3.html#先看编译器重排序规则" class="sidebar-link reco-side-先看编译器重排序规则" data-v-b57cc07c>先看编译器重排序规则</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E4%B8%89%E3%80%81volatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3.html#x86架构处理器的指令重排序规则" class="sidebar-link reco-side-x86架构处理器的指令重排序规则" data-v-b57cc07c>x86架构处理器的指令重排序规则</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E4%B8%89%E3%80%81volatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3.html#总结下" class="sidebar-link reco-side-总结下" data-v-b57cc07c>总结下：</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/java-concurrent/%E4%B8%89%E3%80%81volatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3.html#_4、volatile无法保证原子性吗" class="sidebar-link reco-side-_4、volatile无法保证原子性吗" data-v-b57cc07c>4、volatile无法保证原子性吗？</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E4%B8%89%E3%80%81volatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3.html#先说结论" class="sidebar-link reco-side-先说结论" data-v-b57cc07c>先说结论：</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E4%B8%89%E3%80%81volatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3.html#知识铺垫-总线事务-这部分内容来源于书籍《并发编程的艺术》" class="sidebar-link reco-side-知识铺垫-总线事务-这部分内容来源于书籍《并发编程的艺术》" data-v-b57cc07c>知识铺垫：总线事务  (这部分内容来源于书籍《并发编程的艺术》)</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E4%B8%89%E3%80%81volatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3.html#类似于count-这种复合操作不具有原子性" class="sidebar-link reco-side-类似于count-这种复合操作不具有原子性" data-v-b57cc07c>类似于count++这种复合操作不具有原子性</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/java-concurrent/%E4%B8%89%E3%80%81volatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3.html#_5、volatile怎么用" class="sidebar-link reco-side-_5、volatile怎么用" data-v-b57cc07c>5、volatile怎么用</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E4%B8%89%E3%80%81volatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3.html#推荐用volatile的一种情况-纸上谈兵的时候" class="sidebar-link reco-side-推荐用volatile的一种情况-纸上谈兵的时候" data-v-b57cc07c>推荐用volatile的一种情况（纸上谈兵的时候）</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E4%B8%89%E3%80%81volatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3.html#生产不太推荐使用volatile" class="sidebar-link reco-side-生产不太推荐使用volatile" data-v-b57cc07c>生产不太推荐使用volatile</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E4%B8%89%E3%80%81volatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3.html#心得" class="sidebar-link reco-side-心得" data-v-b57cc07c>心得：</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/blog/assets/js/app.77fe304b.js" defer></script><script src="/blog/assets/js/7.ae6c34c4.js" defer></script><script src="/blog/assets/js/2.aafcebc4.js" defer></script><script src="/blog/assets/js/1.2830a972.js" defer></script><script src="/blog/assets/js/55.e5635d7c.js" defer></script>
  </body>
</html>
