<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java线程池详解 | GM的博客</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="stylesheet" href="/blog/custom.css">
    <script src="/blog/custom.js"></script>
    <meta name="description" content="博观约取、厚积薄发。">
    
    <link rel="preload" href="/blog/assets/css/0.styles.0612dbff.css" as="style"><link rel="preload" href="/blog/assets/js/app.aa36b75b.js" as="script"><link rel="preload" href="/blog/assets/js/7.272de20f.js" as="script"><link rel="preload" href="/blog/assets/js/2.cc89bbf4.js" as="script"><link rel="preload" href="/blog/assets/js/1.fb256d2a.js" as="script"><link rel="preload" href="/blog/assets/js/64.c623834b.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.6c064207.js"><link rel="prefetch" href="/blog/assets/js/11.3e7d7892.js"><link rel="prefetch" href="/blog/assets/js/14.2a1ed16e.js"><link rel="prefetch" href="/blog/assets/js/15.c436ecdb.js"><link rel="prefetch" href="/blog/assets/js/16.5627e9c8.js"><link rel="prefetch" href="/blog/assets/js/17.cf799d13.js"><link rel="prefetch" href="/blog/assets/js/18.21f1f4b3.js"><link rel="prefetch" href="/blog/assets/js/19.c3aec7ee.js"><link rel="prefetch" href="/blog/assets/js/20.73f0a331.js"><link rel="prefetch" href="/blog/assets/js/21.108c76a9.js"><link rel="prefetch" href="/blog/assets/js/22.f6b8bd65.js"><link rel="prefetch" href="/blog/assets/js/23.331063ae.js"><link rel="prefetch" href="/blog/assets/js/24.67f51b5a.js"><link rel="prefetch" href="/blog/assets/js/25.55e00822.js"><link rel="prefetch" href="/blog/assets/js/26.692e69bd.js"><link rel="prefetch" href="/blog/assets/js/27.20ab0ec1.js"><link rel="prefetch" href="/blog/assets/js/28.99545882.js"><link rel="prefetch" href="/blog/assets/js/29.ca1f8c5d.js"><link rel="prefetch" href="/blog/assets/js/3.71f4b310.js"><link rel="prefetch" href="/blog/assets/js/30.2962fbba.js"><link rel="prefetch" href="/blog/assets/js/31.2fc639e9.js"><link rel="prefetch" href="/blog/assets/js/32.97324ada.js"><link rel="prefetch" href="/blog/assets/js/33.23619402.js"><link rel="prefetch" href="/blog/assets/js/34.d9e34b8a.js"><link rel="prefetch" href="/blog/assets/js/35.c4f7378c.js"><link rel="prefetch" href="/blog/assets/js/36.71d98d02.js"><link rel="prefetch" href="/blog/assets/js/37.d91b968d.js"><link rel="prefetch" href="/blog/assets/js/38.ed46a184.js"><link rel="prefetch" href="/blog/assets/js/39.c75715a7.js"><link rel="prefetch" href="/blog/assets/js/4.7cc749e8.js"><link rel="prefetch" href="/blog/assets/js/40.364bac1d.js"><link rel="prefetch" href="/blog/assets/js/41.22ce59c2.js"><link rel="prefetch" href="/blog/assets/js/42.ce64514c.js"><link rel="prefetch" href="/blog/assets/js/43.06b0c452.js"><link rel="prefetch" href="/blog/assets/js/44.1e64cd60.js"><link rel="prefetch" href="/blog/assets/js/45.75e011f9.js"><link rel="prefetch" href="/blog/assets/js/46.996867f3.js"><link rel="prefetch" href="/blog/assets/js/47.80c7ee73.js"><link rel="prefetch" href="/blog/assets/js/48.d4179aba.js"><link rel="prefetch" href="/blog/assets/js/49.e7c29b24.js"><link rel="prefetch" href="/blog/assets/js/5.42dc1081.js"><link rel="prefetch" href="/blog/assets/js/50.dcee16ed.js"><link rel="prefetch" href="/blog/assets/js/51.a987285d.js"><link rel="prefetch" href="/blog/assets/js/52.09affb71.js"><link rel="prefetch" href="/blog/assets/js/53.6488d9e4.js"><link rel="prefetch" href="/blog/assets/js/54.c642f707.js"><link rel="prefetch" href="/blog/assets/js/55.da85728d.js"><link rel="prefetch" href="/blog/assets/js/56.913d645b.js"><link rel="prefetch" href="/blog/assets/js/57.58b32b16.js"><link rel="prefetch" href="/blog/assets/js/58.883d3b76.js"><link rel="prefetch" href="/blog/assets/js/59.31b22d53.js"><link rel="prefetch" href="/blog/assets/js/6.b5ec739c.js"><link rel="prefetch" href="/blog/assets/js/60.32c8305c.js"><link rel="prefetch" href="/blog/assets/js/61.a33bb84d.js"><link rel="prefetch" href="/blog/assets/js/62.67670094.js"><link rel="prefetch" href="/blog/assets/js/63.2b40b104.js"><link rel="prefetch" href="/blog/assets/js/65.9bc16f13.js"><link rel="prefetch" href="/blog/assets/js/66.166ea331.js"><link rel="prefetch" href="/blog/assets/js/67.907e1ee4.js"><link rel="prefetch" href="/blog/assets/js/68.20e23ac0.js"><link rel="prefetch" href="/blog/assets/js/69.2b0c3a93.js"><link rel="prefetch" href="/blog/assets/js/70.95dbaaee.js"><link rel="prefetch" href="/blog/assets/js/71.19b33212.js"><link rel="prefetch" href="/blog/assets/js/72.a7a0893f.js"><link rel="prefetch" href="/blog/assets/js/73.2dbe546c.js"><link rel="prefetch" href="/blog/assets/js/74.e9a61875.js"><link rel="prefetch" href="/blog/assets/js/75.842d1a59.js"><link rel="prefetch" href="/blog/assets/js/76.a39915a0.js"><link rel="prefetch" href="/blog/assets/js/77.18dfad1c.js"><link rel="prefetch" href="/blog/assets/js/78.3a63a875.js"><link rel="prefetch" href="/blog/assets/js/79.048569ea.js"><link rel="prefetch" href="/blog/assets/js/8.92831dcf.js"><link rel="prefetch" href="/blog/assets/js/80.faf81bfe.js"><link rel="prefetch" href="/blog/assets/js/81.827bb5c0.js"><link rel="prefetch" href="/blog/assets/js/82.c59d3f92.js"><link rel="prefetch" href="/blog/assets/js/83.8254bd19.js"><link rel="prefetch" href="/blog/assets/js/9.bfffe90e.js"><link rel="prefetch" href="/blog/assets/js/vendors~docsearch.6e140397.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.0612dbff.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>GM的博客</h3> <p class="description" data-v-59e6cb88>博观约取、厚积薄发。</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2024
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/head.jpg" alt="GM的博客" class="logo"> <span class="site-name">GM的博客</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://deepjava-gm.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  首页
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      GM的博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/deepjava-gm" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/qq_37883866" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><!----> <!----> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>45</h3> <h6 data-v-1fad0c41>文章</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>0</h3> <h6 data-v-1fad0c41>标签</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="https://deepjava-gm.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  首页
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      GM的博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/deepjava-gm" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/qq_37883866" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/blog/" class="sidebar-heading clickable router-link-active"><span>构建自己的Java知识体系</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/" aria-current="page" class="sidebar-link">引言</a></li><li><a href="/blog/contact.html" class="sidebar-link">反馈</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/blog/javabase/一、Java基础知识" class="sidebar-heading clickable"><span>Java基础</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/blog/java-collection/一、Java集合概述" class="sidebar-heading clickable"><span>Java集合</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/blog/java-concurrent/一、Java并发编程基础知识点" class="sidebar-heading clickable open"><span>Java并发编程</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/java-concurrent/一、Java并发编程基础知识点.html" class="sidebar-link">一、Java并发编程基础知识点</a></li><li><a href="/blog/java-concurrent/二、JMM(Java内存模型)详解.html" class="sidebar-link">二、JMM(Java内存模型)详解</a></li><li><a href="/blog/java-concurrent/三、volatile关键字详解.html" class="sidebar-link">三、volatile关键字详解</a></li><li><a href="/blog/java-concurrent/四、synchronized关键字详解.html" class="sidebar-link">四、synchronized关键字详解</a></li><li><a href="/blog/java-concurrent/五、AQS详解.html" class="sidebar-link">五、AQS详解</a></li><li><a href="/blog/java-concurrent/六、LockSupport详解.html" class="sidebar-link">六、LockSupport详解</a></li><li><a href="/blog/java-concurrent/七、JUC包下的并发工具类.html" class="sidebar-link">七、JUC包下的并发工具类</a></li><li><a href="/blog/java-concurrent/八、ThreadLocal详解.html" class="sidebar-link">八、ThreadLocal详解</a></li><li><a href="/blog/java-concurrent/九、Java锁详解.html" class="sidebar-link">九、Java锁详解</a></li><li><a href="/blog/java-concurrent/十、ReentrantReadWriteLock详解.html" class="sidebar-link">十、ReentrantReadWriteLock详解</a></li><li><a href="/blog/java-concurrent/十一、StampedLock详解.html" class="sidebar-link">十一、StampedLock详解</a></li><li><a href="/blog/java-concurrent/十二、Java线程池.html" class="active sidebar-link">十二、Java线程池</a></li><li><a href="/blog/java-concurrent/十三、FutureTask详解.html" class="sidebar-link">十三、FutureTask详解</a></li><li><a href="/blog/java-concurrent/十四、CompletableFuture详解.html" class="sidebar-link">十四、CompletableFuture详解</a></li><li><a href="/blog/java-concurrent/十五、Java CAS、Unsafe类、原子类详解.html" class="sidebar-link">十五、Java CAS、Unsafe类、原子类详解</a></li><li><a href="/blog/java-concurrent/十六、final关键字详解.html" class="sidebar-link">十六、final关键字详解</a></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88></h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2024
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">Java线程池详解</h1> <div data-v-8a445198><!----> <!----> <!----> <!----></div></div> <div class="theme-reco-content content__default"><h1 id="java线程池详解"><a href="#java线程池详解" class="header-anchor">#</a> Java线程池详解</h1> <h2 id="一、java线程池简介"><a href="#一、java线程池简介" class="header-anchor">#</a> 一、Java线程池简介</h2> <p>线程池是为了提升多线程应用的性能和资源利用效率而提出的一种技术方案。它通过池化思想来管理和复用线程，避免了频繁创建和销毁线程所带来的开销。池化思想的核心在于复用已创建的资源（线程），从而提高系统的效率和响应速度。</p> <h3 id="池化思想"><a href="#池化思想" class="header-anchor">#</a> 池化思想</h3> <p>池化思想（Pooling）是一种资源管理的技术，通过维护一个预定义的资源池来提高效率和性能。其主要目标是减少资源的创建和销毁开销，同时提升资源的利用率和响应速度。池化思想的应用不仅限于线程池，还包括数据库连接池、对象池等。</p> <p><strong>池化思想的核心</strong><br> <strong>资源复用：</strong> 池化思想通过创建一个资源池，已经创建的资源可以被重复使用，从而减少了每次使用资源时的开销。例如，线程池中的线程在执行完任务后不会被销毁，而是被回收到线程池中，以备下一个任务使用。</p> <p><strong>预分配资源：</strong> 在使用池化技术时，系统通常会预先创建一定数量的资源，并将其维护在池中。这些资源可以随时被请求和使用，从而减少了动态创建资源的时间。</p> <p><strong>管理资源生命周期：</strong> 资源池负责管理资源的生命周期，包括资源的创建、分配、回收和销毁。通过有效的管理，资源池能够确保资源的高效利用，避免资源的泄漏和过度使用。</p> <p><strong>控制资源数量：</strong> 池化技术通过限制资源池中的资源数量，避免了资源的过度创建和消耗。例如，线程池中的线程数量可以设置核心线程数和最大线程数，从而控制系统中线程的总数。</p> <h3 id="池化思想的优点"><a href="#池化思想的优点" class="header-anchor">#</a> 池化思想的优点</h3> <p><strong>性能提升：</strong> 通过复用资源，减少了资源创建和销毁的开销，从而提高了系统的性能。<br> <strong>资源管理：</strong> 池化技术能够控制资源的数量和使用，避免了资源的浪费和过度消耗。<br> <strong>响应速度：</strong> 由于资源是预先创建和管理的，系统可以更快地响应资源请求，从而提高了响应速度。<br> <strong>资源限制：</strong> 通过限制资源池中的资源数量，可以防止系统资源的耗尽，提高系统的稳定性和可靠性。</p> <h2 id="二、线程池的实现原理分析"><a href="#二、线程池的实现原理分析" class="header-anchor">#</a> 二、线程池的实现原理分析</h2> <h3 id="实现线程池需要考虑哪些问题"><a href="#实现线程池需要考虑哪些问题" class="header-anchor">#</a> 实现线程池需要考虑哪些问题？</h3> <p>结合上面说的池化思想来看：<br>
①、要预分配资源就需要先创建线程，通过什么方式创建线程比较好？<br>
②、要实现资源复用就要考虑线程在执行完任务后放在哪，是让线程阻塞等待还是继续空转等待？<br>
③、要控制资源数量就要考虑如何制定一套合理高效的线程调度规则，资源池中线程的数量是设计成动态的还是固定的？<br>
④、每次提交新任务，是放入队列等待执行，还是直接使用线程执行，如果线程资源不够了怎么处理？</p> <p>带着上面几个问题我们一个一个来说。</p> <p>对于问题①，JDK中的线程池比如：<code>ThreadPoolExecutor</code>  或者 <code>ScheduledThreadPoolExecutor</code>都是使用JDK自己定义的<code>ThreadFactory</code>接口的实例来创建线程，通过<code>ThreadFactory</code>提供统一的接口，能够非常灵活的自定义自己的线程工厂来定制线程属性，方便后期对线程的管理。</p> <p>比如：<br>
实现一个最简单的线程工厂用来创建线程。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">MyThreadFactory</span> <span class="token keyword">implements</span> <span class="token class-name">ThreadFactory</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> threadNum <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 设置线程名称</span>
    <span class="token keyword">public</span> <span class="token class-name">MyThreadFactory</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Thread</span> <span class="token function">newThread</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token function">newThread</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 设置线程名称和编号</span>
        thread<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>name <span class="token operator">+</span> <span class="token string">&quot; [#&quot;</span> <span class="token operator">+</span> threadNum<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;]&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> thread<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>对于问题②、实现资源复用，<code>ThreadPoolExecutor</code> 是将线程和任务封装为<code>Worker</code>对象 ， <code>Worker</code>继承<code>AQS</code>，并利用 AQS 的功能来实现线程的阻塞和唤醒，每个 Worker 对象维护一个线程，通过调用 Worker.run 方法来执行任务。后面会详细介绍，这里先简单说明一下。</p> <p>对于问题③、制定一套合理高效的线程调度规则，那么线程池就要能实现灵活的线程配置，在<code>ThreadPoolExecutor</code>类中线程池资源数量的灵活性主要体现在以下几个方面：</p> <ul><li>核心线程数（Core Pool Size）</li> <li>最大线程数（Maximum Pool Size）</li> <li>线程存活时间（Keep-Alive Time）</li></ul> <p>对于问题④、每次提交新任务，肯定是放入阻塞队列处理更加方便灵活，要不然<code>ThreadPoolExecutor</code>可能就得在自己类的内部实现线程的调度管理了，这样很麻烦又冗余。因为JDK本身实现了一些非常有用的阻塞队列，在线程池的实现上正好能派上用场。</p> <p>如果线程资源不够了怎么处理？<br>
在线程资源不足时，线程池会根据设置的核心线程数、最大线程数和任务队列的状态来决定是否创建新线程或使用拒绝策略处理任务。</p> <h3 id="线程池的简单使用示例"><a href="#线程池的简单使用示例" class="header-anchor">#</a> 线程池的简单使用示例</h3> <p>还是拿狗吃骨头举例<br>
一共三只狗，假设每只狗吃1秒骨头，且每只狗互不影响，单线程执行的话需要3秒，多线程并发执行只要1秒多（需要线程调度所以会大于1秒）。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>atomic<span class="token punctuation">.</span></span><span class="token class-name">AtomicInteger</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestA</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ThreadPoolExecutor</span> threadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>
            <span class="token number">4</span><span class="token punctuation">,</span>                              <span class="token comment">// 核心线程数 </span>
            <span class="token number">8</span><span class="token punctuation">,</span>                          <span class="token comment">// 最大线程数</span>
            <span class="token number">0</span><span class="token punctuation">,</span>                             <span class="token comment">// 非核心线程的存活时间</span>
            <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">,</span>                           <span class="token comment">// 存活时间单位</span>
            <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token comment">// 存放任务的 阻塞队列</span>
            <span class="token keyword">new</span> <span class="token class-name">MyThreadFactory</span><span class="token punctuation">(</span><span class="token string">&quot;DogEatBones&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>   <span class="token comment">// 创建线程的 工厂 </span>
            <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>AbortPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">// 线程池的拒绝策略</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>

        <span class="token class-name">String</span> dog1 <span class="token operator">=</span> <span class="token string">&quot;秀逗&quot;</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> dog2 <span class="token operator">=</span> <span class="token string">&quot;四眼&quot;</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> dog3 <span class="token operator">=</span> <span class="token string">&quot;大黄&quot;</span><span class="token punctuation">;</span>

        <span class="token comment">// 单线程执行</span>
        <span class="token function">eat</span><span class="token punctuation">(</span>dog1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">eat</span><span class="token punctuation">(</span>dog2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">eat</span><span class="token punctuation">(</span>dog3<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;========= 单线程执行完了&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 使用线程池执行</span>
        <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> future1 <span class="token operator">=</span> threadPoolExecutor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token function">eat</span><span class="token punctuation">(</span>dog1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> future2 <span class="token operator">=</span> threadPoolExecutor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token function">eat</span><span class="token punctuation">(</span>dog2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> future3 <span class="token operator">=</span> threadPoolExecutor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token function">eat</span><span class="token punctuation">(</span>dog3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 等待每个任务执行完</span>
        future1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        future2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        future3<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;========= 线程池执行完了&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 关闭线程池</span>
        threadPoolExecutor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name <span class="token operator">+</span> <span class="token string">&quot;吃了骨头！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">MyThreadFactory</span> <span class="token keyword">implements</span> <span class="token class-name">ThreadFactory</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> threadNum <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 设置线程名称</span>
    <span class="token keyword">public</span> <span class="token class-name">MyThreadFactory</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Thread</span> <span class="token function">newThread</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 设置线程名称和编号</span>
        thread<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>name <span class="token operator">+</span> <span class="token string">&quot; [#&quot;</span> <span class="token operator">+</span> threadNum<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;]&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> thread<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>执行结果：</p> <img src="/blog/images/40-1.gif" alt="mixureSecure"> <p>这个例子能很好的体现出利用程池执行非关联异步任务的效率优势。<br>
当执行多个不相关联的耗时任务时，使用线程池的话可让多个不相关联的任务同时执行，相比于单线程顺序执行通常会有不错的效率提升。</p> <h3 id="线程池原理的简单图示"><a href="#线程池原理的简单图示" class="header-anchor">#</a> 线程池原理的简单图示</h3> <img src="/blog/images/40-2.png" alt="mixureSecure"> <h2 id="三、executor详解"><a href="#三、executor详解" class="header-anchor">#</a> 三、Executor详解</h2> <h3 id="executor简介"><a href="#executor简介" class="header-anchor">#</a> Executor简介</h3> <p>在没有接触线程池之前，我们通过Thread类的start方法来开启一个线程执行任务。<br>
在JDK1.5 引入了<code>Executor</code>，并通过<code>Executor</code>及其相关的接口和实现类提供了一种更方便的方式来管理和控制线程的生命周期，使得开发者能够更加专注于业务逻辑而不是底层的线程操作。 并且Java线程池的实现也是基于<code>Executor</code>及其相关的接口和实现类。</p> <p>可以把 <code>Executor</code> 理解为一种框架，它的目的就是简化线程的管理和控制。</p> <h3 id="executor框架的继承结构"><a href="#executor框架的继承结构" class="header-anchor">#</a> Executor框架的继承结构</h3> <img src="/blog/images/40-3.png" alt="mixureSecure"> <p>下图挑了几个常见常用的<code>ExecutorService</code>的实现</p> <img src="/blog/images/40-4.png" alt="mixureSecure"> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <h3 id="executor"><a href="#executor" class="header-anchor">#</a> Executor</h3> <ul><li><code>Executor</code>：定义了一个执行任务的方法 <code>execute(Runnable command)</code>，这是执行任务的基本接口。</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Executor</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> command<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="executorservice"><a href="#executorservice" class="header-anchor">#</a> ExecutorService</h3> <ul><li><code>ExecutorService</code>：继承自 <code>Executor</code>，提供了更全面的线程池管理功能，如提交任务、关闭线程池等。
我们使用具体的线程池时，比如<code>ThreadPoolExecutor</code> 和<code>ScheduledThreadPoolExecutor</code>调用的基本上都是<code>ExecutorService</code> 定义的方法。</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ExecutorService</span> <span class="token keyword">extends</span> <span class="token class-name">Executor</span> <span class="token punctuation">{</span>

    <span class="token comment">/**
     * 启动有序关闭，其中之前提交的任务会被执行，但不再接受新的任务。
     * 如果已经关闭，调用此方法没有其他效果。
     * 
     * 这个方法不会等待之前提交的任务完成。可以使用 {@link #awaitTermination} 来等待任务完成。
     *
     * @throws SecurityException 如果存在安全管理器，并且关闭此 ExecutorService 可能会操作
     *         调用者不允许修改的线程，因为它没有持有 {@link
     *         java.lang.RuntimePermission}{@code (&quot;modifyThread&quot;)} 权限，或者安全管理器的 {@code checkAccess} 方法
     *         拒绝访问。
     */</span>
    <span class="token keyword">void</span> <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * 尝试停止所有正在执行的任务，停止处理等待中的任务，并返回一个待执行任务的列表。
     * 
     * 这个方法不会等待正在执行的任务终止。可以使用 {@link #awaitTermination} 来等待任务终止。
     * 
     * 对于正在执行的任务，停止操作只是尽力而为，可能会通过 {@link Thread#interrupt} 进行取消，但有些任务可能不会响应中断。
     * 
     * @return 未开始执行的任务列表
     * @throws SecurityException 如果存在安全管理器，并且关闭此 ExecutorService 可能会操作
     *         调用者不允许修改的线程，因为它没有持有 {@link
     *         java.lang.RuntimePermission}{@code (&quot;modifyThread&quot;)} 权限，或者安全管理器的 {@code checkAccess} 方法
     *         拒绝访问。
     */</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> <span class="token function">shutdownNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * 如果此执行器已经关闭，则返回 {@code true}。
     * 
     * @return 如果此执行器已经关闭，则返回 {@code true}
     */</span>
    <span class="token keyword">boolean</span> <span class="token function">isShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * 如果所有任务在关闭后都已完成，则返回 {@code true}。
     * 注意，{@code isTerminated} 只有在 {@code shutdown} 或 {@code shutdownNow} 被调用后才会为 {@code true}。
     * 
     * @return 如果所有任务在关闭后都已完成，则返回 {@code true}
     */</span>
    <span class="token keyword">boolean</span> <span class="token function">isTerminated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * 阻塞直到所有任务在关闭请求后完成执行，或者超时发生，或者当前线程被中断，以先发生者为准。
     * 
     * @param timeout 等待的最大时间
     * @param unit 超时时间的单位
     * @return 如果此执行器终止，则返回 {@code true}；如果超时发生而未终止，则返回 {@code false}
     * @throws InterruptedException 如果在等待时被中断
     */</span>
    <span class="token keyword">boolean</span> <span class="token function">awaitTermination</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * 提交一个返回值的任务进行执行，并返回一个表示任务结果的 Future 对象。
     * 
     * 如果需要立即阻塞等待任务，可以使用类似 {@code result = exec.submit(aCallable).get();} 的构造。
     * 
     * @param task 要提交的任务
     * @param &lt;T&gt; 任务结果的类型
     * @return 一个表示任务结果的 Future 对象
     * @throws RejectedExecutionException 如果任务无法被调度执行
     * @throws NullPointerException 如果任务为 null
     */</span>
    <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * 提交一个 Runnable 任务进行执行，并返回一个表示任务结果的 Future 对象。
     * 返回的 Future 对象会在任务成功完成后返回给定的结果。
     * 
     * @param task 要提交的任务
     * @param result 完成任务时返回的结果
     * @param &lt;T&gt; 结果的类型
     * @return 一个表示任务结果的 Future 对象
     * @throws RejectedExecutionException 如果任务无法被调度执行
     * @throws NullPointerException 如果任务为 null
     */</span>
    <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> task<span class="token punctuation">,</span> <span class="token class-name">T</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * 提交一个 Runnable 任务进行执行，并返回一个表示任务的 Future 对象。
     * 返回的 Future 对象会在任务成功完成后返回 null。
     * 
     * @param task 要提交的任务
     * @return 一个表示任务的 Future 对象
     * @throws RejectedExecutionException 如果任务无法被调度执行
     * @throws NullPointerException 如果任务为 null
     */</span>
    <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * 执行给定的任务集合，返回一个包含所有任务的 Future 列表。
     * 
     * @param tasks 任务集合
     * @param &lt;T&gt; 任务返回值的类型
     * @return 任务的 Future 列表，与给定任务集合的顺序相同
     * @throws InterruptedException 如果在等待过程中被中断，未完成的任务会被取消
     * @throws NullPointerException 如果任务或任务集合中的元素为 null
     * @throws RejectedExecutionException 如果任何任务无法被调度执行
     */</span>
    <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Future</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">invokeAll</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Callable</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> tasks<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * 执行给定的任务集合，返回一个包含所有任务的 Future 列表，直到超时发生或所有任务完成为止。
     * 超时后，未完成的任务会被取消。
     * 
     * @param tasks 任务集合
     * @param timeout 最大等待时间
     * @param unit 超时时间的单位
     * @param &lt;T&gt; 任务返回值的类型
     * @return 任务的 Future 列表，与给定任务集合的顺序相同。如果操作未超时，所有任务都会完成；如果超时，有些任务可能未完成。
     * @throws InterruptedException 如果在等待过程中被中断，未完成的任务会被取消
     * @throws NullPointerException 如果任务、任务集合中的元素或单位为 null
     * @throws RejectedExecutionException 如果任何任务无法被调度执行
     */</span>
    <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Future</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">invokeAll</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Callable</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> tasks<span class="token punctuation">,</span>
                                  <span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * 执行给定的任务集合，返回其中一个成功完成的任务的结果。如果没有任务成功完成，返回结果是未定义的。
     * 超时或任务完成后，未完成的任务会被取消。
     * 
     * @param tasks 任务集合
     * @param &lt;T&gt; 任务返回值的类型
     * @return 成功完成的任务返回的结果
     * @throws InterruptedException 如果在等待过程中被中断
     * @throws NullPointerException 如果任务集合或其中的元素为 null
     * @throws IllegalArgumentException 如果任务集合为空
     * @throws ExecutionException 如果没有任务成功完成
     * @throws RejectedExecutionException 如果任务无法被调度执行
     */</span>
    <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">invokeAny</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Callable</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> tasks<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * 执行给定的任务集合，返回其中一个成功完成的任务的结果，如果在给定的超时时间内有任务成功完成。
     * 超时后，未完成的任务会被取消。
     * 
     * @param tasks 任务集合
     * @param timeout 最大等待时间
     * @param unit 超时时间的单位
     * @param &lt;T&gt; 任务返回值的类型
     * @return 成功完成的任务返回的结果
     * @throws InterruptedException 如果在等待过程中被中断
     * @throws NullPointerException 如果任务集合、单位或任务集合中的元素为 null
     * @throws TimeoutException 如果在超时时间内没有任务成功完成
     * @throws ExecutionException 如果没有任务成功完成
     * @throws RejectedExecutionException 如果任务无法被调度执行
     */</span>
    <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">invokeAny</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Callable</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> tasks<span class="token punctuation">,</span>
                    <span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">,</span> <span class="token class-name">TimeoutException</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><ul><li><strong>线程池实现：</strong>
Java 的线程池实现基于 Executor 框架中的接口和类。常用的线程池实现包括 <code>ThreadPoolExecutor</code> 、<code>ScheduledThreadPoolExecutor</code>、<code>ForkJoinPool</code>。其中<code>ForkJoinPool</code>计划在后续文章中再详细说明。</li></ul> <h2 id="四、threadpoolexecutor-详解"><a href="#四、threadpoolexecutor-详解" class="header-anchor">#</a> 四、ThreadPoolExecutor 详解</h2> <h3 id="线程池的七个参数"><a href="#线程池的七个参数" class="header-anchor">#</a> 线程池的七个参数</h3> <p>ThreadPoolExecutor带七个参数的构造方法：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>
                              <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>
                              <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>
                              <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span>
                              <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">,</span>
                              <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">,</span>
                              <span class="token class-name">RejectedExecutionHandler</span> handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>corePoolSize <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span>
            maximumPoolSize <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span>
            maximumPoolSize <span class="token operator">&lt;</span> corePoolSize <span class="token operator">||</span>
            keepAliveTime <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>workQueue <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> threadFactory <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> handler <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>corePoolSize <span class="token operator">=</span> corePoolSize<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>maximumPoolSize <span class="token operator">=</span> maximumPoolSize<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>workQueue <span class="token operator">=</span> workQueue<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>keepAliveTime <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>threadFactory <span class="token operator">=</span> threadFactory<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>handler <span class="token operator">=</span> handler<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><ul><li>参数1
<code>int corePoolSize // 线程池核心线程数量</code><br>
线程池中会维护一个最小的线程数量，即使这些线程处于空闲状态，也不会被销毁，除非设置了   allowCoreThreadTimeOut=true。这里的最小线程数量即是corePoolSize。</li></ul> <div class="language-java extra-class"><pre class="language-java"><code>  <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> allowCoreThreadTimeOut<span class="token punctuation">;</span>

<span class="token comment">// 控制是否允许核心线程在空闲时被回收</span>
<span class="token comment">// 默认情况下，核心线程在空闲时不会被销毁，除非调用了此方法并将 value 设置为 true。</span>
<span class="token comment">// 允许核心线程超时的前提是 keepAliveTime 必须大于0</span>
<span class="token comment">// 当启用核心线程超时时，通过调用 interruptIdleWorkers() 方法中断空闲线程，从而促使它们按照超时时间被销毁</span>
 <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">allowCoreThreadTimeOut</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">&amp;&amp;</span> keepAliveTime <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">&quot;Core threads must have nonzero keep alive times&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">!=</span> allowCoreThreadTimeOut<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            allowCoreThreadTimeOut <span class="token operator">=</span> value<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span>
                <span class="token function">interruptIdleWorkers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre></div><ul><li><p>参数2<br> <code>int maximumPoolSize // 线程池最大线程数量</code><br>
一个任务被提交到线程池以后，首先会找有没有空闲存活线程，如果有则直接执行，如果没有则会缓存到工作队列中，如果工作队列满了，才会创建一个新线程，然后从工作队列的头部取出一个任务交由新线程来处理，而将刚提交的任务放入工作队列尾部。线程池不会无限制的去创建新线程，它会有一个最大线程数量的限制，这个数量即由maximunPoolSize的数量减去corePoolSize的数量来确定，最多能达到maximunPoolSize即最大线程池线程数量。</p></li> <li><p>参数3<br> <code>long keepAliveTime // 空闲线程存活时间</code><br>
一个线程如果处于空闲状态，并且当前的线程数量大于corePoolSize，默认情况下在指定时间后，这个空闲线程会被销毁，这里的指定时间由keepAliveTime来设定。(默认情况是指allowCoreThreadTimeOut=false的情况)。</p></li> <li><p>参数4<br> <code>TimeUnit unit // 空闲线程存活时间单位</code><br>
keepAliveTime参数的时间计量单位</p></li> <li><p>参数5<br> <code>BlockingQueue &lt; Runnable &gt; workQueue // 工作队列</code>
新任务被提交后，会先进入到此工作队列中，任务调度时再从队列中取出任务。<br>
对于阻塞队列的知识可参考  <a href="https://blog.csdn.net/qq_37883866/article/details/139739625" target="_blank" rel="noopener noreferrer">BlockingQueue详解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 这篇文章。</p></li></ul> <p>下面简单介绍下jdk中提供的几种常见的工作队列：<br> <strong>①、ArrayBlockingQueue</strong><br>
基于数组的有界阻塞队列，按FIFO排序。新任务进来后，会放到该队列的队尾，有界的数组可以防止资源耗尽问题。当线程池中线程数量达到corePoolSize后，再有新任务进来，则会将任务放入该队列的队尾，等待被调度。如果队列已经是满的，则创建一个新线程，如果线程数量已经达到maxPoolSize，则会执行拒绝策略。</p> <p><strong>②、LinkedBlockingQuene</strong><br>
基于链表的无界阻塞队列（其实最大容量为Integer.MAX_VALUE），按照FIFO排序。由于该队列的近似无界性，当线程池中线程数量达到corePoolSize后，再有新任务进来，会一直存入该队列，而不会去创建新线程直到maxPoolSize，因此使用该工作队列时，参数maxPoolSize其实是不起作用的，除非JVM内存能装下Integer.MAX_VALUE个任务且不发生OOM。</p> <p><strong>③、SynchronousQuene</strong><br>
一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。也就是说新任务进来时，不会缓存，而是直接被调度执行该任务，如果没有可用线程，则创建新线程，如果线程数量达到maxPoolSize，则执行拒绝策略。</p> <p><strong>④、PriorityBlockingQueue</strong><br>
具有优先级的无界阻塞队列，优先级通过参数Comparator实现。</p> <p><strong>⑤、DelayQueue详解</strong><br>
DelayQueue 是 Java 并发包（java.util.concurrent）中的一个特殊队列,用于在指定的延迟时间之后处理元素。
详细内容可参考 <a href="https://blog.csdn.net/qq_37883866/article/details/139739685" target="_blank" rel="noopener noreferrer">DelayQueue详解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ul><li>参数6
<code>ThreadFactory threadFactory // 线程工厂</code>
创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon（守护）线程等等</li></ul> <p><a href="https://blog.csdn.net/weixin_40304387/article/details/80507340" target="_blank" rel="noopener noreferrer">关于守护线程可参考https://blog.csdn.net/weixin_40304387/article/details/80507340<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ul><li>参数7
<code>RejectedExecutionHandler handler // 拒绝策略</code><br>
当工作队列中的任务已到达最大限制，并且线程池中的线程数量也达到最大限制，这时如果有新任务提交进来，该如何处理呢。这里的拒绝策略，就是解决这个问题的，jdk中提供了4种拒绝策略：</li></ul> <p><strong>①、CallerRunsPolicy</strong>
该策略下，在调用者线程中直接执行被拒绝任务的run方法。除非线程池已经shutdown，则直接抛弃任务，也就是说，当线程池已经关闭时，不会再将任务交给调用者线程执行。<br>
创建CallerRunsPolicy 实例：<br> <code>RejectedExecutionHandler callerRunsPolicy = new ThreadPoolExecutor.CallerRunsPolicy ();</code></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">CallerRunsPolicy</span> <span class="token keyword">implements</span> <span class="token class-name">RejectedExecutionHandler</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token class-name">CallerRunsPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
        
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> r<span class="token punctuation">,</span> <span class="token class-name">ThreadPoolExecutor</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>e<span class="token punctuation">.</span><span class="token function">isShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                r<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre></div><p><strong>②、AbortPolicy</strong>
该策略下，直接丢弃任务，并抛出RejectedExecutionException异常。
创建AbortPolicy实例：<br> <code>RejectedExecutionHandler abortPolicy = new ThreadPoolExecutor.AbortPolicy();</code></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">AbortPolicy</span> <span class="token keyword">implements</span> <span class="token class-name">RejectedExecutionHandler</span> <span class="token punctuation">{</span>
     
        <span class="token keyword">public</span> <span class="token class-name">AbortPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> r<span class="token punctuation">,</span> <span class="token class-name">ThreadPoolExecutor</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RejectedExecutionException</span><span class="token punctuation">(</span><span class="token string">&quot;Task &quot;</span> <span class="token operator">+</span> r<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>
                                                 <span class="token string">&quot; rejected from &quot;</span> <span class="token operator">+</span>
                                                 e<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre></div><p><strong>③、DiscardPolicy</strong>
该策略下，直接丢弃任务，什么都不做。<br>
创建DiscardPolicy实例：<br> <code>RejectedExecutionHandler discardPolicy= new ThreadPoolExecutor.DiscardPolicy();</code></p> <div class="language-java extra-class"><pre class="language-java"><code> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DiscardPolicy</span> <span class="token keyword">implements</span> <span class="token class-name">RejectedExecutionHandler</span> <span class="token punctuation">{</span>

        <span class="token keyword">public</span> <span class="token class-name">DiscardPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> r<span class="token punctuation">,</span> <span class="token class-name">ThreadPoolExecutor</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre></div><p><strong>④、DiscardOldestPolicy</strong><br>
创建DiscardPolicy实例：<br> <code>RejectedExecutionHandler discardOldestPolicy= new ThreadPoolExecutor.DiscardOldestPolicy();</code><br>
该策略下，抛弃进入队列最早的那个任务，然后尝试把这次拒绝的任务放入队列</p> <div class="language-java extra-class"><pre class="language-java"><code> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DiscardOldestPolicy</span> <span class="token keyword">implements</span> <span class="token class-name">RejectedExecutionHandler</span> <span class="token punctuation">{</span>
   
        <span class="token keyword">public</span> <span class="token class-name">DiscardOldestPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
        
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> r<span class="token punctuation">,</span> <span class="token class-name">ThreadPoolExecutor</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>e<span class="token punctuation">.</span><span class="token function">isShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">getQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                e<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre></div><h3 id="线程池的任务调度流程图示"><a href="#线程池的任务调度流程图示" class="header-anchor">#</a> 线程池的任务调度流程图示</h3> <p>图片参考https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html</p> <img src="/blog/images/40-5.png" alt="mixureSecure"> <h3 id="workthread模式和future模式"><a href="#workthread模式和future模式" class="header-anchor">#</a> WorkThread模式和Future模式</h3> <p>下面内容摘自《图解Java多线程设计模式》</p> <p><strong>WorkThread模式</strong><br>
Worker 的意思是工作的人、劳动者。在 Worker Thread模式中，工人线程(worker thread)会逐个取回工作并进行处理。当所有工作全部完成后，工人线程会等待新的工作到来。Worker Thread模式也被称为 Background Thread(背景线程)模式。另外，如果从“保存多个工人线程的场所”这一点来看，我们也可以称这种模式为Thread Pool(线程池)模式。</p> <p><strong>Future 模式</strong><br>
假设我们去蛋糕店买蛋糕。下单后，店员一边递给我们提货单，一边说“请您傍晚再来取蛋糕”。到了傍晚，我们就拿着提货单去取蛋糕。这时，店员会先和我们说“您的蛋糕已经做好了”然后将蛋糕递给了我们。<br>
Future 的意思是未来、期货(经济学用语)。假设有一个方法需要花费很长时间才能获取运行结果。那么，与其一直等待结果，不如先拿一张“提货单”。获取提货单并不耗费时间。这里的“提货单”我们就称为Future角色。<br>
获取Future 角色的线程会在稍后使用Future 角色来获取运行结果。这与凭着提货单去取蛋糕非常相似。<br>
如果运行结果已经出来了，那么直接领取即可;如果运行结果还没有出来，那么需要等待结果出来。Future 角色是购买蛋糕时的提货单、预购单、预约券，是“未来”可以转化为实物的凭证。</p> <p><code>ExecutorService</code>提供两种类型的提交任务方法：</p> <ul><li><p>①、无返回值： <code>void execute(Runnable command);</code>   这个方法用于提交一个实现了 Runnable 接口的任务。该任务在执行完后没有返回结果，也不会抛出异常。</p></li> <li><p>②、返回Future： 比如<code>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</code>或者<code>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</code>等。<br>
具体还是看上面对于ExecutorService类里方法的详细注释。</p></li></ul> <h3 id="线程池的状态和内部结构"><a href="#线程池的状态和内部结构" class="header-anchor">#</a> 线程池的状态和内部结构</h3> <p><strong>线程池的状态</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 使用 AtomicInteger 存储线程池的状态和工作线程数量</span>
<span class="token comment">// AtomicInteger类型是 32 位二进制表示，则其中高 3 位用来表示线程池状态，后面29 位用来记录线程池线程个数。</span>
<span class="token comment">// 其中的（高3位）用来表示线程池状态，（低29位）用来表示线程个数</span>
<span class="token comment">// 默认是RUNNING状态，线程个数为0</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> ctl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token function">ctlOf</span><span class="token punctuation">(</span><span class="token constant">RUNNING</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 控制位掩码的位数 为  32-3 = 29 </span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">COUNT_BITS</span> <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">SIZE</span> <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">;</span>

<span class="token comment">// 最大线程数量（最大工作线程数） (低29位全是1的情况) 000 11111111111111111111111111111</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">CAPACITY</span>   <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token comment">// RUNNING: 线程池正在运行 </span>
<span class="token comment">// 高3位是 111</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">RUNNING</span>    <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span>

<span class="token comment">// SHUTDOWN: 线程池正在关闭，拒绝接受新任务，但处理队列中的任务  </span>
<span class="token comment">// 高3位是 000</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">SHUTDOWN</span>   <span class="token operator">=</span>  <span class="token number">0</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span>

<span class="token comment">// STOP: 线程池正在停止，拒绝新任务和正在处理的任务，并尝试中断工作线程</span>
<span class="token comment">// 高3位是 001</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">STOP</span>       <span class="token operator">=</span>  <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span>

<span class="token comment">// TIDYING: 线程池已完全停止，所有任务都已完成，正在清理资源</span>
<span class="token comment">// 高3位是 010</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">TIDYING</span>    <span class="token operator">=</span>  <span class="token number">2</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span>

<span class="token comment">// TERMINATED: 线程池完全终止，所有资源都已清理</span>
<span class="token comment">// 高3位是 011</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">TERMINATED</span> <span class="token operator">=</span>  <span class="token number">3</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span>

<span class="token comment">// 获取当前状态的高位部分（高3位）， 也就是线程池的状态</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> c <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token constant">CAPACITY</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 获取当前线程池中工作的线程数量 (低29位)</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> c <span class="token operator">&amp;</span> <span class="token constant">CAPACITY</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 将线程池状态（runState）和工作线程数量（workerCount）打包成一个整数</span>
<span class="token comment">// 便于在 ThreadPoolExecutor 中以原子操作的方式存储和更新这些信息</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ctlOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> rs<span class="token punctuation">,</span> <span class="token keyword">int</span> wc<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> rs <span class="token operator">|</span> wc<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p><strong>内部结构</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 阻塞队列，用于存储待执行的任务</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">;</span>
<span class="token comment">// 用于在对 ThreadPoolExecutor 内部状态（如任务队列和工作线程集合）进行修改时提供线程安全（互斥访问）</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> mainLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 用于存储线程池中的工作线程（Worker 对象）</span>
<span class="token comment">// Worker 是 ThreadPoolExecutor 的内部类，表示线程池中的一个线程实例</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Worker</span><span class="token punctuation">&gt;</span></span> workers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Worker</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="线程池的关闭"><a href="#线程池的关闭" class="header-anchor">#</a> 线程池的关闭</h3> <p>当关闭一个线程池的时候，会有一些复杂的情况要考虑，比如有的线程还正在执行某个任务，有的调用者正在向线程池提交任务，并且队列中可能还有未执行的任务。因此，关闭所有的这些任务需要一个过程，这就涉及线程池的完整生命周期管理。</p> <p>ExecutorService提供了两种关闭线程池的方法：<br> <strong>①、<code>void shutdown();</code></strong> <strong>作用：</strong><br>
shutdown() 方法用于平稳地关闭线程池。它会进行一种渐进的关闭过程，使线程池停止接收新任务，但会继续执行队列中已有的任务和正在执行的任务。</p> <p><strong>过程：</strong><br> <strong>禁止接收新任务:</strong>  一旦调用 shutdown()，线程池将不再接收新的任务。即使调用 submit 或 execute 方法提交新任务，这些新任务也会被拒绝。<br> <strong>继续处理队列任务:</strong>  线程池会继续处理任务队列中尚未执行的任务。已经提交的任务将会被逐个处理，直到队列为空。<br> <strong>结束线程:</strong>  当队列中的任务执行完毕后，工作线程会终止。线程池将进入 SHUTDOWN 状态，等待所有任务完成后，最终进入 TERMINATED 状态。</p> <p><strong>②、<code>List&lt;Runnable&gt; shutdownNow();</code></strong><br> <strong>作用：</strong><br> <code>shutdownNow()</code> 方法用于立即关闭线程池。它会尽力停止正在执行的任务，取消队列中的所有待执行任务，并返回那些尚未执行的任务列表。</p> <p><strong>过程：</strong><br> <strong>禁止接收新任务:</strong> 与 <code>shutdown()</code> 方法一样，shutdownNow() 也会立即禁止线程池接收新任务。<br> <strong>中断正在执行的任务:</strong>  线程池会尝试中断正在执行的任务。这是通过调用 <code>Thread.interrupt()</code> 实现的。请注意，任务需要能够处理中断请求，以便被正确停止。<br> <strong>取消队列任务:</strong>  从任务队列中移除所有未执行的任务。未被处理的任务将不会被执行。<br> <strong>返回未执行的任务列表:</strong> <code>shutdownNow()</code> 方法返回一个 <code>List&lt;Runnable&gt;</code>，包含所有从队列中移除但尚未执行的任务。这个列表可以用于进一步处理，例如记录或重试这些任务。<br> <strong>结束线程:</strong>  尽管 <code>shutdownNow()</code> 会尝试中断任务和线程，但线程池的工作线程最终会终止。线程池会进入 <code>STOP</code> 状态，并在所有任务完全处理后，最终进入 <code>TERMINATED</code> 状态。</p> <h4 id="线程池的状态转换图"><a href="#线程池的状态转换图" class="header-anchor">#</a> 线程池的状态转换图</h4> <p>下图参考《Java并发编程之美》<br> <img src="/blog/images/40-6.png" alt="mixureSecure"></p> <p>正确关闭线程池示例：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> dog1 <span class="token operator">=</span> <span class="token string">&quot;秀逗&quot;</span><span class="token punctuation">;</span>

        <span class="token comment">// 使用线程池执行任务</span>
        threadPoolExecutor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token function">eat</span><span class="token punctuation">(</span>dog1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 关闭线程池</span>
        threadPoolExecutor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 或者  threadPoolExecutor.shutdownNow();</span>

        <span class="token comment">// 一直判端是否关闭</span>
<span class="token comment">//        while (!threadPoolExecutor.isTerminated()) {</span>
<span class="token comment">//        }</span>

        <span class="token comment">// 或者使用awaitTermination 隔短时间判断一次</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>threadPoolExecutor<span class="token punctuation">.</span><span class="token function">awaitTermination</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">}</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;线程池已关闭&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
</code></pre></div><h3 id="工作线程worker"><a href="#工作线程worker" class="header-anchor">#</a> 工作线程<code>Worker</code></h3> <p><code>Worker</code> 是 <code>ThreadPoolExecutor</code> 的内部类，表示线程池中的一个线程实例。<br> <code>Worker</code> 继承 AQS 实现了不可重入的互斥锁用于控制线程的状态和同步。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// `Worker` 类表示线程池中的一个工作线程</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Worker</span>
        <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token comment">// 继承自 AQS，用于控制线程的状态和同步</span>
        <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span> <span class="token comment">// 实现 Runnable 接口，以便能够作为线程执行任务</span>

    <span class="token comment">// 当前工作线程实例</span>
    <span class="token keyword">final</span> <span class="token class-name">Thread</span> thread<span class="token punctuation">;</span>
    
    <span class="token comment">// 初始任务，在工作线程启动时执行</span>
    <span class="token class-name">Runnable</span> firstTask<span class="token punctuation">;</span>
    
    <span class="token comment">// 已完成的任务数量</span>
    <span class="token keyword">volatile</span> <span class="token keyword">long</span> completedTasks<span class="token punctuation">;</span>

    <span class="token comment">// 构造函数</span>
    <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> firstTask<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 设置 AQS 的状态为 -1，以禁止中断，直到 `runWorker` 方法执行</span>
        <span class="token function">setState</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 初始化 `firstTask`，这是构造 `Worker` 时传入的初始任务</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>firstTask <span class="token operator">=</span> firstTask<span class="token punctuation">;</span>
        
        <span class="token comment">// 通过线程工厂创建一个新的线程，并将当前 `Worker` 作为任务传递给线程</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token function">getThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newThread</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// `run` 方法是 `Runnable` 接口中的方法，实现了线程的实际执行逻辑</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 执行 `runWorker` 方法，处理任务的实际逻辑</span>
        <span class="token function">runWorker</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="execute方法详解"><a href="#execute方法详解" class="header-anchor">#</a> <code>execute</code>方法详解</h3> <p><strong><code>ThreadPoolExecutor</code> 类的<code>execute</code>方法：</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> command<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 检查任务是否为null，如果是，抛出空指针异常</span>

    <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取当前状态</span>

    <span class="token comment">// 如果当前工作线程数小于核心线程数</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 尝试添加核心线程</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// 如果成功添加，直接返回</span>
        c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 重新获取状态</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 如果线程池处于运行状态并且队列可以容纳任务</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRunning</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> workQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> recheck <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 再次检查状态</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isRunning</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">remove</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 如果线程池不再运行且任务被移除</span>
            <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 拒绝任务</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// 如果没有线程在工作</span>
            <span class="token function">addWorker</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 添加非核心线程</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果无法添加线程（非核心线程）</span>
        <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 拒绝任务</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><p><strong>总结：</strong><br>
execute 方法接收一个 Runnable 任务并开始处理它。<br>
首先检查任务是否为 null，然后检查当前工作线程数是否少于核心线程数。<br>
如果是，尝试添加一个核心线程。<br>
如果线程池处于运行状态并且队列能够接受任务，它将任务添加到队列中。<br>
如果线程池状态变化或没有工作线程，它将尝试添加额外的线程。<br>
如果上述步骤失败，它将尝试添加一个非核心线程。<br>
如果仍然无法添加线程，它将拒绝任务。</p> <p><strong><code>ThreadPoolExecutor</code> 类的<code>addWorker</code>方法：</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// core如果是true 则添加核心线程  如果是false 则添加 非核心线程</span>
<span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">addWorker</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> firstTask<span class="token punctuation">,</span> <span class="token keyword">boolean</span> core<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    retry<span class="token operator">:</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取当前状态</span>
        <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取线程池运行状态</span>

        <span class="token comment">// 如果线程池状态是SHUTDOWN且任务不为空，返回false</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">&gt;=</span> <span class="token constant">SHUTDOWN</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>rs <span class="token operator">==</span> <span class="token constant">SHUTDOWN</span> <span class="token operator">&amp;&amp;</span> firstTask <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取当前工作线程数</span>
            <span class="token comment">// 如果工作线程数超出最大限制，返回false</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>wc <span class="token operator">&gt;=</span> <span class="token constant">CAPACITY</span> <span class="token operator">||</span> wc <span class="token operator">&gt;=</span> <span class="token punctuation">(</span>core <span class="token operator">?</span> corePoolSize <span class="token operator">:</span> maximumPoolSize<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndIncrementWorkerCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">break</span> retry<span class="token punctuation">;</span> <span class="token comment">// 尝试增加工作线程数，如果成功则跳出重试</span>
            c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 重新获取状态</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> rs<span class="token punctuation">)</span>
                <span class="token keyword">continue</span> retry<span class="token punctuation">;</span> <span class="token comment">// 如果状态发生变化，重新尝试</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">boolean</span> workerStarted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> workerAdded <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token class-name">Worker</span> w <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        w <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>firstTask<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建新的工作线程</span>
        <span class="token keyword">final</span> <span class="token class-name">Thread</span> t <span class="token operator">=</span> w<span class="token punctuation">.</span>thread<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>
            mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token comment">// 检查线程池状态，并确保线程未被启动</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">&lt;</span> <span class="token constant">SHUTDOWN</span> <span class="token operator">||</span> <span class="token punctuation">(</span>rs <span class="token operator">==</span> <span class="token constant">SHUTDOWN</span> <span class="token operator">&amp;&amp;</span> firstTask <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalThreadStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果线程已经存活，抛出异常</span>
                    workers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将工作线程添加到线程池中</span>
                    <span class="token keyword">int</span> s <span class="token operator">=</span> workers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">&gt;</span> largestPoolSize<span class="token punctuation">)</span>
                        largestPoolSize <span class="token operator">=</span> s<span class="token punctuation">;</span> <span class="token comment">// 更新最大线程池大小</span>
                    workerAdded <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>workerAdded<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 启动线程</span>
                workerStarted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>workerStarted<span class="token punctuation">)</span>
            <span class="token function">addWorkerFailed</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果线程未成功启动，处理失败情况</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> workerStarted<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>总结：<br>
addWorker 方法尝试添加一个新的工作线程。<br>
它首先检查线程池的状态和工作线程数，然后尝试增加工作线程数。<br>
如果线程成功增加，它创建一个新的 Worker 对象并启动线程。<br>
如果线程未成功启动，它会调用 addWorkerFailed 方法处理失败情况。</p> <p><strong><code>ThreadPoolExecutor</code> 类的<code>addWorkerFailed</code>方法：</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">addWorkerFailed</span><span class="token punctuation">(</span><span class="token class-name">Worker</span> w<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>
    mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>w <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            workers<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 移除未成功添加的工作线程</span>
        <span class="token function">decrementWorkerCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 减少工作线程计数</span>
        <span class="token function">tryTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 尝试终止线程池（如果需要）</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="worker-的run方法"><a href="#worker-的run方法" class="header-anchor">#</a> <code>Worker</code> 的<code>run</code>方法</h3> <p>上分析<code>addWorker</code> 方法，如果线程成功增加，会创建一个新的 Worker 对象并启动线程。<br>
就会调用 <code>Worker</code> 的<code>run</code>方法。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Worker 的 run 方法被调用时，实际执行 runWorker 方法，传入当前 Worker 实例。</span>
    <span class="token function">runWorker</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>总结：<br> <code>Worker</code> 的<code>run</code>方法调用 runWorker(this) 来执行 Worker 的任务处理逻辑。</p> <p><strong><code>runWorker</code> 方法，负责执行任务并处理工作线程的生命周期</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">runWorker</span><span class="token punctuation">(</span><span class="token class-name">Worker</span> w<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取当前线程（即 Worker 线程）</span>
    <span class="token class-name">Thread</span> wt <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 从 Worker 中获取第一个任务，并将 firstTask 置为 null</span>
    <span class="token class-name">Runnable</span> task <span class="token operator">=</span> w<span class="token punctuation">.</span>firstTask<span class="token punctuation">;</span>
    w<span class="token punctuation">.</span>firstTask <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 解锁 Worker，允许中断操作</span>
    w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">boolean</span> completedAbruptly <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 标记线程是否异常结束</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// 主循环：只要有任务可执行，就执行</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>task <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>task <span class="token operator">=</span> <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            w<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 锁定 Worker，防止并发修改</span>
            
            <span class="token comment">// 如果线程池的状态至少是 STOP 状态，且线程没有中断，则中断线程</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">STOP</span><span class="token punctuation">)</span> <span class="token operator">||</span>
                 <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">STOP</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
                <span class="token operator">!</span>wt<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                wt<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token comment">// 在执行任务之前调用 beforeExecute 方法</span>
                <span class="token function">beforeExecute</span><span class="token punctuation">(</span>wt<span class="token punctuation">,</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">Throwable</span> thrown <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 执行任务</span>
                    task<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Error</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 在任务执行后调用 afterExecute 方法</span>
                    <span class="token function">afterExecute</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> thrown<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                <span class="token comment">// 任务执行完成后清空 task，并解锁 Worker</span>
                task <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                w<span class="token punctuation">.</span>completedTasks<span class="token operator">++</span><span class="token punctuation">;</span>
                w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        completedAbruptly <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 如果正常完成，标记为 false</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token comment">// 处理 Worker 的退出逻辑</span>
        <span class="token function">processWorkerExit</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> completedAbruptly<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><p><strong>总结：</strong><br> <code>runWorker</code>方法负责 Worker 线程的任务执行。<br>
处理任务队列中的任务。<br>
管理任务的执行前后钩子方法 (beforeExecute 和 afterExecute)。<br>
处理线程中断和异常。<br>
完成任务后更新任务计数，并处理 Worker 退出逻辑。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token class-name">Runnable</span> <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">boolean</span> timedOut <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 上一次 poll() 是否超时</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取线程池的控制状态</span>
        <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取线程池的运行状态</span>

        <span class="token comment">// 如果线程池状态是 SHUTDOWN 或更高状态，且队列为空，则减少 Worker 数量，并返回 null</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">&gt;=</span> <span class="token constant">SHUTDOWN</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>rs <span class="token operator">&gt;=</span> <span class="token constant">STOP</span> <span class="token operator">||</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">decrementWorkerCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取当前工作线程的数量</span>

        <span class="token comment">// 是否需要考虑核心线程超时</span>
        <span class="token keyword">boolean</span> timed <span class="token operator">=</span> allowCoreThreadTimeOut <span class="token operator">||</span> wc <span class="token operator">&gt;</span> corePoolSize<span class="token punctuation">;</span>

        <span class="token comment">// 如果工作线程数超出最大线程数或已超时，且工作队列为空</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>wc <span class="token operator">&gt;</span> maximumPoolSize <span class="token operator">||</span> <span class="token punctuation">(</span>timed <span class="token operator">&amp;&amp;</span> timedOut<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>wc <span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">||</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 尝试减少工作线程数</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndDecrementWorkerCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token comment">// 继续循环，尝试重新获取任务</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// 尝试从工作队列中获取任务</span>
            <span class="token class-name">Runnable</span> r <span class="token operator">=</span> timed <span class="token operator">?</span>
                workQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">NANOSECONDS</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token comment">// 超时情况下尝试获取任务</span>
                workQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 不超时情况下尝试获取任务</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> r<span class="token punctuation">;</span> <span class="token comment">// 如果成功获取到任务，返回任务</span>
            timedOut <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 如果没有获取到任务且 timed 为 true，标记超时</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> retry<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            timedOut <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 如果获取任务过程中被中断，标记未超时</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><p><strong>总结:</strong><br>
getTask 方法负责从工作队列中获取任务，它执行以下操作：</p> <p><strong>①、检查线程池状态:</strong><br>
如果线程池的状态是 SHUTDOWN 或更高状态，并且队列为空，则减少 Worker 数量并返回 null。这意味着线程池正在关闭或已经关闭，无法再获取任务。</p> <p><strong>②、判断是否需要考虑核心线程超时:</strong><br>
如果线程池允许核心线程超时或当前 Worker 数量超过核心线程池大小，则 timed 标记为 true。</p> <p><strong>③、检查是否需要减少 Worker 数量:</strong><br>
如果当前工作线程数超过最大线程数，或者超时并且工作队列为空，且 Worker 数量大于 1，则尝试减少 Worker 数量。如果成功减少，则返回 null。</p> <p><strong>④、获取任务:</strong><br>
如果未超时，则调用 workQueue.take() 阻塞地等待任务。如果超时，则调用 <code>workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)</code> 尝试获取任务。如果获取到任务，则返回任务；否则标记为超时并继续循环尝试。</p> <p><strong>⑤、处理中断情况:</strong><br>
如果在获取任务过程中被中断，标记为未超时，并继续循环尝试获取任务。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">processWorkerExit</span><span class="token punctuation">(</span><span class="token class-name">Worker</span> w<span class="token punctuation">,</span> <span class="token keyword">boolean</span> completedAbruptly<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>completedAbruptly<span class="token punctuation">)</span> <span class="token comment">// 如果线程异常结束，则 workerCount 没有被调整</span>
        <span class="token function">decrementWorkerCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>
    mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// 更新 completedTaskCount 和移除 Worker</span>
        completedTaskCount <span class="token operator">+=</span> w<span class="token punctuation">.</span>completedTasks<span class="token punctuation">;</span>
        workers<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 尝试终止线程池，如果需要的话</span>
    <span class="token function">tryTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">runStateLessThan</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token constant">STOP</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果线程池状态低于 STOP 状态，检查是否需要添加新的 Worker</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>completedAbruptly<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> min <span class="token operator">=</span> allowCoreThreadTimeOut <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> corePoolSize<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>min <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                min <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> min<span class="token punctuation">)</span>
                <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// 如果当前线程数大于或等于最小线程数，不需要添加新的 Worker</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 添加新的 Worker</span>
        <span class="token function">addWorker</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><p><strong>总结：</strong><br>
处理 Worker 线程的退出逻辑。<br>
更新任务计数和 Worker 列表。<br>
根据线程池的状态和条件决定是否需要添加新的 Worker。</p> <h3 id="submit方法详解"><a href="#submit方法详解" class="header-anchor">#</a> <code>submit</code>方法详解</h3> <p><code>submit</code>方法是在<code>AbstractExecutorService</code>类中实现的 ，下面三个submit方法就不赘述了。
详细的方法注释都在上面<code>ExecutorService</code>接口中。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> task<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>task <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">RunnableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> ftask <span class="token operator">=</span> <span class="token function">newTaskFor</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">execute</span><span class="token punctuation">(</span>ftask<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> ftask<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

 <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> task<span class="token punctuation">,</span> <span class="token class-name">T</span> result<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>task <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">RunnableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> ftask <span class="token operator">=</span> <span class="token function">newTaskFor</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">execute</span><span class="token punctuation">(</span>ftask<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> ftask<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
 <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> task<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>task <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">RunnableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> ftask <span class="token operator">=</span> <span class="token function">newTaskFor</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">execute</span><span class="token punctuation">(</span>ftask<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> ftask<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>可以看到，其最终还是调用execute方法来执行任务。</p> <p><strong>具体的步骤如下：</strong><br> <strong>检查任务是否为空：</strong> 如果 <code>task</code> 为 <code>null</code>，抛出 <code>NullPointerException</code>。<br> <strong>创建 <code>RunnableFuture</code> 对象：</strong> 调用 <code>newTaskFor</code> 方法，将 <code>task</code> 封装为 <code>RunnableFuture</code> 对象。这个方法通常会根据具体的实现生成一个 <code>RunnableFuture</code> 实例。<br> <strong>执行任务：</strong> 调用 <code>execute</code> 方法来提交 <code>RunnableFuture</code> 对象到线程池执行。<br> <strong>返回 <code>Future</code> 对象：</strong> 返回封装了任务的 <code>RunnableFuture</code> 对象，允许调用者对任务进行管理（如取消、等待任务完成等）。</p> <p><code>newTaskFor方法</code></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 用于创建一个 FutureTask 实例，将 Runnable 任务和一个预定义的结果 value 关联在一起</span>
<span class="token keyword">protected</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">RunnableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">newTaskFor</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> runnable<span class="token punctuation">,</span> <span class="token class-name">T</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>runnable<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
<span class="token comment">// 用于创建一个 FutureTask 实例，将 Callable 任务封装在一起</span>
<span class="token keyword">protected</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">RunnableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">newTaskFor</span><span class="token punctuation">(</span><span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> callable<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>callable<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>通过<code>submit</code>和<code>newTaskFor</code>方法，<code>ExecutorService</code> 可以灵活地将不同类型的任务封装为 <code>FutureTask</code> 对象，然后提交给线程池执行，从而提供任务执行的异步处理能力和结果管理功能。</p> <h3 id="适配器runnablefuture"><a href="#适配器runnablefuture" class="header-anchor">#</a> 适配器RunnableFuture</h3> <p><code>RunnableFuture</code> 是一个接口，继承自 <code>Runnable</code> 和 <code>Future</code> 接口，旨在同时兼容这两种接口。它的主要作用是允许通过 <code>Runnable</code> 任务接口来处理结果，这种设计使得任务可以同时被线程池执行和结果获取。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 这个接口结合了 Runnable 和 Future 的功能</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">RunnableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">Runnable</span><span class="token punctuation">,</span> <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>实现类 FutureTask</strong><br>
这里仅简单解释下(FutureTask的详细分析计划后续再写一篇博客)
FutureTask 是 RunnableFuture 的一个常用实现，它可以封装 Runnable 或 Callable 任务，提供执行和结果获取的功能。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">RunnableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><img src="/blog/images/40-7.png" alt="mixureSecure"> <h2 id="五、scheduledthreadpoolexecutor详解"><a href="#五、scheduledthreadpoolexecutor详解" class="header-anchor">#</a> 五、ScheduledThreadPoolExecutor详解</h2> <p><code>ScheduledThreadPoolExecutor</code> 是 Java 并发框架中用于执行定时任务和周期任务的一个类。它扩展了 <code>ThreadPoolExecutor</code>，并实现了 <code>ScheduledExecutorService</code> 接口，提供了在给定的延迟后执行任务和周期性执行任务的能力。</p> <h3 id="类的继承体系"><a href="#类的继承体系" class="header-anchor">#</a> 类的继承体系</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ScheduledThreadPoolExecutor</span>
        <span class="token keyword">extends</span> <span class="token class-name">ThreadPoolExecutor</span>
        <span class="token keyword">implements</span> <span class="token class-name">ScheduledExecutorService</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><img src="/blog/images/40-8.png" alt="mixureSecure"> <h3 id="三种特殊执行方式"><a href="#三种特殊执行方式" class="header-anchor">#</a> 三种特殊执行方式</h3> <p><strong>①、schedule方法</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * 计划一个一次性任务，在指定的延迟后执行。
 * 任务将在指定的延迟时间后执行一次，适用于需要在延迟后执行的单次任务。
 *
 * @param command 要执行的任务，必须是 Runnable 类型
 * @param delay 从现在起的延迟时间，任务将在此时间后执行
 * @param unit 延迟时间的单位，例如 TimeUnit.SECONDS
 * @return 一个 ScheduledFuture 对象，代表已计划的任务
 * @throws NullPointerException 如果 command 或 unit 为 null
 */</span>
<span class="token keyword">public</span> <span class="token class-name">ScheduledFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> command<span class="token punctuation">,</span>
                                   <span class="token keyword">long</span> delay<span class="token punctuation">,</span>
                                   <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> unit <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 确保 command 和 unit 不为 null</span>

    <span class="token comment">// 创建一个 ScheduledFutureTask 对象，设置指定的延迟时间</span>
    <span class="token class-name">RunnableScheduledFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> t <span class="token operator">=</span> <span class="token function">decorateTask</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span>
        <span class="token keyword">new</span> <span class="token class-name">ScheduledFutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
                                      <span class="token function">triggerTime</span><span class="token punctuation">(</span>delay<span class="token punctuation">,</span> unit<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 延迟执行任务</span>
    <span class="token function">delayedExecute</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> t<span class="token punctuation">;</span> <span class="token comment">// 返回代表已计划任务的 ScheduledFuture 对象</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 计划一个一次性任务，在指定的延迟后执行。
 * 任务将在指定的延迟时间后执行一次，适用于需要在延迟后执行的单次任务，并能返回计算结果。
 *
 * @param callable 要执行的任务，必须是 Callable 类型
 * @param delay 从现在起的延迟时间，任务将在此时间后执行
 * @param unit 延迟时间的单位，例如 TimeUnit.SECONDS
 * @return 一个 ScheduledFuture 对象，代表已计划的任务，并且可以获取任务的结果
 * @throws NullPointerException 如果 callable 或 unit 为 null
 */</span>
<span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">ScheduledFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> callable<span class="token punctuation">,</span>
                                       <span class="token keyword">long</span> delay<span class="token punctuation">,</span>
                                       <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>callable <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> unit <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 确保 callable 和 unit 不为 null</span>

    <span class="token comment">// 创建一个 ScheduledFutureTask 对象，设置指定的延迟时间</span>
    <span class="token class-name">RunnableScheduledFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> t <span class="token operator">=</span> <span class="token function">decorateTask</span><span class="token punctuation">(</span>callable<span class="token punctuation">,</span>
        <span class="token keyword">new</span> <span class="token class-name">ScheduledFutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>callable<span class="token punctuation">,</span>
                                   <span class="token function">triggerTime</span><span class="token punctuation">(</span>delay<span class="token punctuation">,</span> unit<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 延迟执行任务</span>
    <span class="token function">delayedExecute</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> t<span class="token punctuation">;</span> <span class="token comment">// 返回代表已计划任务的 ScheduledFuture 对象</span>
<span class="token punctuation">}</span>

</code></pre></div><p><strong>②、scheduleAtFixedRate方法</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * 计划一个任务按固定频率执行。
 * 任务会在初始延迟之后开始执行，然后按照固定的周期时间间隔重复执行，周期时间间隔不受任务执行时间的影响。
 * 适用于需要定期执行的任务，例如每隔固定时间更新状态。 (任务的执行时长必须小于周期时长)
 *
 * @param command 要执行的任务，必须是 Runnable 类型
 * @param initialDelay 第一次执行前的延迟时间
 * @param period 后续执行之间的周期时间
 * @param unit initialDelay 和 period 参数的时间单位，例如 TimeUnit.SECONDS
 * @return 一个 ScheduledFuture 对象，代表已计划的任务
 * @throws NullPointerException 如果 command 或 unit 为 null
 * @throws IllegalArgumentException 如果 period 小于或等于零
 */</span>
<span class="token keyword">public</span> <span class="token class-name">ScheduledFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">scheduleAtFixedRate</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> command<span class="token punctuation">,</span>
                                              <span class="token keyword">long</span> initialDelay<span class="token punctuation">,</span>
                                              <span class="token keyword">long</span> period<span class="token punctuation">,</span>
                                              <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> unit <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 确保 command 和 unit 不为 null</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>period <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 确保 period 大于零</span>

    <span class="token comment">// 创建一个 ScheduledFutureTask 对象，设置初始延迟和固定周期</span>
    <span class="token class-name">ScheduledFutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> sft <span class="token operator">=</span>
        <span class="token keyword">new</span> <span class="token class-name">ScheduledFutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>command<span class="token punctuation">,</span>
                                      <span class="token keyword">null</span><span class="token punctuation">,</span>
                                      <span class="token function">triggerTime</span><span class="token punctuation">(</span>initialDelay<span class="token punctuation">,</span> unit<span class="token punctuation">)</span><span class="token punctuation">,</span>
                                      unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>period<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 包装任务并设置外部任务引用</span>
    <span class="token class-name">RunnableScheduledFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> t <span class="token operator">=</span> <span class="token function">decorateTask</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> sft<span class="token punctuation">)</span><span class="token punctuation">;</span>
    sft<span class="token punctuation">.</span>outerTask <span class="token operator">=</span> t<span class="token punctuation">;</span>
    <span class="token comment">// 延迟执行任务</span>
    <span class="token function">delayedExecute</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> t<span class="token punctuation">;</span> <span class="token comment">// 返回代表已计划任务的 ScheduledFuture 对象</span>
<span class="token punctuation">}</span>

</code></pre></div><p><strong>③、scheduleWithFixedDelay方法</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * 计划一个任务按固定延迟执行。
 * 任务会在初始延迟之后开始执行，然后在每次任务结束后的固定延迟后再次执行。延迟时间从任务结束时开始计算，因此任务执行时间长度会影响下次执行的时间。
 * 适用于需要任务完成后再等待固定时间再执行的场景，例如每次处理完成后等待一段时间。
 *
 * @param command 要执行的任务，必须是 Runnable 类型
 * @param initialDelay 第一次执行前的延迟时间
 * @param delay 后续执行之间的延迟时间
 * @param unit initialDelay 和 delay 参数的时间单位，例如 TimeUnit.SECONDS
 * @return 一个 ScheduledFuture 对象，代表已计划的任务
 * @throws NullPointerException 如果 command 或 unit 为 null
 * @throws IllegalArgumentException 如果 delay 小于或等于零
 */</span>
<span class="token keyword">public</span> <span class="token class-name">ScheduledFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">scheduleWithFixedDelay</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> command<span class="token punctuation">,</span>
                                                 <span class="token keyword">long</span> initialDelay<span class="token punctuation">,</span>
                                                 <span class="token keyword">long</span> delay<span class="token punctuation">,</span>
                                                 <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> unit <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 确保 command 和 unit 不为 null</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>delay <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 确保 delay 大于零</span>

    <span class="token comment">// 创建一个 ScheduledFutureTask 对象，设置初始延迟和固定延迟（负值表示固定延迟）</span>
    <span class="token class-name">ScheduledFutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> sft <span class="token operator">=</span>
        <span class="token keyword">new</span> <span class="token class-name">ScheduledFutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>command<span class="token punctuation">,</span>
                                      <span class="token keyword">null</span><span class="token punctuation">,</span>
                                      <span class="token function">triggerTime</span><span class="token punctuation">(</span>initialDelay<span class="token punctuation">,</span> unit<span class="token punctuation">)</span><span class="token punctuation">,</span>
                                      unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span><span class="token operator">-</span>delay<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 包装任务并设置外部任务引用</span>
    <span class="token class-name">RunnableScheduledFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> t <span class="token operator">=</span> <span class="token function">decorateTask</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> sft<span class="token punctuation">)</span><span class="token punctuation">;</span>
    sft<span class="token punctuation">.</span>outerTask <span class="token operator">=</span> t<span class="token punctuation">;</span>
    <span class="token comment">// 延迟执行任务</span>
    <span class="token function">delayedExecute</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> t<span class="token punctuation">;</span> <span class="token comment">// 返回代表已计划任务的 ScheduledFuture 对象</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="使用示例"><a href="#使用示例" class="header-anchor">#</a> 使用示例</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">BlockingQueue</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">ScheduledThreadPoolExecutor</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">TimeUnit</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestA</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ScheduledThreadPoolExecutor</span> executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> dog1 <span class="token operator">=</span> <span class="token string">&quot;秀逗&quot;</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> dog2 <span class="token operator">=</span> <span class="token string">&quot;四眼&quot;</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> dog3 <span class="token operator">=</span> <span class="token string">&quot;大黄&quot;</span><span class="token punctuation">;</span>


        <span class="token comment">// 5秒后 秀逗吃骨头</span>
        executor<span class="token punctuation">.</span><span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dog1 <span class="token operator">+</span> <span class="token string">&quot;吃了骨头！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                <span class="token number">5</span><span class="token punctuation">,</span>
                <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>



        <span class="token comment">// 四眼吃骨头第一次不延时  以后固定周期每两秒吃一次骨头</span>
        <span class="token comment">// 如果吃骨头时间小于两秒 则下一次执行需要等待到2秒才能执行</span>
        <span class="token comment">// 如果吃骨头时间超过了两秒 则下一次执行需要等待上次执行完毕后执行</span>
        executor<span class="token punctuation">.</span><span class="token function">scheduleAtFixedRate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dog2 <span class="token operator">+</span> <span class="token string">&quot;吃了骨头！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">try</span> <span class="token punctuation">{</span>
                        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>

                    <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> executor<span class="token punctuation">.</span><span class="token function">getQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token punctuation">,</span>
                <span class="token number">0</span><span class="token punctuation">,</span>
                <span class="token number">2</span><span class="token punctuation">,</span>
                <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


        <span class="token comment">// 大黄吃骨头第一次不延时  以后每次等上次吃骨头结束后再等2秒执行</span>
        <span class="token comment">// 和具体的任务时间有关 </span>
        executor<span class="token punctuation">.</span><span class="token function">scheduleWithFixedDelay</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dog3 <span class="token operator">+</span> <span class="token string">&quot;吃了骨头！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                <span class="token number">0</span><span class="token punctuation">,</span>
                <span class="token number">2</span><span class="token punctuation">,</span>
                <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="延时执行原理分析"><a href="#延时执行原理分析" class="header-anchor">#</a> 延时执行原理分析</h3> <p>在Java中延时执行的工具有好几种：<br>
①、延时队列DelayQueue，详细可参考<a href="https://blog.csdn.net/qq_37883866/article/details/139739685" target="_blank" rel="noopener noreferrer">DelayQueue详解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 。<br>
②、java.util.Timer类。<br>
③、还有本次说的ScheduledThreadPoolExecutor。</p> <p>对比：</p> <table><thead><tr><th>工具</th> <th>使用场景</th> <th>实现方式</th></tr></thead> <tbody><tr><td><strong>DelayQueue</strong></td> <td>适用于需要延迟执行的单个任务，例如缓存过期</td> <td>实现了 <code>BlockingQueue</code> 接口，通过 <code>Delayed</code> 元素实现延迟队列</td></tr> <tr><td><strong>java.util.Timer</strong></td> <td>适用于简单的定时任务和周期性任务</td> <td>使用单线程调度任务，通过 <code>TimerTask</code> 实现定时执行</td></tr> <tr><td><strong>ScheduledThreadPoolExecutor</strong></td> <td>适用于高并发定时和周期性任务</td> <td>扩展自 <code>ThreadPoolExecutor</code>，使用 <code>DelayedWorkQueue</code> 实现任务调度</td></tr></tbody></table> <h3 id="delayedworkqueue"><a href="#delayedworkqueue" class="header-anchor">#</a> DelayedWorkQueue</h3> <p><code>ScheduledThreadPoolExecutor</code>内部实现了一个<code>DelayedWorkQueue</code> 延时队列。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DelayedWorkQueue</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span>
        <span class="token keyword">implements</span> <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><p><strong><code>ScheduledThreadPoolExecutor</code>的一个构造方法：</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">NANOSECONDS</span><span class="token punctuation">,</span>
              <span class="token keyword">new</span> <span class="token class-name">DelayedWorkQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>总结：<br>
核心线程数：线程池的核心线程数由 corePoolSize 参数指定。
最大线程数：没有最大线程数限制（设置为 Integer.MAX_VALUE）。
线程空闲时间：在这个构造方法中无实际意义（设置为 0）。表示线程不会空闲等待。
时间单位：在这里设置为纳秒（NANOSECONDS），但不对空闲时间起作用。
任务队列：使用 DelayedWorkQueue，支持任务的延迟和定时调度。直接初始化一个DelayedWorkQueue实例。</p> <p><strong>再看下DelayedWorkQueue存的是什么？</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">INITIAL_CAPACITY</span> <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token class-name">RunnableScheduledFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RunnableScheduledFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token constant">INITIAL_CAPACITY</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>可以看到DelayedWorkQueue底层是RunnableScheduledFuture数组。</p> <img src="/blog/images/40-9.png" alt="mixureSecure"> <p>可以看到RunnableScheduledFuture继承了Delayed接口， DelayQueue保存的对象也是要实现Delayed接口的。<br>
都是要利用getDelay方法获取延迟时间。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getDelay</span><span class="token punctuation">(</span><span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> unit<span class="token punctuation">.</span><span class="token function">convert</span><span class="token punctuation">(</span>time <span class="token operator">-</span> <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">NANOSECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre></div><h3 id="延迟执行-schedule方法"><a href="#延迟执行-schedule方法" class="header-anchor">#</a> 延迟执行：  <code>schedule</code>方法</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ScheduledFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> command<span class="token punctuation">,</span>
                                   <span class="token keyword">long</span> delay<span class="token punctuation">,</span>
                                   <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 检查参数是否为 null。如果是，则抛出 NullPointerException 异常。</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> unit <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 创建一个 ScheduledFutureTask 对象。ScheduledFutureTask 是实现了 ScheduledFuture 的任务。</span>
    <span class="token comment">// decorateTask 方法用于对任务进行装饰（例如，可能添加一些额外功能），</span>
    <span class="token comment">// 这里的 ScheduledFutureTask 以 command 为任务，使用 triggerTime 方法计算触发时间。</span>
    <span class="token class-name">RunnableScheduledFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> t <span class="token operator">=</span> <span class="token function">decorateTask</span><span class="token punctuation">(</span>
        command<span class="token punctuation">,</span> <span class="token comment">// 任务命令</span>
        <span class="token keyword">new</span> <span class="token class-name">ScheduledFutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token comment">// 创建 ScheduledFutureTask 实例，传入任务命令和触发时间</span>
                                      <span class="token function">triggerTime</span><span class="token punctuation">(</span>delay<span class="token punctuation">,</span> unit<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 调用 delayedExecute 方法，将任务提交到延迟队列中，以便在指定的延迟时间后执行。</span>
    <span class="token function">delayedExecute</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 返回创建的 ScheduledFutureTask 实例，允许调用者通过它来获取任务的执行结果和状态。</span>
    <span class="token keyword">return</span> t<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">delayedExecute</span><span class="token punctuation">(</span><span class="token class-name">RunnableScheduledFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> task<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果线程池已经关闭，则拒绝任务的添加。</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">reject</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 将任务添加到任务队列中。</span>
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 检查线程池是否已经关闭，并且当前线程池状态不允许运行此任务。</span>
        <span class="token comment">// 如果任务是周期性的，且在关闭后任务仍然在队列中，则取消任务。</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
            <span class="token operator">!</span><span class="token function">canRunInCurrentRunState</span><span class="token punctuation">(</span>task<span class="token punctuation">.</span><span class="token function">isPeriodic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
            <span class="token function">remove</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span>
            task<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token comment">// 确保线程池有足够的核心线程来处理任务。</span>
            <span class="token function">ensurePrestart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// ThreadPoolExecutor里的 ensurePrestart方法</span>
<span class="token keyword">void</span> <span class="token function">ensurePrestart</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取当前工作线程数量。</span>
    <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 如果工作线程数少于核心线程数，则添加新的工作线程。</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>wc <span class="token operator">&lt;</span> corePoolSize<span class="token punctuation">)</span>
        <span class="token function">addWorker</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 如果工作线程数为 0，则添加一个新的工作线程。</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>wc <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token function">addWorker</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>可以看到schedule方法就是把提交的 Runnable 任务加上delay时间，转换成ScheduledFutureTask对象，放入DelayedWorkerQueue中。后面任务的执行过程还是复用的ThreadPoolExecutor，延迟的控制是在DelayedWorkerQueue内部完成的。</p> <h3 id="周期执行-withfixeddelay和atfixedrate"><a href="#周期执行-withfixeddelay和atfixedrate" class="header-anchor">#</a> 周期执行：  <code>withFixedDelay</code>和<code>atFixedRate</code></h3> <p>周期执行整体步骤和延迟执行步骤基本一致，不同点在于<code>ScheduledFutureTask</code>的内部实现。</p> <p><code>scheduleWithFixedDelay</code>方法内创建<code>ScheduledFutureTask</code>对象时传入的延迟时间是负值<code>unit.toNanos(-delay)</code>。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">ScheduledFutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> sft <span class="token operator">=</span>
            <span class="token keyword">new</span> <span class="token class-name">ScheduledFutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>command<span class="token punctuation">,</span>
                                          <span class="token keyword">null</span><span class="token punctuation">,</span>
                                          <span class="token function">triggerTime</span><span class="token punctuation">(</span>initialDelay<span class="token punctuation">,</span> unit<span class="token punctuation">)</span><span class="token punctuation">,</span>
                                          unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span><span class="token operator">-</span>delay<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><code>scheduleAtFixedRate</code>方法内创建<code>ScheduledFutureTask</code>对象时传入的周期时间是正值<code>unit.toNanos(period))</code>。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">ScheduledFutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> sft <span class="token operator">=</span>
            <span class="token keyword">new</span> <span class="token class-name">ScheduledFutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>command<span class="token punctuation">,</span>
                                          <span class="token keyword">null</span><span class="token punctuation">,</span>
                                          <span class="token function">triggerTime</span><span class="token punctuation">(</span>initialDelay<span class="token punctuation">,</span> unit<span class="token punctuation">)</span><span class="token punctuation">,</span>
                                          unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>period<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>正是正值和负值的区别觉得这两个方法的功能区别。</p> <p>在 ScheduledFutureTask 类的 run 方法和 setNextRunTime 方法中，正值和负值的使用会影响任务的调度逻辑。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">boolean</span> periodic <span class="token operator">=</span> <span class="token function">isPeriodic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 如果当前状态不允许运行此任务，则取消任务</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">canRunInCurrentRunState</span><span class="token punctuation">(</span>periodic<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 如果任务是一次性的，则执行任务</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>periodic<span class="token punctuation">)</span>
        <span class="token class-name">ScheduledFutureTask</span><span class="token punctuation">.</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 如果任务是周期性的，则重置任务并重新调度</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">ScheduledFutureTask</span><span class="token punctuation">.</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">runAndReset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">setNextRunTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">reExecutePeriodic</span><span class="token punctuation">(</span>outerTask<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">setNextRunTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">long</span> p <span class="token operator">=</span> period<span class="token punctuation">;</span>
            <span class="token comment">// scheduleAtFixedRate方法  固定周期  </span>
            <span class="token comment">// 周期为正值，下一次开始执行时间 = 上一次开始执行时间 + 周期时间</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
                time <span class="token operator">+=</span> p<span class="token punctuation">;</span>
            <span class="token keyword">else</span>
            <span class="token comment">//scheduleWithFixedDelay 方法 </span>
            <span class="token comment">// 周期为负值, 通过 triggerTime(-p) 计算下一次运行时间  =  当前时间 + 延迟时间</span>
                time <span class="token operator">=</span> <span class="token function">triggerTime</span><span class="token punctuation">(</span><span class="token operator">-</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre></div><h2 id="六、executors工具类"><a href="#六、executors工具类" class="header-anchor">#</a> 六、Executors工具类</h2> <img src="/blog/images/40-10.png" alt="mixureSecure"> <p>下面主要讲一下Executors提供的几种线程池：</p> <ul><li>1、Executors.newSingleThreadExecutor()
具体实现</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> <span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FinalizableDelegatedExecutorService</span>
            <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span>
                                    <span class="token number">0L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">,</span>
                                    <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><ul><li>2、ExecutorService threadPool2 = Executors.newFixedThreadPool(int nThreads);
具体实现</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> <span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> nThreads<span class="token punctuation">,</span>
                                      <span class="token number">0L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">,</span>
                                      <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><ul><li>3、Executors.newCachedThreadPool();
具体实现</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> <span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">,</span>
                                      <span class="token number">60L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">,</span>
                                      <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                      threadFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><ul><li>4、Executors.newScheduledThreadPool(int corePoolSize);
具体实现</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ScheduledExecutorService</span> <span class="token function">newScheduledThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>总结：<br>
上面的四种线程池都是Executors工具类提供的。并且均是阿里的代码规范禁止使用的。</p> <p>阿里的代码规范：<br>
【强制】线程池不允许使用Executors 去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p> <p>说明: Executors返回的线程池对象的弊端如下:
<strong>FixedThreadPool和 SingleThreadPool:</strong><br>
允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。也可能导致栈溢出。</p> <p><strong>CachedThreadPool和 ScheduledThreadPool:</strong><br>
允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。也可能导致栈溢出。</p> <h2 id="七、线程池定义策略和监控"><a href="#七、线程池定义策略和监控" class="header-anchor">#</a> 七、线程池定义策略和监控</h2> <p>(仅供参考 实际情况并非这么简单，下面说的线程数量相关的配置方式仅为参考值，具体需要根据业务场景的负载进行配置)</p> <h3 id="maximumpoolsize-最大线程数"><a href="#maximumpoolsize-最大线程数" class="header-anchor">#</a> maximumPoolSize(最大线程数)</h3> <p>在大部分资料上面都是建议看具体任务类型来配置：</p> <ul><li>①、CPU密集型任务<br>
CPU密集型任务是指那些主要依赖中央处理器（CPU）计算能力的任务。<br>
比如业务中需要对已经查询出的大量数据进行排序，汇总报表等操作。大量数据的金额或者公式计算操作等。</li></ul> <p>这种情况设置maximumPoolSize等于 运行该程序的物理机<strong>CPU核心数量+1</strong>   例如服务器CPU为下图配置则 maximumPoolSize = 33+1 = 34。<br>
这种方式可以保持CPU的效率最高，并且额外多出来的一个线程，即使当计算密集型的线程偶尔由于页缺失故障或者其他原因而暂停时，这个“额外”的线程也能确保CPU的时钟周期不会被浪费。</p> <img src="/blog/images/40-11.png" alt="mixureSecure"> <p>在java代码中  Runtime.getRuntime().availableProcessors() 可返回CPU核心数
<a href="https://blog.csdn.net/zhanghongzheng3213/article/details/83376571" target="_blank" rel="noopener noreferrer">注意 该方法有时候并不一定能准确的返回真实的CPU核心数
参考https://blog.csdn.net/zhanghongzheng3213/article/details/83376571<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ul><li>②、IO密集型
IO（Input/Output）密集型是指程序在执行过程中受到输入输出操作限制的类型。这类程序的特点是它们大部分时间都在等待数据的输入或输出，而不是在进行计算。IO密集型任务往往涉及大量的文件读写、网络通信或其他类型的外部数据交换。</li></ul> <p>对于IO密集型任务，可以配置更多的线程，因为这些任务在等待IO操作完成时会被阻塞，这时阻塞的线程并不会占用CPU资源。这样做的好处是可以充分利用线程池中的线程在等待IO的同时处理其他任务，从而提高系统的吞吐量和效率。</p> <p>一般可以设置为 CPU核心数量*2。</p> <p>还有一种根据公式计算的方式：<br>
参考《Java并发编程实战》</p> <img src="/blog/images/40-12.png" alt="mixureSecure"> <p>这种算出来一般是几倍于核心数的一个值。 但是实际可操作性不大。</p> <p>总结：
最大线程数的设置：<br>
对于CPU密集型任务一般设置为CPU核心数+1。<br>
对于IO密集型任务可以尝试设置为2*CPU核心数。</p> <p>上面的设置方式也只是理论值，具体需要考虑真正的任务情况和负债情况来设置更加合适的值。</p> <h3 id="核心线程数-corepoolsize"><a href="#核心线程数-corepoolsize" class="header-anchor">#</a> 核心线程数 (corePoolSize)：</h3> <p>可以设置为较小的值，通常是较少的线程数来处理常见的请求。比如1 ~ 0.8*CPU核心数。</p> <h3 id="线程工厂"><a href="#线程工厂" class="header-anchor">#</a> 线程工厂</h3> <p>比较重要的是设置线程名称，最好是设置和业务相关的名称，如果出问题了方便排查。</p> <h3 id="非核心线程的存活时间和单位"><a href="#非核心线程的存活时间和单位" class="header-anchor">#</a> 非核心线程的存活时间和单位</h3> <p>单位一般就用秒<code>TimeUnit.SECONDS</code>，如果机器的内存比较吃紧，或者线程引用的任务比较占内存，存活时间可以设置为0。<br>
如果机器内存比较充足，存活时间设置为几百秒也可以。</p> <h3 id="工作队列"><a href="#工作队列" class="header-anchor">#</a> 工作队列</h3> <p>建议使用有界队列，比如<code>ArrayBlockingQueue</code>或者<code>LinkedBlockingQueue</code>(手动传入队列最大容量值)。</p> <h3 id="拒绝策略"><a href="#拒绝策略" class="header-anchor">#</a> 拒绝策略</h3> <p>一般使用  <code>new ThreadPoolExecutor.AbortPolicy()</code>或者<code>new ThreadPoolExecutor.CallerRunsPolicy ()</code>，主要目的就是为了让任务得到处理，或者即使任务得不到处理也要告知调用者没有处理成功。</p> <h3 id="监控线程池"><a href="#监控线程池" class="header-anchor">#</a> 监控线程池</h3> <p>这个属于比较高级的用法了，至少我在生产中没有监控过或者动态调整过线程池的参数。<br>
主要是因为我们生产负载没有太高，按照平时测试情况和经验设置的线程池参数运行起来还算稳定。</p> <p>如果应用并发较高或者对线程池使用量比较大的应用需要进一步优化线程池使用时，就需要对线程池进行监控或者动态调整线程池参数。   具体可以参考美团技术团队的做法 <a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html" target="_blank" rel="noopener noreferrer">https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>ThreadPoolExecutor也提供了一些方法来获取线程池的一些状态参数：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * 返回线程池中已提交的任务的近似数量。
 */</span>
<span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getTaskCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * 返回线程池中已完成任务的近似数量。
 */</span>
<span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getCompletedTaskCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * 返回当前正在执行任务的线程的近似数量。
 */</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getActiveCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * 返回线程池中的当前线程数量。
 */</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * 返回线程池中曾经同时存在的最大线程数量。
 */</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getLargestPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * 返回线程池允许的最大线程数量。
 */</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getMaximumPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// ...</span>
</code></pre></div><p>我们可以利用这些方法来实现一个监控程序。  当我们能想到这一步的时候，一定已经有人把这事都做好了。<br>
比如 <a href="https://hippo4j.cn/" target="_blank" rel="noopener noreferrer">https://hippo4j.cn/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a><br>
看着还不错，感兴趣的可以研究研究。</p> <img src="/blog/images/40-13.png" alt="mixureSecure"> <img src="/blog/images/40-14.png" alt="mixureSecure"> <p>当然这种轮子不可能只有一家， 还有个<a href="https://dynamictp.cn/" target="_blank" rel="noopener noreferrer">https://dynamictp.cn/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>  感谢兴趣也可以去看看。</p> <h2 id="八、实践-手动创建一个生产用线程池"><a href="#八、实践-手动创建一个生产用线程池" class="header-anchor">#</a> 八、实践 手动创建一个生产用线程池</h2> <p>为一个CPU密集型的业务场景设计一个线程池。</p> <h3 id="直接在类的内部创建-将线程池作为类的成员变量"><a href="#直接在类的内部创建-将线程池作为类的成员变量" class="header-anchor">#</a> 直接在类的内部创建，将线程池作为类的成员变量</h3> <p>直接创建 <code>private static final ThreadPoolExecutor</code></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>atomic<span class="token punctuation">.</span></span><span class="token class-name">AtomicInteger</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestA</span> <span class="token punctuation">{</span>

    <span class="token comment">// 假设应用运行的服务器是8核</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ThreadPoolExecutor</span> threadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>
            <span class="token number">4</span><span class="token punctuation">,</span>                              <span class="token comment">// 核心线程数</span>
            <span class="token number">9</span><span class="token punctuation">,</span>                          <span class="token comment">// 最大线程数</span>
            <span class="token number">0</span><span class="token punctuation">,</span>                             <span class="token comment">// 非核心线程的存活时间</span>
            <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">,</span>                           <span class="token comment">// 存活时间单位</span>
            <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">20000</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token comment">// 存放任务的 阻塞队列  设置成2w</span>
            <span class="token keyword">new</span> <span class="token class-name">MyThreadFactory</span><span class="token punctuation">(</span><span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">defaultThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">&quot;自定义线程名称&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>   <span class="token comment">// 创建线程的 工厂</span>
            <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>AbortPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">// 线程池的拒绝策略</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>


    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token punctuation">}</span>


<span class="token punctuation">}</span>


<span class="token comment">/**
 * 可自定义名称的线程池工厂
 */</span>
<span class="token keyword">class</span> <span class="token class-name">MyThreadFactory</span> <span class="token keyword">implements</span> <span class="token class-name">ThreadFactory</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> threadNum <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ThreadFactory</span> delegate<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>


    <span class="token keyword">public</span> <span class="token class-name">MyThreadFactory</span><span class="token punctuation">(</span><span class="token class-name">ThreadFactory</span> delegate<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>delegate <span class="token operator">=</span> delegate<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Thread</span> <span class="token function">newThread</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Thread</span> t <span class="token operator">=</span> delegate<span class="token punctuation">.</span><span class="token function">newThread</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
        t<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>name <span class="token operator">+</span> <span class="token string">&quot; [#&quot;</span> <span class="token operator">+</span> threadNum<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;]&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> t<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="spring项目中可以把线程池注入容器"><a href="#spring项目中可以把线程池注入容器" class="header-anchor">#</a> Spring项目中可以把线程池注入容器</h3> <p>将线程池注入到Spring容器中，并通过依赖注入的方式使用它。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Bean</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Configuration</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>scheduling<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">EnableAsync</span></span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>atomic<span class="token punctuation">.</span></span><span class="token class-name">AtomicInteger</span></span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@Configuration</span>
<span class="token annotation punctuation">@EnableAsync</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadPoolConfig</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">&quot;DefaultExecutorService&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">ExecutorService</span> <span class="token function">cpuIntensiveTaskExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>
                <span class="token number">4</span><span class="token punctuation">,</span>                              <span class="token comment">// 核心线程数</span>
                <span class="token number">9</span><span class="token punctuation">,</span>                          <span class="token comment">// 最大线程数</span>
                <span class="token number">0</span><span class="token punctuation">,</span>                             <span class="token comment">// 非核心线程的存活时间</span>
                <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">,</span>                           <span class="token comment">// 存活时间单位</span>
                <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">20000</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token comment">// 存放任务的 阻塞队列  设置成2w</span>
                <span class="token keyword">new</span> <span class="token class-name">MyThreadFactory</span><span class="token punctuation">(</span><span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">defaultThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">&quot;自定义线程名称&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>   <span class="token comment">// 创建线程的 工厂</span>
                <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>AbortPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">// 线程池的拒绝策略</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 可自定义名称的线程池工厂
 */</span>
<span class="token keyword">class</span> <span class="token class-name">MyThreadFactory</span> <span class="token keyword">implements</span> <span class="token class-name">ThreadFactory</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> threadNum <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ThreadFactory</span> delegate<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>


    <span class="token keyword">public</span> <span class="token class-name">MyThreadFactory</span><span class="token punctuation">(</span><span class="token class-name">ThreadFactory</span> delegate<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>delegate <span class="token operator">=</span> delegate<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Thread</span> <span class="token function">newThread</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Thread</span> t <span class="token operator">=</span> delegate<span class="token punctuation">.</span><span class="token function">newThread</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
        t<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>name <span class="token operator">+</span> <span class="token string">&quot; [#&quot;</span> <span class="token operator">+</span> threadNum<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;]&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> t<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><p>使用起来很方便<br>
不过建议一个线程池还是只用于一种异步任务比较好，这样出问题了好排查。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Resource</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">&quot;DefaultExecutorService&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">private</span> <span class="token class-name">ExecutorService</span> executorService<span class="token punctuation">;</span>
</code></pre></div><p>Spring也提供了线程池的实现<code>ThreadPoolTaskExecutor</code>，创建过程更简单。感兴趣的也可以研究研究，这里不再赘述了。</p> <p>最后简单的线程池使用需求，还是建议直接在类的内部创建<code>private static final ThreadPoolExecutor</code>  ，将线程池作为类的成员变量使用就行了。</p> <p>参考资料：
https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html<br>
https://javaguide.cn/java/concurrent/java-thread-pool-best-practices.html<br>
https://pdai.tech/md/java/thread/java-thread-x-juc-executor-ThreadPoolExecutor.html<br>
《Java性能权威指南》<br>
《Java并发编程之美》<br>
《Java并发编程的艺术》<br>
《图解Java多线程设计模式》</p></div></section> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/blog/java-concurrent/十一、StampedLock详解.html" class="prev">
          十一、StampedLock详解
        </a></span> <span class="next"><a href="/blog/java-concurrent/十三、FutureTask详解.html">
          十三、FutureTask详解
        </a></span></p></div> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-b57cc07c data-v-7dd95ae2><li class="level-2" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E4%BA%8C%E3%80%81Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.html#一、java线程池简介" class="sidebar-link reco-side-一、java线程池简介" data-v-b57cc07c>一、Java线程池简介</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E4%BA%8C%E3%80%81Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.html#池化思想" class="sidebar-link reco-side-池化思想" data-v-b57cc07c>池化思想</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E4%BA%8C%E3%80%81Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.html#池化思想的优点" class="sidebar-link reco-side-池化思想的优点" data-v-b57cc07c>池化思想的优点</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E4%BA%8C%E3%80%81Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.html#二、线程池的实现原理分析" class="sidebar-link reco-side-二、线程池的实现原理分析" data-v-b57cc07c>二、线程池的实现原理分析</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E4%BA%8C%E3%80%81Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.html#实现线程池需要考虑哪些问题" class="sidebar-link reco-side-实现线程池需要考虑哪些问题" data-v-b57cc07c>实现线程池需要考虑哪些问题？</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E4%BA%8C%E3%80%81Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.html#线程池的简单使用示例" class="sidebar-link reco-side-线程池的简单使用示例" data-v-b57cc07c>线程池的简单使用示例</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E4%BA%8C%E3%80%81Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.html#线程池原理的简单图示" class="sidebar-link reco-side-线程池原理的简单图示" data-v-b57cc07c>线程池原理的简单图示</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E4%BA%8C%E3%80%81Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.html#三、executor详解" class="sidebar-link reco-side-三、executor详解" data-v-b57cc07c>三、Executor详解</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E4%BA%8C%E3%80%81Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.html#executor简介" class="sidebar-link reco-side-executor简介" data-v-b57cc07c>Executor简介</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E4%BA%8C%E3%80%81Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.html#executor框架的继承结构" class="sidebar-link reco-side-executor框架的继承结构" data-v-b57cc07c>Executor框架的继承结构</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E4%BA%8C%E3%80%81Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.html#总结" class="sidebar-link reco-side-总结" data-v-b57cc07c>总结</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E4%BA%8C%E3%80%81Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.html#executor" class="sidebar-link reco-side-executor" data-v-b57cc07c>Executor</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E4%BA%8C%E3%80%81Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.html#executorservice" class="sidebar-link reco-side-executorservice" data-v-b57cc07c>ExecutorService</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E4%BA%8C%E3%80%81Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.html#四、threadpoolexecutor-详解" class="sidebar-link reco-side-四、threadpoolexecutor-详解" data-v-b57cc07c>四、ThreadPoolExecutor 详解</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E4%BA%8C%E3%80%81Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.html#线程池的七个参数" class="sidebar-link reco-side-线程池的七个参数" data-v-b57cc07c>线程池的七个参数</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E4%BA%8C%E3%80%81Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.html#线程池的任务调度流程图示" class="sidebar-link reco-side-线程池的任务调度流程图示" data-v-b57cc07c>线程池的任务调度流程图示</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E4%BA%8C%E3%80%81Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.html#workthread模式和future模式" class="sidebar-link reco-side-workthread模式和future模式" data-v-b57cc07c>WorkThread模式和Future模式</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E4%BA%8C%E3%80%81Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.html#线程池的状态和内部结构" class="sidebar-link reco-side-线程池的状态和内部结构" data-v-b57cc07c>线程池的状态和内部结构</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E4%BA%8C%E3%80%81Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.html#线程池的关闭" class="sidebar-link reco-side-线程池的关闭" data-v-b57cc07c>线程池的关闭</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E4%BA%8C%E3%80%81Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.html#工作线程worker" class="sidebar-link reco-side-工作线程worker" data-v-b57cc07c>工作线程Worker</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E4%BA%8C%E3%80%81Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.html#execute方法详解" class="sidebar-link reco-side-execute方法详解" data-v-b57cc07c>execute方法详解</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E4%BA%8C%E3%80%81Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.html#worker-的run方法" class="sidebar-link reco-side-worker-的run方法" data-v-b57cc07c>Worker 的run方法</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E4%BA%8C%E3%80%81Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.html#submit方法详解" class="sidebar-link reco-side-submit方法详解" data-v-b57cc07c>submit方法详解</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E4%BA%8C%E3%80%81Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.html#适配器runnablefuture" class="sidebar-link reco-side-适配器runnablefuture" data-v-b57cc07c>适配器RunnableFuture</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E4%BA%8C%E3%80%81Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.html#五、scheduledthreadpoolexecutor详解" class="sidebar-link reco-side-五、scheduledthreadpoolexecutor详解" data-v-b57cc07c>五、ScheduledThreadPoolExecutor详解</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E4%BA%8C%E3%80%81Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.html#类的继承体系" class="sidebar-link reco-side-类的继承体系" data-v-b57cc07c>类的继承体系</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E4%BA%8C%E3%80%81Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.html#三种特殊执行方式" class="sidebar-link reco-side-三种特殊执行方式" data-v-b57cc07c>三种特殊执行方式</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E4%BA%8C%E3%80%81Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.html#使用示例" class="sidebar-link reco-side-使用示例" data-v-b57cc07c>使用示例</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E4%BA%8C%E3%80%81Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.html#延时执行原理分析" class="sidebar-link reco-side-延时执行原理分析" data-v-b57cc07c>延时执行原理分析</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E4%BA%8C%E3%80%81Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.html#delayedworkqueue" class="sidebar-link reco-side-delayedworkqueue" data-v-b57cc07c>DelayedWorkQueue</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E4%BA%8C%E3%80%81Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.html#延迟执行-schedule方法" class="sidebar-link reco-side-延迟执行-schedule方法" data-v-b57cc07c>延迟执行：  schedule方法</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E4%BA%8C%E3%80%81Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.html#周期执行-withfixeddelay和atfixedrate" class="sidebar-link reco-side-周期执行-withfixeddelay和atfixedrate" data-v-b57cc07c>周期执行：  withFixedDelay和atFixedRate</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E4%BA%8C%E3%80%81Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.html#六、executors工具类" class="sidebar-link reco-side-六、executors工具类" data-v-b57cc07c>六、Executors工具类</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E4%BA%8C%E3%80%81Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.html#七、线程池定义策略和监控" class="sidebar-link reco-side-七、线程池定义策略和监控" data-v-b57cc07c>七、线程池定义策略和监控</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E4%BA%8C%E3%80%81Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.html#maximumpoolsize-最大线程数" class="sidebar-link reco-side-maximumpoolsize-最大线程数" data-v-b57cc07c>maximumPoolSize(最大线程数)</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E4%BA%8C%E3%80%81Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.html#核心线程数-corepoolsize" class="sidebar-link reco-side-核心线程数-corepoolsize" data-v-b57cc07c>核心线程数 (corePoolSize)：</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E4%BA%8C%E3%80%81Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.html#线程工厂" class="sidebar-link reco-side-线程工厂" data-v-b57cc07c>线程工厂</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E4%BA%8C%E3%80%81Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.html#非核心线程的存活时间和单位" class="sidebar-link reco-side-非核心线程的存活时间和单位" data-v-b57cc07c>非核心线程的存活时间和单位</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E4%BA%8C%E3%80%81Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.html#工作队列" class="sidebar-link reco-side-工作队列" data-v-b57cc07c>工作队列</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E4%BA%8C%E3%80%81Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.html#拒绝策略" class="sidebar-link reco-side-拒绝策略" data-v-b57cc07c>拒绝策略</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E4%BA%8C%E3%80%81Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.html#监控线程池" class="sidebar-link reco-side-监控线程池" data-v-b57cc07c>监控线程池</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E4%BA%8C%E3%80%81Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.html#八、实践-手动创建一个生产用线程池" class="sidebar-link reco-side-八、实践-手动创建一个生产用线程池" data-v-b57cc07c>八、实践 手动创建一个生产用线程池</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E4%BA%8C%E3%80%81Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.html#直接在类的内部创建-将线程池作为类的成员变量" class="sidebar-link reco-side-直接在类的内部创建-将线程池作为类的成员变量" data-v-b57cc07c>直接在类的内部创建，将线程池作为类的成员变量</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E4%BA%8C%E3%80%81Java%E7%BA%BF%E7%A8%8B%E6%B1%A0.html#spring项目中可以把线程池注入容器" class="sidebar-link reco-side-spring项目中可以把线程池注入容器" data-v-b57cc07c>Spring项目中可以把线程池注入容器</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/blog/assets/js/app.aa36b75b.js" defer></script><script src="/blog/assets/js/7.272de20f.js" defer></script><script src="/blog/assets/js/2.cc89bbf4.js" defer></script><script src="/blog/assets/js/1.fb256d2a.js" defer></script><script src="/blog/assets/js/64.c623834b.js" defer></script>
  </body>
</html>
