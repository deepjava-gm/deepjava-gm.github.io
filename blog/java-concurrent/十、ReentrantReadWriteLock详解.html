<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>ReentrantReadWriteLock详解 | GM的博客</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="stylesheet" href="/blog/custom.css">
    <script src="/blog/custom.js"></script>
    <meta name="description" content="博观约取、厚积薄发。">
    
    <link rel="preload" href="/blog/assets/css/0.styles.0612dbff.css" as="style"><link rel="preload" href="/blog/assets/js/app.86d0dcf0.js" as="script"><link rel="preload" href="/blog/assets/js/7.4b97e329.js" as="script"><link rel="preload" href="/blog/assets/js/2.cc89bbf4.js" as="script"><link rel="preload" href="/blog/assets/js/1.fb256d2a.js" as="script"><link rel="preload" href="/blog/assets/js/61.fc998d09.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.6c064207.js"><link rel="prefetch" href="/blog/assets/js/11.a693a8f3.js"><link rel="prefetch" href="/blog/assets/js/14.2a1ed16e.js"><link rel="prefetch" href="/blog/assets/js/15.c436ecdb.js"><link rel="prefetch" href="/blog/assets/js/16.5627e9c8.js"><link rel="prefetch" href="/blog/assets/js/17.d76a2ccb.js"><link rel="prefetch" href="/blog/assets/js/18.21f1f4b3.js"><link rel="prefetch" href="/blog/assets/js/19.c3aec7ee.js"><link rel="prefetch" href="/blog/assets/js/20.73f0a331.js"><link rel="prefetch" href="/blog/assets/js/21.108c76a9.js"><link rel="prefetch" href="/blog/assets/js/22.f6b8bd65.js"><link rel="prefetch" href="/blog/assets/js/23.8b148e1e.js"><link rel="prefetch" href="/blog/assets/js/24.f9175dcd.js"><link rel="prefetch" href="/blog/assets/js/25.29d310be.js"><link rel="prefetch" href="/blog/assets/js/26.692e69bd.js"><link rel="prefetch" href="/blog/assets/js/27.20ab0ec1.js"><link rel="prefetch" href="/blog/assets/js/28.99545882.js"><link rel="prefetch" href="/blog/assets/js/29.054ab9de.js"><link rel="prefetch" href="/blog/assets/js/3.c7991857.js"><link rel="prefetch" href="/blog/assets/js/30.2962fbba.js"><link rel="prefetch" href="/blog/assets/js/31.2fc639e9.js"><link rel="prefetch" href="/blog/assets/js/32.97324ada.js"><link rel="prefetch" href="/blog/assets/js/33.23619402.js"><link rel="prefetch" href="/blog/assets/js/34.d9e34b8a.js"><link rel="prefetch" href="/blog/assets/js/35.c4f7378c.js"><link rel="prefetch" href="/blog/assets/js/36.71d98d02.js"><link rel="prefetch" href="/blog/assets/js/37.234e0087.js"><link rel="prefetch" href="/blog/assets/js/38.cf3e4a36.js"><link rel="prefetch" href="/blog/assets/js/39.c75715a7.js"><link rel="prefetch" href="/blog/assets/js/4.e360d680.js"><link rel="prefetch" href="/blog/assets/js/40.f614977f.js"><link rel="prefetch" href="/blog/assets/js/41.2d4e929a.js"><link rel="prefetch" href="/blog/assets/js/42.47df6955.js"><link rel="prefetch" href="/blog/assets/js/43.2d140aa4.js"><link rel="prefetch" href="/blog/assets/js/44.d9013303.js"><link rel="prefetch" href="/blog/assets/js/45.2f402304.js"><link rel="prefetch" href="/blog/assets/js/46.057f8164.js"><link rel="prefetch" href="/blog/assets/js/47.2185b9f9.js"><link rel="prefetch" href="/blog/assets/js/48.d4179aba.js"><link rel="prefetch" href="/blog/assets/js/49.f4fbb16c.js"><link rel="prefetch" href="/blog/assets/js/5.56e9ad02.js"><link rel="prefetch" href="/blog/assets/js/50.86ade5e9.js"><link rel="prefetch" href="/blog/assets/js/51.fb57146c.js"><link rel="prefetch" href="/blog/assets/js/52.f06fea4e.js"><link rel="prefetch" href="/blog/assets/js/53.e138eaad.js"><link rel="prefetch" href="/blog/assets/js/54.e802ec15.js"><link rel="prefetch" href="/blog/assets/js/55.da85728d.js"><link rel="prefetch" href="/blog/assets/js/56.03097147.js"><link rel="prefetch" href="/blog/assets/js/57.6b93b5ea.js"><link rel="prefetch" href="/blog/assets/js/58.aecc6554.js"><link rel="prefetch" href="/blog/assets/js/59.70565292.js"><link rel="prefetch" href="/blog/assets/js/6.71cc5d94.js"><link rel="prefetch" href="/blog/assets/js/60.cfa40f6d.js"><link rel="prefetch" href="/blog/assets/js/62.40fe6439.js"><link rel="prefetch" href="/blog/assets/js/63.2b40b104.js"><link rel="prefetch" href="/blog/assets/js/64.66baa9d8.js"><link rel="prefetch" href="/blog/assets/js/65.f090b70f.js"><link rel="prefetch" href="/blog/assets/js/66.3adeb4b7.js"><link rel="prefetch" href="/blog/assets/js/67.f0bda73a.js"><link rel="prefetch" href="/blog/assets/js/68.52c04798.js"><link rel="prefetch" href="/blog/assets/js/69.58f28854.js"><link rel="prefetch" href="/blog/assets/js/70.e1ed8eeb.js"><link rel="prefetch" href="/blog/assets/js/71.b66e8f4e.js"><link rel="prefetch" href="/blog/assets/js/72.785f61c5.js"><link rel="prefetch" href="/blog/assets/js/73.52e216f8.js"><link rel="prefetch" href="/blog/assets/js/74.07aa1ff0.js"><link rel="prefetch" href="/blog/assets/js/75.1cae44a0.js"><link rel="prefetch" href="/blog/assets/js/76.e8ae83b9.js"><link rel="prefetch" href="/blog/assets/js/77.4e4a65f3.js"><link rel="prefetch" href="/blog/assets/js/78.ad7f1544.js"><link rel="prefetch" href="/blog/assets/js/79.991a72fa.js"><link rel="prefetch" href="/blog/assets/js/8.92831dcf.js"><link rel="prefetch" href="/blog/assets/js/80.de239793.js"><link rel="prefetch" href="/blog/assets/js/81.8166ea73.js"><link rel="prefetch" href="/blog/assets/js/9.99883fee.js"><link rel="prefetch" href="/blog/assets/js/vendors~docsearch.6e140397.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.0612dbff.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>GM的博客</h3> <p class="description" data-v-59e6cb88>博观约取、厚积薄发。</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2024
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/head.jpg" alt="GM的博客" class="logo"> <span class="site-name">GM的博客</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://deepjava-gm.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  首页
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      GM的博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/deepjava-gm" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/qq_37883866" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><!----> <!----> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>43</h3> <h6 data-v-1fad0c41>文章</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>0</h3> <h6 data-v-1fad0c41>标签</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="https://deepjava-gm.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  首页
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      GM的博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/deepjava-gm" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/qq_37883866" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/blog/" class="sidebar-heading clickable router-link-active"><span>构建自己的Java知识体系</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/" aria-current="page" class="sidebar-link">引言</a></li><li><a href="/blog/contact.html" class="sidebar-link">反馈</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/blog/javabase/一、Java基础知识" class="sidebar-heading clickable"><span>Java基础</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/blog/java-collection/一、Java集合概述" class="sidebar-heading clickable"><span>Java集合</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/blog/java-concurrent/一、Java并发编程基础知识点" class="sidebar-heading clickable open"><span>Java并发编程</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/java-concurrent/一、Java并发编程基础知识点.html" class="sidebar-link">一、Java并发编程基础知识点</a></li><li><a href="/blog/java-concurrent/二、JMM(Java内存模型)详解.html" class="sidebar-link">二、JMM(Java内存模型)详解</a></li><li><a href="/blog/java-concurrent/三、volatile关键字详解.html" class="sidebar-link">三、volatile关键字详解</a></li><li><a href="/blog/java-concurrent/四、synchronized关键字详解.html" class="sidebar-link">四、synchronized关键字详解</a></li><li><a href="/blog/java-concurrent/五、AQS详解.html" class="sidebar-link">五、AQS详解</a></li><li><a href="/blog/java-concurrent/六、LockSupport详解.html" class="sidebar-link">六、LockSupport详解</a></li><li><a href="/blog/java-concurrent/七、JUC包下的并发工具类.html" class="sidebar-link">七、JUC包下的并发工具类</a></li><li><a href="/blog/java-concurrent/八、ThreadLocal详解.html" class="sidebar-link">八、ThreadLocal详解</a></li><li><a href="/blog/java-concurrent/九、Java锁详解.html" class="sidebar-link">九、Java锁详解</a></li><li><a href="/blog/java-concurrent/十、ReentrantReadWriteLock详解.html" class="active sidebar-link">十、ReentrantReadWriteLock详解</a></li><li><a href="/blog/java-concurrent/十一、StampedLock详解.html" class="sidebar-link">十一、StampedLock详解</a></li><li><a href="/blog/java-concurrent/十二、Java线程池.html" class="sidebar-link">十二、Java线程池</a></li><li><a href="/blog/java-concurrent/十三、FutureTask详解.html" class="sidebar-link">十三、FutureTask详解</a></li><li><a href="/blog/java-concurrent/十四、CompletableFuture详解.html" class="sidebar-link">十四、CompletableFuture详解</a></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88></h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2024
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">ReentrantReadWriteLock详解</h1> <div data-v-8a445198><!----> <!----> <!----> <!----></div></div> <div class="theme-reco-content content__default"><h1 id="reentrantreadwritelock详解"><a href="#reentrantreadwritelock详解" class="header-anchor">#</a> ReentrantReadWriteLock详解</h1> <h2 id="_1、reentrantreadwritelock简介"><a href="#_1、reentrantreadwritelock简介" class="header-anchor">#</a> 1、ReentrantReadWriteLock简介</h2> <p><code>ReentrantReadWriteLock</code> 是 Java 并发包中的一个类，这个类的字面意思是可重入的读写锁。 在关于ReentrantLock这篇文章中<a href="https://deepjava.blog.csdn.net/article/details/140112505" target="_blank" rel="noopener noreferrer">https://deepjava.blog.csdn.net/article/details/140112505<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 对ReentrantLock进行了详细说明，ReentrantLock是独占锁，某一时刻只有一个线程可以获取该锁，这就导致在读多写少的场景下浪费了性能。因为多个线程对共享资源的读操作不加锁也不会出现线程安全问题。</p> <p>ReentrantReadWriteLock 就是为了提升这种读多写少场景下的并发性能而设计的。 其采用读写分离的策略，允许多个线程可以同时获取读锁，也就是读锁是共享的，写锁依然是互斥的。</p> <h2 id="_2、reentrantreadwritelock类继承结构和类属性"><a href="#_2、reentrantreadwritelock类继承结构和类属性" class="header-anchor">#</a> 2、ReentrantReadWriteLock类继承结构和类属性</h2> <p><strong>类继承结构：</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReentrantReadWriteLock</span>
        <span class="token keyword">implements</span> <span class="token class-name">ReadWriteLock</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span>

<span class="token keyword">abstract</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Sync</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span>

<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">NonfairSync</span> <span class="token keyword">extends</span> <span class="token class-name">Sync</span>

<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">FairSync</span> <span class="token keyword">extends</span> <span class="token class-name">Sync</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ReadLock</span> <span class="token keyword">implements</span> <span class="token class-name">Lock</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">WriteLock</span> <span class="token keyword">implements</span> <span class="token class-name">Lock</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span>
</code></pre></div><img src="/blog/images/38-1.png" alt="mixureSecure"> <p>描述：<br> <code>ReentrantReadWriteLock</code> 实现了 <code>ReadWriteLock</code> 接口，并且是 <code>Serializable</code>，允许其对象进行序列化。这个类主要提供读写锁的实现，并且管理读锁和写锁的状态。</p> <p><code>Sync</code> 是 <code>ReentrantReadWriteLock</code> 的内部抽象类，继承自 <code>AbstractQueuedSynchronizer</code> (AQS)。<code>Sync</code> 负责管理读写锁的同步机制，处理锁的获取和释放。它有两个主要的具体实现类：<code>NonfairSync</code> 和 <code>FairSync</code>。</p> <p><code>NonfairSync</code> 是 <code>Sync</code> 的具体实现，代表非公平锁的同步策略。它允许线程在获取锁时插队，从而可能提升性能，但可能导致线程饥饿。</p> <p><code>FairSync</code> 是 <code>Sync</code> 的具体实现，代表公平锁的同步策略。它按照线程请求的顺序来获取锁，避免线程饥饿，但可能会带来额外的性能开销。</p> <p><code>ReadLock</code> 实现了 <code>Lock</code> 接口，并且是 <code>Serializable</code>。它提供读锁的具体实现，允许多个线程同时持有读锁，只要没有线程持有写锁。<code>ReadLock</code> 提供了获取和释放读锁的方法。</p> <p><strong>类属性</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 读锁  ReadLock 是 ReentrantReadWriteLock 的静态内部类</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ReentrantReadWriteLock<span class="token punctuation">.</span>ReadLock</span> readerLock<span class="token punctuation">;</span>

<span class="token comment">// 写锁  WriteLock 是 ReentrantReadWriteLock 的静态内部类</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ReentrantReadWriteLock<span class="token punctuation">.</span>WriteLock</span> writerLock<span class="token punctuation">;</span>

<span class="token comment">// Sync  也是 ReentrantReadWriteLock 的静态内部类</span>
<span class="token keyword">final</span> <span class="token class-name">Sync</span> sync<span class="token punctuation">;</span>
</code></pre></div><p><strong>构造方法：</strong></p> <ul><li>①、无参构造</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ReentrantReadWriteLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 调用有参构造  默认非公平锁</span>
        <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><ul><li>②、有参构造<br>
传<code>true</code>表示公平锁，传<code>false</code>表示非公平锁</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ReentrantReadWriteLock</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        sync <span class="token operator">=</span> fair <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">FairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 初始化读锁</span>
        readerLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReadLock</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 初始化写锁</span>
        writerLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WriteLock</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><h2 id="_3、reentrantreadwritelock的读写锁原理分析"><a href="#_3、reentrantreadwritelock的读写锁原理分析" class="header-anchor">#</a> 3、ReentrantReadWriteLock的读写锁原理分析</h2> <p>这里先说结论，方便下面对方法深入分析。(下面这段话部分截取自《Java并发编程之美》，我觉得这本书对并发编程的解释比较通俗易懂，比较推荐阅读。)</p> <p>由上面<code>ReentrantReadWriteLock</code>类的继承结构可以看出读写锁的内部维护了一个 <code>ReadLock</code> 和一个 <code>WriteLock</code>，它们依赖 <code>Sync</code> 实现具体功能。而 <code>Sync</code> 继承自 <code>AQS</code>，并且也提供了公平和非公平的实现。我们知道 <code>AQS</code> 中只维护了一个 <code>state</code> 状态，而 <code>ReentrantReadWriteLock</code> 则需要分别维护读状态和写状态。<br>
一个 <code>int</code> 类型的<code>state</code>字段  怎么表示写和读两种状态呢 ?  ReentrantReadWriteLock 巧妙地使用 <code>state</code> 的高 16 位表示读状态，也就是获取到读锁的次数 ；使用低 16 位表示获取到写锁的线程的可重入次数。</p> <p><strong>看下Sync类的具体实现：</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">SHARED_SHIFT</span>   <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span> <span class="token comment">// 读锁计数的位移量，定义读锁计数在状态中的位置</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">SHARED_UNIT</span>    <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">SHARED_SHIFT</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 读锁计数的单位，等于 2^16</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MAX_COUNT</span>      <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">SHARED_SHIFT</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 读锁计数的最大值，等于 2^16 - 1</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">EXCLUSIVE_MASK</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">SHARED_SHIFT</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 用于提取写锁计数的掩码</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">sharedCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 从状态中提取读锁的计数</span>
    <span class="token keyword">return</span> c <span class="token operator">&gt;&gt;&gt;</span> <span class="token constant">SHARED_SHIFT</span><span class="token punctuation">;</span> <span class="token comment">// 右移 SHARED_SHIFT 位，提取高 16 位</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">exclusiveCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 从状态中提取写锁的计数</span>
    <span class="token keyword">return</span> c <span class="token operator">&amp;</span> <span class="token constant">EXCLUSIVE_MASK</span><span class="token punctuation">;</span> <span class="token comment">// 使用 EXCLUSIVE_MASK 掩码提取低 16 位</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">HoldCounter</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 当前线程获取写锁的次数  </span>
    <span class="token keyword">final</span> <span class="token keyword">long</span> tid <span class="token operator">=</span> <span class="token function">getThreadId</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 线程 ID，避免垃圾回收</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalHoldCounter</span> <span class="token keyword">extends</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HoldCounter</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">HoldCounter</span> <span class="token function">initialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 初始化每个线程的 HoldCounter 实例</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">HoldCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


<span class="token comment">// 下面是对锁持有情况的高性管理设计</span>
<span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">ThreadLocalHoldCounter</span> readHolds<span class="token punctuation">;</span> <span class="token comment">// 每个线程的读锁持有计数器</span>
<span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">HoldCounter</span> cachedHoldCounter<span class="token punctuation">;</span> <span class="token comment">// 当前线程的写锁持有计数器缓存</span>
<span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">Thread</span> firstReader <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 记录第一个获取读锁的线程</span>
<span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">int</span> firstReaderHoldCount<span class="token punctuation">;</span> <span class="token comment">// 第一个获取读锁的线程持有的读锁次数</span>

<span class="token comment">// Sync 构造函数</span>
<span class="token class-name">Sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 初始化 ThreadLocalHoldCounter，用于每个线程独立的读锁持有计数</span>
    readHolds <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocalHoldCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 确保 readHolds 字段的可见性</span>
    <span class="token function">setState</span><span class="token punctuation">(</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Sync类的其他方法 省略</span>
</code></pre></div><p>总结：<br>
在 <code>ReentrantReadWriteLock</code> 中，<code>state</code> 字段的高 16 位用于存储读锁计数，低 16 位用于存储写锁计数。这种设计巧妙地利用了位运算来在一个整数中同时存储读锁和写锁的状态。具体来说：</p> <ul><li>读锁计数：通过将 <code>state</code> 右移16位来提取。</li> <li>写锁计数：通过掩码操作提取。</li></ul> <p>此外，为了支持写锁的可重入性，<code>HoldCounter</code> 类用于记录线程对写锁的持有次数，并通过 <code>ThreadLocalHoldCounter</code> 来保证每个线程有自己的 <code>HoldCounter</code> 实例。这样设计不仅提高了锁的性能，还简化了锁的管理。</p> <h2 id="_4、reentrantreadwritelock-writelock类的核心方法详解"><a href="#_4、reentrantreadwritelock-writelock类的核心方法详解" class="header-anchor">#</a> 4、ReentrantReadWriteLock.WriteLock类的核心方法详解</h2> <h3 id="非公平写锁的获取"><a href="#非公平写锁的获取" class="header-anchor">#</a> 非公平写锁的获取</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 创建非公平的 ReentrantReadWriteLock </span>
<span class="token class-name">ReentrantReadWriteLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantReadWriteLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 获取写锁实例</span>
<span class="token class-name">ReentrantReadWriteLock<span class="token punctuation">.</span>WriteLock</span> writeLock <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 写锁上锁</span>
writeLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>WriteLock类的lock方法</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// 实际调用的是 Sync内部类的 acquire方法</span>
	<span class="token comment">// acquire方法 是Sync内部类 继承 AQS的 acquire方法</span>
    sync<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>AQS的 acquire方法</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 尝试获取锁，调用 内部类Sync的 tryAcquire 方法</span>
    <span class="token comment">// 如果 tryAcquire 返回 false，说明无法直接获取锁</span>
    <span class="token comment">// 需要将当前线程加入等待队列中</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
        <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token constant">EXCLUSIVE</span><span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 尝试将当前线程加入等待队列</span>
        <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果线程被中断，进行自我中断处理</span>
<span class="token punctuation">}</span>

</code></pre></div><p><strong>Sync内部类实现的tryAcquire方法</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    
    <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取当前线程</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取当前锁的状态</span>
    <span class="token keyword">int</span> w <span class="token operator">=</span> <span class="token function">exclusiveCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取当前写锁的计数</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果当前锁的状态不为 0，说明有锁持有</span>
        <span class="token comment">// 如果当前写锁的计数为 0，说明有读锁持有，或者持有锁的线程不是当前线程</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>w <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> current <span class="token operator">!=</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 当前线程无法获取写锁</span>

        <span class="token comment">// 检查写锁计数是否超过最大允许值</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>w <span class="token operator">+</span> <span class="token function">exclusiveCount</span><span class="token punctuation">(</span>acquires<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token constant">MAX_COUNT</span><span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;Maximum lock count exceeded&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 超过最大值，抛出异常</span>

        <span class="token comment">// 如果是重入锁，更新锁的状态</span>
        <span class="token function">setState</span><span class="token punctuation">(</span>c <span class="token operator">+</span> acquires<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 增加写锁计数</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 成功获取写锁</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 检查写锁是否应该阻塞（例如是否存在其他写锁，writerShouldBlock主要用于实现公平\非公平锁）</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">writerShouldBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span>
        <span class="token operator">!</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> c <span class="token operator">+</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 尝试更新锁的状态</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 更新失败，返回 false</span>

    <span class="token comment">// 更新当前线程为写锁的持有者</span>
    <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 设置当前线程为写锁持有者</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 成功获取写锁</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>NonfairSync类的writerShouldBlock方法</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">writerShouldBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// writers can always barge</span>
        <span class="token punctuation">}</span>
</code></pre></div><p><strong>总结</strong><br> <strong>WriteLock.lock():</strong><br>
调用 Sync.acquire(1) 尝试获取写锁。</p> <p><strong>Sync.acquire(int arg):</strong><br>
尝试通过 tryAcquire(arg) 方法直接获取写锁。<br>
如果直接获取失败，将当前线程加入等待队列，并尝试从等待队列中获取锁。</p> <p><strong>Sync.tryAcquire(int acquires):</strong><br> <strong>检查锁状态:</strong><br>
确保当前线程可以获取写锁，如果锁被其他线程持有，或计数超出最大值，则返回 false。<br> <strong>尝试获取锁:</strong><br>
如果没有其他线程持有锁，且状态更新成功，将当前线程设置为写锁持有者，并返回 true。</p> <h3 id="非公平写锁的释放"><a href="#非公平写锁的释放" class="header-anchor">#</a> 非公平写锁的释放</h3> <p><strong>WriteLock类的unlock方法</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 释放写锁</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 调用同步器（AQS）的release方法来释放锁</span>
    sync<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>AQS的release方法</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 释放锁，尝试解除对当前线程的持有</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 调用tryRelease尝试释放锁并更新状态</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryRelease</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 获取当前的头结点</span>
        <span class="token class-name">Node</span> h <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token comment">// 如果头结点不为空且其状态不为0，唤醒头结点的后继节点</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 唤醒头结点的后继节点（如果有）</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p><strong>Sync的tryRelease方法</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 检查当前线程是否持有锁</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果没有持有锁，抛出异常</span>

    <span class="token comment">// 计算释放后剩余的状态值</span>
    <span class="token keyword">int</span> nextc <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> releases<span class="token punctuation">;</span>
    <span class="token comment">// 判断释放后是否没有线程持有锁（即状态值为0）</span>
    
    <span class="token comment">// 从状态中提取写锁的计数  这里不用考虑读锁(高16位)，因为获取写锁时读锁状态值肯定为0</span>
    <span class="token keyword">boolean</span> free <span class="token operator">=</span> <span class="token function">exclusiveCount</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token comment">// 如果锁已经完全释放，将独占线程设置为null</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>free<span class="token punctuation">)</span>
        <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 更新状态值</span>
    <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> free<span class="token punctuation">;</span> <span class="token comment">// 返回锁是否完全释放的状态</span>
<span class="token punctuation">}</span>

</code></pre></div><p><strong>总结：</strong><br> <strong>WriteLock.unlock():</strong><br> <code>sync.release(1)</code> 调用会尝试释放一个写锁，如果锁成功释放，会通知等待的线程。</p> <p><strong>AQS.release(int arg):</strong><br> <code>tryRelease(arg)</code> 方法尝试释放锁并更新锁的状态。如果锁成功释放（即 <code>tryRelease</code> 返回 true），并且头结点的 <code>waitStatus</code> 不为0（表示有线程在等待），则调用 <code>unparkSuccessor(h)</code> 唤醒头结点的后继节点，使其能够尝试获得锁。</p> <p><strong>Sync.tryRelease(int releases):</strong><br>
首先检查当前线程是否持有锁，如果没有持有，则抛出 <code>IllegalMonitorStateException</code> 异常。然后计算释放锁后的状态值，如果状态值为0，则表示锁完全释放，这时候将独占线程设置为 <code>null</code>。最后更新状态值并返回锁是否完全释放的状态。</p> <h3 id="公平写锁的获取"><a href="#公平写锁的获取" class="header-anchor">#</a> 公平写锁的获取</h3> <p>公平写锁的获取过程和非公平写锁类似，但通过 <code>FairSync</code> 类的 <code>writerShouldBlock</code> 方法实现公平性。</p> <p><strong>FairSync的<code>writerShouldBlock</code> 方法</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">writerShouldBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 检查队列中是否存在其他线程（例如，读线程或写线程）在当前线程之前</span>
    <span class="token keyword">return</span> <span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>AQS的<code>hasQueuedPredecessors</code>方法</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 检查当前线程前面是否有其他线程在等待</span>
    <span class="token comment">// 正确性依赖于head在tail之前初始化，并且head.next在当前线程是队列中的第一个线程时准确</span>
    <span class="token class-name">Node</span> t <span class="token operator">=</span> tail<span class="token punctuation">;</span> <span class="token comment">// 读取尾节点</span>
    <span class="token class-name">Node</span> h <span class="token operator">=</span> head<span class="token punctuation">;</span> <span class="token comment">// 读取头节点</span>
    <span class="token class-name">Node</span> s<span class="token punctuation">;</span>

    <span class="token comment">// 判断队列中是否有线程在当前线程之前</span>
    <span class="token comment">// h != t 确保队列中至少有两个节点</span>
    <span class="token comment">// (s = h.next) == null 说明头节点的下一个节点为空，即当前线程是第一个</span>
    <span class="token comment">// s.thread != Thread.currentThread() 确保队列中的下一个节点不是当前线程</span>
    <span class="token keyword">return</span> h <span class="token operator">!=</span> t <span class="token operator">&amp;&amp;</span>
        <span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">=</span> h<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> s<span class="token punctuation">.</span>thread <span class="token operator">!=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p><strong>总结：</strong><br>
公平性实现:<br> <code>FairSync.writerShouldBlock()</code> 方法调用 <code>hasQueuedPredecessors()</code> 来检查队列中是否有其他线程在当前线程之前，从而实现公平性。</p> <p><code>hasQueuedPredecessors()</code> 方法:
检查队列: 通过比较头节点和尾节点，以及检查头节点的下一个节点来确定是否存在其他线程在当前线程之前，确保公平性。</p> <h3 id="公平写锁的释放"><a href="#公平写锁的释放" class="header-anchor">#</a> 公平写锁的释放</h3> <p>同上面非公平写锁的释放步骤。</p> <h2 id="_5、reentrantreadwritelock-readlock类的核心方法详解"><a href="#_5、reentrantreadwritelock-readlock类的核心方法详解" class="header-anchor">#</a> 5、ReentrantReadWriteLock.ReadLock类的核心方法详解</h2> <h3 id="非公平读锁的获取"><a href="#非公平读锁的获取" class="header-anchor">#</a> 非公平读锁的获取</h3> <p>因为读锁是共享锁，所以调用的方法都是<code>xxxShared</code>命名的方法。</p> <p><strong>ReadLock的lock方法</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 调用同步器（AQS）的 acquireShared 方法来尝试获取一个共享读锁</span>
    sync<span class="token punctuation">.</span><span class="token function">acquireShared</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>AQS的releaseShared方法</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 尝试获取共享锁，通过 tryAcquireShared 方法</span>
    <span class="token comment">// 如果 tryAcquireShared 返回负值，说明无法直接获取锁</span>
    <span class="token comment">// 需要进入等待队列</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token function">doAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 进入等待队列并尝试获取锁</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>Sync的tryReleaseShared方法</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> unused<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取当前线程</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取当前锁的状态</span>
    <span class="token comment">// 如果有独占锁(写锁)持有，并且持有锁的线程不是当前线程，不能获取读锁</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">exclusiveCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>
        <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> current<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">sharedCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取当前读锁的计数</span>
    <span class="token comment">// 如果读锁计数小于最大允许值且当前线程可以获取锁  (readerShouldBlock 用来保证是否公平)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">readerShouldBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
        r <span class="token operator">&lt;</span> <span class="token constant">MAX_COUNT</span> <span class="token operator">&amp;&amp;</span>
        <span class="token function">compareAndSetState</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> c <span class="token operator">+</span> <span class="token constant">SHARED_UNIT</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果当前读锁计数为 0，说明当前线程是第一个获取读锁的线程</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            firstReader <span class="token operator">=</span> current<span class="token punctuation">;</span> <span class="token comment">// 设置当前线程为第一个读线程</span>
            firstReaderHoldCount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 设置持有读锁的计数</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>firstReader <span class="token operator">==</span> current<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 如果当前线程已经是第一个读线程，增加持有读锁的计数</span>
            firstReaderHoldCount<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">// 更新读锁计数的缓存</span>
            <span class="token class-name">HoldCounter</span> rh <span class="token operator">=</span> cachedHoldCounter<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>rh <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> rh<span class="token punctuation">.</span>tid <span class="token operator">!=</span> <span class="token function">getThreadId</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">)</span>
                cachedHoldCounter <span class="token operator">=</span> rh <span class="token operator">=</span> readHolds<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rh<span class="token punctuation">.</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
                readHolds<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>rh<span class="token punctuation">)</span><span class="token punctuation">;</span>
            rh<span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 成功获取读锁</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 如果直接获取失败，调用 fullTryAcquireShared 方法进一步处理</span>
    <span class="token keyword">return</span> <span class="token function">fullTryAcquireShared</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p><strong>NonfairSync的readerShouldBlock方法</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 使用启发式方法来避免写线程的饥饿，决定读线程是否应该阻塞</span>
<span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">readerShouldBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   	<span class="token comment">// 调用AQS的apparentlyFirstQueuedIsExclusive</span>
    <span class="token keyword">return</span> <span class="token function">apparentlyFirstQueuedIsExclusive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 检查队列中的头节点的下一个节点是否是一个非共享模式的节点（即写线程）。</span>
<span class="token comment">// 如果是，则说明队列中有写线程等待，当前读操作应该阻塞</span>
<span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">apparentlyFirstQueuedIsExclusive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Node</span> h<span class="token punctuation">,</span> s<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> head<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token comment">// 确保头节点存在</span>
        <span class="token punctuation">(</span>s <span class="token operator">=</span> h<span class="token punctuation">.</span>next<span class="token punctuation">)</span>  <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token comment">// 确保头节点的下一个节点存在</span>
        <span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">isShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token comment">// 检查下一个节点是否不是共享模式（即是写线程）</span>
        s<span class="token punctuation">.</span>thread <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 确保下一个节点的线程存在</span>
<span class="token punctuation">}</span>

</code></pre></div><p><strong>Sync的fullTryAcquireShared方法</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">fullTryAcquireShared</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> current<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/*
     * 这个方法在功能上与 tryAcquireShared 方法有一些重复，
     * 但它整体上更简单，因为它不涉及重试和延迟读取持有计数的交互。
     */</span>
    <span class="token class-name">HoldCounter</span> rh <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 用于缓存持有计数的变量</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取当前锁的状态</span>
        <span class="token comment">// 检查是否有独占锁持有</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">exclusiveCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 如果独占锁被持有且持有者不是当前线程，无法获取读锁</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> current<span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 返回 -1 表示无法获取锁</span>
            <span class="token comment">// 否则，当前线程持有独占锁；在此阻塞将导致死锁。</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">readerShouldBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 检查是否需要阻塞读者线程（确保不是递归获取读锁）</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>firstReader <span class="token operator">==</span> current<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// assert firstReaderHoldCount &gt; 0; // 当前线程是第一个读线程，持有计数应大于 0</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token comment">// 当前线程不是第一个读线程，检查读锁持有计数</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>rh <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    rh <span class="token operator">=</span> cachedHoldCounter<span class="token punctuation">;</span> <span class="token comment">// 获取缓存的持有计数</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>rh <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> rh<span class="token punctuation">.</span>tid <span class="token operator">!=</span> <span class="token function">getThreadId</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token comment">// 如果缓存为空或不匹配当前线程 ID，则获取持有计数</span>
                        rh <span class="token operator">=</span> readHolds<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>rh<span class="token punctuation">.</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
                            readHolds<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果计数为 0，则移除</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>rh<span class="token punctuation">.</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
                    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 如果读锁持有计数为 0，则返回 -1 表示无法获取锁</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 检查读锁计数是否超过最大允许值</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sharedCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">MAX_COUNT</span><span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;Maximum lock count exceeded&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 超过最大值，抛出异常</span>

        <span class="token comment">// 尝试更新锁的状态</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> c <span class="token operator">+</span> <span class="token constant">SHARED_UNIT</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 更新成功，检查是否需要更新读线程的信息</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sharedCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                firstReader <span class="token operator">=</span> current<span class="token punctuation">;</span> <span class="token comment">// 设置当前线程为第一个读线程</span>
                firstReaderHoldCount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 设置持有读锁的计数</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>firstReader <span class="token operator">==</span> current<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 如果当前线程已经是第一个读线程，增加持有计数</span>
                firstReaderHoldCount<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token comment">// 更新读锁计数的缓存</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>rh <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                    rh <span class="token operator">=</span> cachedHoldCounter<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>rh <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> rh<span class="token punctuation">.</span>tid <span class="token operator">!=</span> <span class="token function">getThreadId</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">)</span>
                    rh <span class="token operator">=</span> readHolds<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rh<span class="token punctuation">.</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
                    readHolds<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>rh<span class="token punctuation">)</span><span class="token punctuation">;</span>
                rh<span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
                cachedHoldCounter <span class="token operator">=</span> rh<span class="token punctuation">;</span> <span class="token comment">// 缓存用于释放读锁</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 成功获取读锁</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><p><strong>AQS 的 doAcquireShared(int arg) 方法</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 将当前线程封装为共享节点并加入等待队列</span>
    <span class="token keyword">final</span> <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token constant">SHARED</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 标记是否获取锁失败</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 标记是否中断</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">final</span> <span class="token class-name">Node</span> p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取当前节点的前驱节点</span>
            <span class="token comment">// 如果前驱节点是头节点，尝试获取共享锁</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 如果成功获取锁，设置头节点并传播锁</span>
                    <span class="token function">setHeadAndPropagate</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 解除前驱节点的引用，帮助垃圾回收</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>interrupted<span class="token punctuation">)</span>
                        <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 处理中断</span>
                    failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                    <span class="token keyword">return</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 如果获取锁失败，判断是否需要挂起当前线程</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
                <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                interrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span>
            <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果获取锁失败，取消加入等待队列</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><p><strong>总结：</strong><br> <strong>ReadLock.lock() 方法:</strong><br>
调用 Sync.acquireShared(1) 尝试获取共享读锁。</p> <p><strong>Sync.acquireShared(int arg) 方法:</strong><br>
直接调用 tryAcquireShared(arg) 尝试获取读锁。<br>
如果直接获取失败，则调用 doAcquireShared(arg) 方法将线程加入等待队列。</p> <p><strong>Sync.tryAcquireShared(int unused) 方法:</strong><br>
检查锁状态:<br>
如果独占锁存在且持有者不是当前线程，返回 -1。<br>
尝试获取锁:<br>
如果可以直接获取锁，则更新状态，并设置读线程信息。<br>
如果直接获取失败，则调用 fullTryAcquireShared 进一步处理。</p> <p><strong>AQS.doAcquireShared(int arg) 方法:</strong><br>
将线程加入等待队列:<br>
将当前线程封装为共享节点并加入等待队列。<br>
尝试获取锁:<br>
如果当前线程的前驱节点是头节点，则尝试获取共享读锁。<br>
如果获取锁失败，则挂起当前线程，等待锁的释放。<br>
非公平读锁在获取锁时不会强制保证线程的公平性。线程可以在任何时候被允许获取读锁，前提是没有其他线程持有独占锁(写锁)。</p> <h3 id="非公平读锁的释放"><a href="#非公平读锁的释放" class="header-anchor">#</a> 非公平读锁的释放</h3> <p><strong>ReadLock的unlock() 方法</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sync<span class="token punctuation">.</span><span class="token function">releaseShared</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 尝试释放一个共享读锁</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>AQS的releaseShared(int arg) 方法</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">releaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryReleaseShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 尝试释放共享锁</span>
        <span class="token function">doReleaseShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 确保释放后正确地唤醒等待线程</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>Sync的tryReleaseShared(int unused) 方法</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryReleaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> unused<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取当前线程</span>
    <span class="token comment">// 检查当前线程是否为第一个读线程</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>firstReader <span class="token operator">==</span> current<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// assert firstReaderHoldCount &gt; 0;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>firstReaderHoldCount <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
            firstReader <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 如果持有计数为 1，清除第一个读线程</span>
        <span class="token keyword">else</span>
            firstReaderHoldCount<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">// 否则减少持有计数</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 当前线程不是第一个读线程，更新持有计数</span>
        <span class="token class-name">HoldCounter</span> rh <span class="token operator">=</span> cachedHoldCounter<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>rh <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> rh<span class="token punctuation">.</span>tid <span class="token operator">!=</span> <span class="token function">getThreadId</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">)</span>
            rh <span class="token operator">=</span> readHolds<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取持有计数</span>
        <span class="token keyword">int</span> count <span class="token operator">=</span> rh<span class="token punctuation">.</span>count<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            readHolds<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果计数为 1 或更少，移除持有计数</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
                <span class="token keyword">throw</span> <span class="token function">unmatchedUnlockException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果计数为 0 或更少，抛出异常</span>
        <span class="token punctuation">}</span>
        <span class="token operator">--</span>rh<span class="token punctuation">.</span>count<span class="token punctuation">;</span> <span class="token comment">// 减少持有计数</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 尝试更新锁的状态</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取当前状态</span>
        <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">-</span> <span class="token constant">SHARED_UNIT</span><span class="token punctuation">;</span> <span class="token comment">// 减少共享单位</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> nextc<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 更新状态</span>
            <span class="token comment">// 释放读锁对读者没有影响，但可能允许等待的写线程继续</span>
            <span class="token keyword">return</span> nextc <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 如果状态为 0，返回 true 表示所有读锁已释放</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><p><strong>AQS的doReleaseShared() 方法</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doReleaseShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Node</span> h <span class="token operator">=</span> head<span class="token punctuation">;</span> <span class="token comment">// 获取头节点</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> h <span class="token operator">!=</span> tail<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> ws <span class="token operator">=</span> h<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">==</span> <span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token constant">SIGNAL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token constant">SIGNAL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token comment">// 循环以重新检查情况</span>
                <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 唤醒后继节点</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>
                     <span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token constant">PROPAGATE</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token comment">// 循环以重新检查 CAS 失败的情况</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">==</span> head<span class="token punctuation">)</span> <span class="token comment">// 如果头节点改变，继续循环</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>总结：</strong> <strong>ReadLock.unlock() 方法:</strong><br>
调用 Sync.releaseShared(1) 尝试释放一个共享读锁。</p> <p><strong>AQS.releaseShared(int arg) 方法:</strong><br>
调用 tryReleaseShared(arg) 尝试释放共享读锁。<br>
成功释放锁后，调用 doReleaseShared() 确保正确地唤醒等待线程。</p> <p><strong>Sync.tryReleaseShared(int unused) 方法:</strong><br>
检查并更新读锁持有计数:<br>
如果当前线程是第一个读线程，更新相关信息。<br>
如果当前线程不是第一个读线程，更新缓存的持有计数。<br>
更新锁状态:<br>
尝试减少共享单位并更新状态。<br>
返回 true 表示所有读锁已释放。</p> <p><strong>AQS.doReleaseShared() 方法:</strong><br>
确保释放后正确地唤醒等待线程。<br>
如果需要传播信号，将状态设置为 PROPAGATE。</p> <h3 id="公平读锁的获取"><a href="#公平读锁的获取" class="header-anchor">#</a> 公平读锁的获取</h3> <p>整体步骤和 非公平读锁的获取差不多。 公平性的保证主要通过<code>readerShouldBlock</code>方法保证。</p> <p><strong>FairSync类的readerShouldBlock方法</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">readerShouldBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/*
     * 确保公平性：如果当前队列中存在其他线程，且这些线程在队列中处于当前读线程之前，
     * 则新来的读线程应当阻塞，以保证公平性。
     */</span>
    <span class="token keyword">return</span> <span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// AQS的hasQueuedPredecessors方法          </span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Node</span> t <span class="token operator">=</span> tail<span class="token punctuation">;</span> <span class="token comment">// 获取队列的尾节点</span>
    <span class="token class-name">Node</span> h <span class="token operator">=</span> head<span class="token punctuation">;</span> <span class="token comment">// 获取队列的头节点</span>
    <span class="token class-name">Node</span> s<span class="token punctuation">;</span> <span class="token comment">// 下一个节点</span>

    <span class="token comment">/*
     * 确保头节点存在并且不是队尾节点，且头节点的下一个节点不是当前线程。
     * 如果条件成立，说明队列中有其他线程在等待，当前线程需要阻塞。
     */</span>
    <span class="token keyword">return</span> h <span class="token operator">!=</span> t <span class="token operator">&amp;&amp;</span>
        <span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">=</span> h<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> s<span class="token punctuation">.</span>thread <span class="token operator">!=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p><strong>总结</strong><br> <strong>FairSync.readerShouldBlock():</strong><br>
通过调用 hasQueuedPredecessors() 方法来决定当前读线程是否应该阻塞。主要用于维护公平性，确保新来的读线程在获取锁之前，如果队列中有其他等待的线程，则阻塞。</p> <p><strong>hasQueuedPredecessors():</strong><br>
检查队列中是否存在其他线程在当前线程之前等待。如果队列中有等待的线程（特别是写线程），则返回 true，表示当前线程应该阻塞。<br>
这些方法通过确保读线程在获取锁之前，检查是否有其他等待的线程，从而保证了读锁的公平性。</p> <h3 id="非公平读锁的释放-2"><a href="#非公平读锁的释放-2" class="header-anchor">#</a> 非公平读锁的释放</h3> <p>同非公平读锁的释放步骤。</p> <h2 id="_6、读写锁的使用注意事项"><a href="#_6、读写锁的使用注意事项" class="header-anchor">#</a> 6、读写锁的使用注意事项</h2> <h3 id="利用锁降级保证可见性和效率的做法"><a href="#利用锁降级保证可见性和效率的做法" class="header-anchor">#</a> 利用锁降级保证可见性和效率的做法</h3> <p>补充知识点：<br>
这里说的锁降级是指线程在持有写锁的前提下，获取读锁，再释放写锁的过程。 注意全程都是有锁的状态。<br>
但是不能进行锁升级，也就是持有读锁的前提下，获取写锁，因为写锁是互斥的。</p> <h3 id="举例"><a href="#举例" class="header-anchor">#</a> 举例：</h3> <p>我养了几只特别厉害的狗，这几只狗会做大骨汤，等骨头准备好了，所有的狗狗就可以同时并发的吃骨头。如果骨头没准备好，狗狗想吃骨头就得等做骨头的那只狗先把骨头汤煮好才能全部开吃。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span></span><span class="token class-name">Lock</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span></span><span class="token class-name">ReentrantReadWriteLock</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestA</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ReentrantReadWriteLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantReadWriteLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Lock</span> readLock <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Lock</span> writeLock <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> bonePrepared <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 是否准备好骨头</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>

        <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token function">useBone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">&quot;秀逗&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


        <span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token function">useBone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">&quot;四眼&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


        <span class="token class-name">Thread</span> t3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token function">useBone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">&quot;大黄&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t3<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 真正给狗狗调用的方法</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">useBone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        readLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>bonePrepared<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 如果骨头未准备好，先释放读锁</span>
                readLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                writeLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>bonePrepared<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token comment">// 准备骨头</span>
                        <span class="token function">prepareBone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        bonePrepared <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token comment">// 准备好后，重新获取读锁</span>
                    readLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 释放写锁</span>
                    writeLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token comment">// 锁降级完成，读锁已重新获取</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 使用骨头的过程</span>
            <span class="token function">eatBone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            <span class="token comment">// 释放读锁</span>
            readLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>


    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">prepareBone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token comment">// 骨头准备的具体过程</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;机器开始自动准备骨头...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;切骨头...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;煮骨头...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;放调味料...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;准备好啦...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 模拟准备过程</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> e<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">eatBone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token comment">// 吃骨头的过程</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;开始吃骨头...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 模拟吃骨头的过程</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> e<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    
<span class="token punctuation">}</span>

</code></pre></div><p><strong>总结：</strong><br>
假设秀逗跑的最快。</p> <p><strong>线程获取读锁：</strong><br>
秀逗首先尝试获取读锁，因为读取操作通常是安全的，多个线程可以并发读取数据。
由于初始时骨头还未准备好，秀逗发现需要准备骨头，于是释放读锁并获取写锁。</p> <p><strong>获取写锁并准备骨头：</strong><br>
秀逗获取写锁后开始准备骨头（如制作骨头汤）。写锁是独占的，这确保了在准备骨头的过程中没有其他线程能够修改或读取骨头。<br>
由于写锁是互斥的，其他线程必须等待秀逗完成骨头准备。</p> <p><strong>锁降级：</strong><br>
准备完骨头后，秀逗需要释放写锁以允许其他线程访问骨头。<br>
在释放写锁之前，秀逗再一次获取读锁。这样，秀逗在告知其他狗子骨头准备好之前，自己相当于先盛了一碗骨头汤。 (还是秀逗聪明~  自己做的自己先盛一碗没毛病吧~ )</p> <p><strong>通知其他线程：</strong><br>
一旦秀逗获取到读锁，就释放写锁(虽然秀逗先偷偷盛了一碗，但仍然等通知了其他狗子之后再吃，秀逗还是很讲义气的~)，其他狗子得到通知也能获取读锁并开始吃骨头。
通过这种方式，秀逗保证了自己首先获取读锁，同时公平地让其他线程也能得到通知获取读锁。</p> <p>读写锁一般还可以用来实现线程安全的缓存。这里就不写示例了。</p> <h3 id="谈一下-single-threaded-execution模式"><a href="#谈一下-single-threaded-execution模式" class="header-anchor">#</a> 谈一下 Single Threaded Execution模式</h3> <p>下面摘自《图解Java多线程设计模式》<br>
有一座独木桥，非常细，每次只允许一个人经过。如果这个人还没有走到桥的另一头，则下一个人无法过桥。如果同时有两个人上桥，桥就会塌掉，掉进河里。</p> <p>所谓 Single Threaded Execution 模式，意即“以一个线程执行”。就像独木桥同一时间内只允许一个人通行一样，该模式用于设置限制，以确保同一时间内只能让一个线程执行处理。</p> <p>Single Threaded Execution有时候也称为临界区(critical section)或临界域(critical region )Single Threaded Execution这个名称侧重于执行处理的线程(过桥的人)，而临界区或临界域的名称则侧重于执行范围(人过的桥)。</p> <p>我觉得这个模式算是多线程同步的基础。也可以算是互斥锁的基础思想。</p> <p>上面例子中 秀逗准备骨头汤的过程就是 Single Threaded Execution。 而整个例子又是Read-Write Lock模式。</p> <h3 id="谈一下read-write-lock模式"><a href="#谈一下read-write-lock模式" class="header-anchor">#</a> 谈一下Read-Write Lock模式</h3> <p>学生们正在一起看老师在黑板上写的板书。这时，老师想擦掉板书，再写新的内容。而学生们说道:“老师，我们还没看完，请先不要擦掉!”于是，老师就会等待大家都看完。</p> <p>我觉得这个解释的角度很有意思，从读锁的角度解释。 一般我们理解读写锁，容易从写锁角度去理解，比如写的过程中不能读不能写。 上面的解释也很到位，因为写锁是互斥的也要等没有读锁的时候才能获取。</p> <p>在 Read-Write Lock模式中，读取操作和写入操作是分开考虑的。在执行读取操作之前，线程必须获取用于读取的锁。而在执行写入操作之前，线程必须获取用于写人的锁。<br>
由于当线程执行读取操作时，实例的状态不会发生变化，所以多个线程可以同时读取。但在读取时，不可以写入。<br>
当线程执行写人操作时，实例的状态就会发生变化。因此，当有一个线程正在写入时，其他线程不可以读取或写入。</p> <p>一般来说，执行互斥处理会降低程序性能。但如果把针对写入的互斥处理和针对读取的互斥处理分开来考虑，则可以提高程序性能。</p> <h2 id="_7、总结"><a href="#_7、总结" class="header-anchor">#</a> 7、总结</h2> <p>ReentrantReadWriteLock 只是读写锁思想的一个具体Java实现。 重要的是理解这种思想。掌握这些思想可以帮助我们在不同编程语言或框架中应用类似的锁机制。</p> <p>参考资源(非常感谢下面这些资料)：<br>
《图解Java多线程设计模式》<br>
《Java并发编程的艺术》<br>
https://pdai.tech/md/java/thread/java-thread-x-lock-ReentrantReadWriteLock.html<br>
https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html#reentrantreadwritelock</p></div></section> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/blog/java-concurrent/九、Java锁详解.html" class="prev">
          九、Java锁详解
        </a></span> <span class="next"><a href="/blog/java-concurrent/十一、StampedLock详解.html">
          十一、StampedLock详解
        </a></span></p></div> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-b57cc07c data-v-7dd95ae2><li class="level-2" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E3%80%81ReentrantReadWriteLock%E8%AF%A6%E8%A7%A3.html#_1、reentrantreadwritelock简介" class="sidebar-link reco-side-_1、reentrantreadwritelock简介" data-v-b57cc07c>1、ReentrantReadWriteLock简介</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E3%80%81ReentrantReadWriteLock%E8%AF%A6%E8%A7%A3.html#_2、reentrantreadwritelock类继承结构和类属性" class="sidebar-link reco-side-_2、reentrantreadwritelock类继承结构和类属性" data-v-b57cc07c>2、ReentrantReadWriteLock类继承结构和类属性</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E3%80%81ReentrantReadWriteLock%E8%AF%A6%E8%A7%A3.html#_3、reentrantreadwritelock的读写锁原理分析" class="sidebar-link reco-side-_3、reentrantreadwritelock的读写锁原理分析" data-v-b57cc07c>3、ReentrantReadWriteLock的读写锁原理分析</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E3%80%81ReentrantReadWriteLock%E8%AF%A6%E8%A7%A3.html#_4、reentrantreadwritelock-writelock类的核心方法详解" class="sidebar-link reco-side-_4、reentrantreadwritelock-writelock类的核心方法详解" data-v-b57cc07c>4、ReentrantReadWriteLock.WriteLock类的核心方法详解</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E3%80%81ReentrantReadWriteLock%E8%AF%A6%E8%A7%A3.html#非公平写锁的获取" class="sidebar-link reco-side-非公平写锁的获取" data-v-b57cc07c>非公平写锁的获取</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E3%80%81ReentrantReadWriteLock%E8%AF%A6%E8%A7%A3.html#非公平写锁的释放" class="sidebar-link reco-side-非公平写锁的释放" data-v-b57cc07c>非公平写锁的释放</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E3%80%81ReentrantReadWriteLock%E8%AF%A6%E8%A7%A3.html#公平写锁的获取" class="sidebar-link reco-side-公平写锁的获取" data-v-b57cc07c>公平写锁的获取</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E3%80%81ReentrantReadWriteLock%E8%AF%A6%E8%A7%A3.html#公平写锁的释放" class="sidebar-link reco-side-公平写锁的释放" data-v-b57cc07c>公平写锁的释放</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E3%80%81ReentrantReadWriteLock%E8%AF%A6%E8%A7%A3.html#_5、reentrantreadwritelock-readlock类的核心方法详解" class="sidebar-link reco-side-_5、reentrantreadwritelock-readlock类的核心方法详解" data-v-b57cc07c>5、ReentrantReadWriteLock.ReadLock类的核心方法详解</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E3%80%81ReentrantReadWriteLock%E8%AF%A6%E8%A7%A3.html#非公平读锁的获取" class="sidebar-link reco-side-非公平读锁的获取" data-v-b57cc07c>非公平读锁的获取</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E3%80%81ReentrantReadWriteLock%E8%AF%A6%E8%A7%A3.html#非公平读锁的释放" class="sidebar-link reco-side-非公平读锁的释放" data-v-b57cc07c>非公平读锁的释放</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E3%80%81ReentrantReadWriteLock%E8%AF%A6%E8%A7%A3.html#公平读锁的获取" class="sidebar-link reco-side-公平读锁的获取" data-v-b57cc07c>公平读锁的获取</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E3%80%81ReentrantReadWriteLock%E8%AF%A6%E8%A7%A3.html#非公平读锁的释放-2" class="sidebar-link reco-side-非公平读锁的释放-2" data-v-b57cc07c>非公平读锁的释放</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E3%80%81ReentrantReadWriteLock%E8%AF%A6%E8%A7%A3.html#_6、读写锁的使用注意事项" class="sidebar-link reco-side-_6、读写锁的使用注意事项" data-v-b57cc07c>6、读写锁的使用注意事项</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E3%80%81ReentrantReadWriteLock%E8%AF%A6%E8%A7%A3.html#利用锁降级保证可见性和效率的做法" class="sidebar-link reco-side-利用锁降级保证可见性和效率的做法" data-v-b57cc07c>利用锁降级保证可见性和效率的做法</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E3%80%81ReentrantReadWriteLock%E8%AF%A6%E8%A7%A3.html#举例" class="sidebar-link reco-side-举例" data-v-b57cc07c>举例：</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E3%80%81ReentrantReadWriteLock%E8%AF%A6%E8%A7%A3.html#谈一下-single-threaded-execution模式" class="sidebar-link reco-side-谈一下-single-threaded-execution模式" data-v-b57cc07c>谈一下 Single Threaded Execution模式</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E3%80%81ReentrantReadWriteLock%E8%AF%A6%E8%A7%A3.html#谈一下read-write-lock模式" class="sidebar-link reco-side-谈一下read-write-lock模式" data-v-b57cc07c>谈一下Read-Write Lock模式</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/java-concurrent/%E5%8D%81%E3%80%81ReentrantReadWriteLock%E8%AF%A6%E8%A7%A3.html#_7、总结" class="sidebar-link reco-side-_7、总结" data-v-b57cc07c>7、总结</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/blog/assets/js/app.86d0dcf0.js" defer></script><script src="/blog/assets/js/7.4b97e329.js" defer></script><script src="/blog/assets/js/2.cc89bbf4.js" defer></script><script src="/blog/assets/js/1.fb256d2a.js" defer></script><script src="/blog/assets/js/61.fc998d09.js" defer></script>
  </body>
</html>
